/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/jsbi/dist/jsbi-umd.js
var require_jsbi_umd = __commonJS({
  "node_modules/jsbi/dist/jsbi-umd.js"(exports, module2) {
    (function(e2, t2) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = t2() : "function" == typeof define && define.amd ? define(t2) : (e2 = e2 || self, e2.JSBI = t2());
    })(exports, function() {
      "use strict";
      var e2 = Math.imul, t2 = Math.clz32;
      function i2(e3) {
        "@babel/helpers - typeof";
        return i2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e4) {
          return typeof e4;
        } : function(e4) {
          return e4 && "function" == typeof Symbol && e4.constructor === Symbol && e4 !== Symbol.prototype ? "symbol" : typeof e4;
        }, i2(e3);
      }
      function _2(e3, t3) {
        if (!(e3 instanceof t3))
          throw new TypeError("Cannot call a class as a function");
      }
      function n2(e3, t3) {
        for (var _3, n3 = 0; n3 < t3.length; n3++)
          _3 = t3[n3], _3.enumerable = _3.enumerable || false, _3.configurable = true, "value" in _3 && (_3.writable = true), Object.defineProperty(e3, _3.key, _3);
      }
      function l2(e3, t3, i3) {
        return t3 && n2(e3.prototype, t3), i3 && n2(e3, i3), Object.defineProperty(e3, "prototype", { writable: false }), e3;
      }
      function g2(e3, t3) {
        if ("function" != typeof t3 && null !== t3)
          throw new TypeError("Super expression must either be null or a function");
        e3.prototype = Object.create(t3 && t3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), Object.defineProperty(e3, "prototype", { writable: false }), t3 && u2(e3, t3);
      }
      function a2(e3) {
        return a2 = Object.setPrototypeOf ? Object.getPrototypeOf : function(e4) {
          return e4.__proto__ || Object.getPrototypeOf(e4);
        }, a2(e3);
      }
      function u2(e3, t3) {
        return u2 = Object.setPrototypeOf || function(e4, t4) {
          return e4.__proto__ = t4, e4;
        }, u2(e3, t3);
      }
      function s2() {
        if ("undefined" == typeof Reflect || !Reflect.construct)
          return false;
        if (Reflect.construct.sham)
          return false;
        if ("function" == typeof Proxy)
          return true;
        try {
          return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          })), true;
        } catch (t3) {
          return false;
        }
      }
      function r2() {
        return r2 = s2() ? Reflect.construct : function(e3, t3, i3) {
          var _3 = [null];
          _3.push.apply(_3, t3);
          var n3 = Function.bind.apply(e3, _3), l3 = new n3();
          return i3 && u2(l3, i3.prototype), l3;
        }, r2.apply(null, arguments);
      }
      function d2(e3) {
        return -1 !== Function.toString.call(e3).indexOf("[native code]");
      }
      function h2(e3) {
        var t3 = "function" == typeof Map ? /* @__PURE__ */ new Map() : void 0;
        return h2 = function(e4) {
          function i3() {
            return r2(e4, arguments, a2(this).constructor);
          }
          if (null === e4 || !d2(e4))
            return e4;
          if ("function" != typeof e4)
            throw new TypeError("Super expression must either be null or a function");
          if ("undefined" != typeof t3) {
            if (t3.has(e4))
              return t3.get(e4);
            t3.set(e4, i3);
          }
          return i3.prototype = Object.create(e4.prototype, { constructor: { value: i3, enumerable: false, writable: true, configurable: true } }), u2(i3, e4);
        }, h2(e3);
      }
      function b2(e3) {
        if (void 0 === e3)
          throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e3;
      }
      function m2(e3, t3) {
        if (t3 && ("object" == typeof t3 || "function" == typeof t3))
          return t3;
        if (void 0 !== t3)
          throw new TypeError("Derived constructors may only return object or undefined");
        return b2(e3);
      }
      function c2(e3) {
        var t3 = s2();
        return function() {
          var i3, _3 = a2(e3);
          if (t3) {
            var n3 = a2(this).constructor;
            i3 = Reflect.construct(_3, arguments, n3);
          } else
            i3 = _3.apply(this, arguments);
          return m2(this, i3);
        };
      }
      function v2(e3, t3) {
        return y2(e3) || f2(e3, t3) || D2(e3, t3) || k2();
      }
      function y2(e3) {
        if (Array.isArray(e3))
          return e3;
      }
      function f2(e3, t3) {
        var i3 = null == e3 ? null : "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (null != i3) {
          var _3, n3, l3 = [], g3 = true, o2 = false;
          try {
            for (i3 = i3.call(e3); !(g3 = (_3 = i3.next()).done) && (l3.push(_3.value), !(t3 && l3.length === t3)); g3 = true)
              ;
          } catch (e4) {
            o2 = true, n3 = e4;
          } finally {
            try {
              g3 || null == i3["return"] || i3["return"]();
            } finally {
              if (o2)
                throw n3;
            }
          }
          return l3;
        }
      }
      function D2(e3, t3) {
        if (e3) {
          if ("string" == typeof e3)
            return p2(e3, t3);
          var i3 = Object.prototype.toString.call(e3).slice(8, -1);
          return "Object" === i3 && e3.constructor && (i3 = e3.constructor.name), "Map" === i3 || "Set" === i3 ? Array.from(e3) : "Arguments" === i3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i3) ? p2(e3, t3) : void 0;
        }
      }
      function p2(e3, t3) {
        (null == t3 || t3 > e3.length) && (t3 = e3.length);
        for (var _3 = 0, n3 = Array(t3); _3 < t3; _3++)
          n3[_3] = e3[_3];
        return n3;
      }
      function k2() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      function B2(e3, t3) {
        var _3 = "undefined" != typeof Symbol && e3[Symbol.iterator] || e3["@@iterator"];
        if (!_3) {
          if (Array.isArray(e3) || (_3 = D2(e3)) || t3 && e3 && "number" == typeof e3.length) {
            _3 && (e3 = _3);
            var n3 = 0, l3 = function() {
            };
            return { s: l3, n: function() {
              return n3 >= e3.length ? { done: true } : { done: false, value: e3[n3++] };
            }, e: function(t4) {
              throw t4;
            }, f: l3 };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var g3, a3 = true, u3 = false;
        return { s: function() {
          _3 = _3.call(e3);
        }, n: function() {
          var e4 = _3.next();
          return a3 = e4.done, e4;
        }, e: function(t4) {
          u3 = true, g3 = t4;
        }, f: function() {
          try {
            a3 || null == _3.return || _3.return();
          } finally {
            if (u3)
              throw g3;
          }
        } };
      }
      var S2 = function(e3) {
        var t3 = Math.abs, n3 = Math.max, o2 = Math.floor;
        function a3(e4, t4) {
          var i3;
          if (_2(this, a3), i3 = u3.call(this, e4), i3.sign = t4, Object.setPrototypeOf(b2(i3), a3.prototype), e4 > a3.__kMaxLength)
            throw new RangeError("Maximum BigInt size exceeded");
          return i3;
        }
        g2(a3, e3);
        var u3 = c2(a3);
        return l2(a3, [{ key: "toDebugString", value: function() {
          var e4, t4 = ["BigInt["], i3 = B2(this);
          try {
            for (i3.s(); !(e4 = i3.n()).done; ) {
              var _3 = e4.value;
              t4.push((_3 ? (_3 >>> 0).toString(16) : _3) + ", ");
            }
          } catch (e5) {
            i3.e(e5);
          } finally {
            i3.f();
          }
          return t4.push("]"), t4.join("");
        } }, { key: "toString", value: function() {
          var e4 = 0 < arguments.length && void 0 !== arguments[0] ? arguments[0] : 10;
          if (2 > e4 || 36 < e4)
            throw new RangeError("toString() radix argument must be between 2 and 36");
          return 0 === this.length ? "0" : 0 == (e4 & e4 - 1) ? a3.__toStringBasePowerOfTwo(this, e4) : a3.__toStringGeneric(this, e4, false);
        } }, { key: "valueOf", value: function() {
          throw new Error("Convert JSBI instances to native numbers using `toNumber`.");
        } }, { key: "__copy", value: function() {
          for (var e4 = new a3(this.length, this.sign), t4 = 0; t4 < this.length; t4++)
            e4[t4] = this[t4];
          return e4;
        } }, { key: "__trim", value: function() {
          for (var e4 = this.length, t4 = this[e4 - 1]; 0 === t4; )
            e4--, t4 = this[e4 - 1], this.pop();
          return 0 === e4 && (this.sign = false), this;
        } }, { key: "__initializeDigits", value: function() {
          for (var e4 = 0; e4 < this.length; e4++)
            this[e4] = 0;
        } }, { key: "__clzmsd", value: function() {
          return a3.__clz30(this.__digit(this.length - 1));
        } }, { key: "__inplaceMultiplyAdd", value: function(e4, t4, _3) {
          _3 > this.length && (_3 = this.length);
          for (var n4 = 32767 & e4, l3 = e4 >>> 15, g3 = 0, o3 = t4, u4 = 0; u4 < _3; u4++) {
            var s3 = this.__digit(u4), r3 = 32767 & s3, d3 = s3 >>> 15, h3 = a3.__imul(r3, n4), b3 = a3.__imul(r3, l3), m3 = a3.__imul(d3, n4), c3 = a3.__imul(d3, l3), v3 = o3 + h3 + g3;
            g3 = v3 >>> 30, v3 &= 1073741823, v3 += ((32767 & b3) << 15) + ((32767 & m3) << 15), g3 += v3 >>> 30, o3 = c3 + (b3 >>> 15) + (m3 >>> 15), this.__setDigit(u4, 1073741823 & v3);
          }
          if (0 !== g3 || 0 !== o3)
            throw new Error("implementation bug");
        } }, { key: "__inplaceAdd", value: function(e4, t4, _3) {
          for (var n4, l3 = 0, g3 = 0; g3 < _3; g3++)
            n4 = this.__halfDigit(t4 + g3) + e4.__halfDigit(g3) + l3, l3 = n4 >>> 15, this.__setHalfDigit(t4 + g3, 32767 & n4);
          return l3;
        } }, { key: "__inplaceSub", value: function(e4, t4, _3) {
          var n4 = 0;
          if (1 & t4) {
            t4 >>= 1;
            for (var l3 = this.__digit(t4), g3 = 32767 & l3, o3 = 0; o3 < _3 - 1 >>> 1; o3++) {
              var a4 = e4.__digit(o3), u4 = (l3 >>> 15) - (32767 & a4) - n4;
              n4 = 1 & u4 >>> 15, this.__setDigit(t4 + o3, (32767 & u4) << 15 | 32767 & g3), l3 = this.__digit(t4 + o3 + 1), g3 = (32767 & l3) - (a4 >>> 15) - n4, n4 = 1 & g3 >>> 15;
            }
            var s3 = e4.__digit(o3), r3 = (l3 >>> 15) - (32767 & s3) - n4;
            n4 = 1 & r3 >>> 15, this.__setDigit(t4 + o3, (32767 & r3) << 15 | 32767 & g3);
            if (t4 + o3 + 1 >= this.length)
              throw new RangeError("out of bounds");
            0 == (1 & _3) && (l3 = this.__digit(t4 + o3 + 1), g3 = (32767 & l3) - (s3 >>> 15) - n4, n4 = 1 & g3 >>> 15, this.__setDigit(t4 + e4.length, 1073709056 & l3 | 32767 & g3));
          } else {
            t4 >>= 1;
            for (var d3 = 0; d3 < e4.length - 1; d3++) {
              var h3 = this.__digit(t4 + d3), b3 = e4.__digit(d3), m3 = (32767 & h3) - (32767 & b3) - n4;
              n4 = 1 & m3 >>> 15;
              var c3 = (h3 >>> 15) - (b3 >>> 15) - n4;
              n4 = 1 & c3 >>> 15, this.__setDigit(t4 + d3, (32767 & c3) << 15 | 32767 & m3);
            }
            var v3 = this.__digit(t4 + d3), y3 = e4.__digit(d3), f3 = (32767 & v3) - (32767 & y3) - n4;
            n4 = 1 & f3 >>> 15;
            var D3 = 0;
            0 == (1 & _3) && (D3 = (v3 >>> 15) - (y3 >>> 15) - n4, n4 = 1 & D3 >>> 15), this.__setDigit(t4 + d3, (32767 & D3) << 15 | 32767 & f3);
          }
          return n4;
        } }, { key: "__inplaceRightShift", value: function(e4) {
          if (0 !== e4) {
            for (var t4, _3 = this.__digit(0) >>> e4, n4 = this.length - 1, l3 = 0; l3 < n4; l3++)
              t4 = this.__digit(l3 + 1), this.__setDigit(l3, 1073741823 & t4 << 30 - e4 | _3), _3 = t4 >>> e4;
            this.__setDigit(n4, _3);
          }
        } }, { key: "__digit", value: function(e4) {
          return this[e4];
        } }, { key: "__unsignedDigit", value: function(e4) {
          return this[e4] >>> 0;
        } }, { key: "__setDigit", value: function(e4, t4) {
          this[e4] = 0 | t4;
        } }, { key: "__setDigitGrow", value: function(e4, t4) {
          this[e4] = 0 | t4;
        } }, { key: "__halfDigitLength", value: function() {
          var e4 = this.length;
          return 32767 >= this.__unsignedDigit(e4 - 1) ? 2 * e4 - 1 : 2 * e4;
        } }, { key: "__halfDigit", value: function(e4) {
          return 32767 & this[e4 >>> 1] >>> 15 * (1 & e4);
        } }, { key: "__setHalfDigit", value: function(e4, t4) {
          var i3 = e4 >>> 1, _3 = this.__digit(i3), n4 = 1 & e4 ? 32767 & _3 | t4 << 15 : 1073709056 & _3 | 32767 & t4;
          this.__setDigit(i3, n4);
        } }], [{ key: "BigInt", value: function(e4) {
          var t4 = Number.isFinite;
          if ("number" == typeof e4) {
            if (0 === e4)
              return a3.__zero();
            if (a3.__isOneDigitInt(e4))
              return 0 > e4 ? a3.__oneDigit(-e4, true) : a3.__oneDigit(e4, false);
            if (!t4(e4) || o2(e4) !== e4)
              throw new RangeError("The number " + e4 + " cannot be converted to BigInt because it is not an integer");
            return a3.__fromDouble(e4);
          }
          if ("string" == typeof e4) {
            var _3 = a3.__fromString(e4);
            if (null === _3)
              throw new SyntaxError("Cannot convert " + e4 + " to a BigInt");
            return _3;
          }
          if ("boolean" == typeof e4)
            return true === e4 ? a3.__oneDigit(1, false) : a3.__zero();
          if ("object" === i2(e4)) {
            if (e4.constructor === a3)
              return e4;
            var n4 = a3.__toPrimitive(e4);
            return a3.BigInt(n4);
          }
          throw new TypeError("Cannot convert " + e4 + " to a BigInt");
        } }, { key: "toNumber", value: function(e4) {
          var t4 = e4.length;
          if (0 === t4)
            return 0;
          if (1 === t4) {
            var i3 = e4.__unsignedDigit(0);
            return e4.sign ? -i3 : i3;
          }
          var _3 = e4.__digit(t4 - 1), n4 = a3.__clz30(_3), l3 = 30 * t4 - n4;
          if (1024 < l3)
            return e4.sign ? -Infinity : 1 / 0;
          var g3 = l3 - 1, o3 = _3, u4 = t4 - 1, s3 = n4 + 3, r3 = 32 === s3 ? 0 : o3 << s3;
          r3 >>>= 12;
          var d3 = s3 - 12, h3 = 12 <= s3 ? 0 : o3 << 20 + s3, b3 = 20 + s3;
          for (0 < d3 && 0 < u4 && (u4--, o3 = e4.__digit(u4), r3 |= o3 >>> 30 - d3, h3 = o3 << d3 + 2, b3 = d3 + 2); 0 < b3 && 0 < u4; )
            u4--, o3 = e4.__digit(u4), h3 |= 30 <= b3 ? o3 << b3 - 30 : o3 >>> 30 - b3, b3 -= 30;
          var m3 = a3.__decideRounding(e4, b3, u4, o3);
          if ((1 === m3 || 0 === m3 && 1 == (1 & h3)) && (h3 = h3 + 1 >>> 0, 0 === h3 && (r3++, 0 != r3 >>> 20 && (r3 = 0, g3++, 1023 < g3))))
            return e4.sign ? -Infinity : 1 / 0;
          var c3 = e4.sign ? -2147483648 : 0;
          return g3 = g3 + 1023 << 20, a3.__kBitConversionInts[1] = c3 | g3 | r3, a3.__kBitConversionInts[0] = h3, a3.__kBitConversionDouble[0];
        } }, { key: "unaryMinus", value: function(e4) {
          if (0 === e4.length)
            return e4;
          var t4 = e4.__copy();
          return t4.sign = !e4.sign, t4;
        } }, { key: "bitwiseNot", value: function(e4) {
          return e4.sign ? a3.__absoluteSubOne(e4).__trim() : a3.__absoluteAddOne(e4, true);
        } }, { key: "exponentiate", value: function(e4, t4) {
          if (t4.sign)
            throw new RangeError("Exponent must be positive");
          if (0 === t4.length)
            return a3.__oneDigit(1, false);
          if (0 === e4.length)
            return e4;
          if (1 === e4.length && 1 === e4.__digit(0))
            return e4.sign && 0 == (1 & t4.__digit(0)) ? a3.unaryMinus(e4) : e4;
          if (1 < t4.length)
            throw new RangeError("BigInt too big");
          var i3 = t4.__unsignedDigit(0);
          if (1 === i3)
            return e4;
          if (i3 >= a3.__kMaxLengthBits)
            throw new RangeError("BigInt too big");
          if (1 === e4.length && 2 === e4.__digit(0)) {
            var _3 = 1 + (0 | i3 / 30), n4 = e4.sign && 0 != (1 & i3), l3 = new a3(_3, n4);
            l3.__initializeDigits();
            var g3 = 1 << i3 % 30;
            return l3.__setDigit(_3 - 1, g3), l3;
          }
          var o3 = null, u4 = e4;
          for (0 != (1 & i3) && (o3 = e4), i3 >>= 1; 0 !== i3; i3 >>= 1)
            u4 = a3.multiply(u4, u4), 0 != (1 & i3) && (null === o3 ? o3 = u4 : o3 = a3.multiply(o3, u4));
          return o3;
        } }, { key: "multiply", value: function(e4, t4) {
          if (0 === e4.length)
            return e4;
          if (0 === t4.length)
            return t4;
          var _3 = e4.length + t4.length;
          30 <= e4.__clzmsd() + t4.__clzmsd() && _3--;
          var n4 = new a3(_3, e4.sign !== t4.sign);
          n4.__initializeDigits();
          for (var l3 = 0; l3 < e4.length; l3++)
            a3.__multiplyAccumulate(t4, e4.__digit(l3), n4, l3);
          return n4.__trim();
        } }, { key: "divide", value: function(e4, t4) {
          if (0 === t4.length)
            throw new RangeError("Division by zero");
          if (0 > a3.__absoluteCompare(e4, t4))
            return a3.__zero();
          var i3, _3 = e4.sign !== t4.sign, n4 = t4.__unsignedDigit(0);
          if (1 === t4.length && 32767 >= n4) {
            if (1 === n4)
              return _3 === e4.sign ? e4 : a3.unaryMinus(e4);
            i3 = a3.__absoluteDivSmall(e4, n4, null);
          } else
            i3 = a3.__absoluteDivLarge(e4, t4, true, false);
          return i3.sign = _3, i3.__trim();
        } }, { key: "remainder", value: function i3(e4, t4) {
          if (0 === t4.length)
            throw new RangeError("Division by zero");
          if (0 > a3.__absoluteCompare(e4, t4))
            return e4;
          var _3 = t4.__unsignedDigit(0);
          if (1 === t4.length && 32767 >= _3) {
            if (1 === _3)
              return a3.__zero();
            var n4 = a3.__absoluteModSmall(e4, _3);
            return 0 === n4 ? a3.__zero() : a3.__oneDigit(n4, e4.sign);
          }
          var i4 = a3.__absoluteDivLarge(e4, t4, false, true);
          return i4.sign = e4.sign, i4.__trim();
        } }, { key: "add", value: function(e4, t4) {
          var i3 = e4.sign;
          return i3 === t4.sign ? a3.__absoluteAdd(e4, t4, i3) : 0 <= a3.__absoluteCompare(e4, t4) ? a3.__absoluteSub(e4, t4, i3) : a3.__absoluteSub(t4, e4, !i3);
        } }, { key: "subtract", value: function(e4, t4) {
          var i3 = e4.sign;
          return i3 === t4.sign ? 0 <= a3.__absoluteCompare(e4, t4) ? a3.__absoluteSub(e4, t4, i3) : a3.__absoluteSub(t4, e4, !i3) : a3.__absoluteAdd(e4, t4, i3);
        } }, { key: "leftShift", value: function(e4, t4) {
          return 0 === t4.length || 0 === e4.length ? e4 : t4.sign ? a3.__rightShiftByAbsolute(e4, t4) : a3.__leftShiftByAbsolute(e4, t4);
        } }, { key: "signedRightShift", value: function(e4, t4) {
          return 0 === t4.length || 0 === e4.length ? e4 : t4.sign ? a3.__leftShiftByAbsolute(e4, t4) : a3.__rightShiftByAbsolute(e4, t4);
        } }, { key: "unsignedRightShift", value: function() {
          throw new TypeError("BigInts have no unsigned right shift; use >> instead");
        } }, { key: "lessThan", value: function(e4, t4) {
          return 0 > a3.__compareToBigInt(e4, t4);
        } }, { key: "lessThanOrEqual", value: function(e4, t4) {
          return 0 >= a3.__compareToBigInt(e4, t4);
        } }, { key: "greaterThan", value: function(e4, t4) {
          return 0 < a3.__compareToBigInt(e4, t4);
        } }, { key: "greaterThanOrEqual", value: function(e4, t4) {
          return 0 <= a3.__compareToBigInt(e4, t4);
        } }, { key: "equal", value: function(e4, t4) {
          if (e4.sign !== t4.sign)
            return false;
          if (e4.length !== t4.length)
            return false;
          for (var _3 = 0; _3 < e4.length; _3++)
            if (e4.__digit(_3) !== t4.__digit(_3))
              return false;
          return true;
        } }, { key: "notEqual", value: function(e4, t4) {
          return !a3.equal(e4, t4);
        } }, { key: "bitwiseAnd", value: function(e4, t4) {
          if (!e4.sign && !t4.sign)
            return a3.__absoluteAnd(e4, t4).__trim();
          if (e4.sign && t4.sign) {
            var i3 = n3(e4.length, t4.length) + 1, _3 = a3.__absoluteSubOne(e4, i3), l3 = a3.__absoluteSubOne(t4);
            return _3 = a3.__absoluteOr(_3, l3, _3), a3.__absoluteAddOne(_3, true, _3).__trim();
          }
          if (e4.sign) {
            var g3 = [t4, e4];
            e4 = g3[0], t4 = g3[1];
          }
          return a3.__absoluteAndNot(e4, a3.__absoluteSubOne(t4)).__trim();
        } }, { key: "bitwiseXor", value: function(e4, t4) {
          if (!e4.sign && !t4.sign)
            return a3.__absoluteXor(e4, t4).__trim();
          if (e4.sign && t4.sign) {
            var i3 = n3(e4.length, t4.length), _3 = a3.__absoluteSubOne(e4, i3), l3 = a3.__absoluteSubOne(t4);
            return a3.__absoluteXor(_3, l3, _3).__trim();
          }
          var g3 = n3(e4.length, t4.length) + 1;
          if (e4.sign) {
            var o3 = [t4, e4];
            e4 = o3[0], t4 = o3[1];
          }
          var u4 = a3.__absoluteSubOne(t4, g3);
          return u4 = a3.__absoluteXor(u4, e4, u4), a3.__absoluteAddOne(u4, true, u4).__trim();
        } }, { key: "bitwiseOr", value: function(e4, t4) {
          var i3 = n3(e4.length, t4.length);
          if (!e4.sign && !t4.sign)
            return a3.__absoluteOr(e4, t4).__trim();
          if (e4.sign && t4.sign) {
            var _3 = a3.__absoluteSubOne(e4, i3), l3 = a3.__absoluteSubOne(t4);
            return _3 = a3.__absoluteAnd(_3, l3, _3), a3.__absoluteAddOne(_3, true, _3).__trim();
          }
          if (e4.sign) {
            var g3 = [t4, e4];
            e4 = g3[0], t4 = g3[1];
          }
          var o3 = a3.__absoluteSubOne(t4, i3);
          return o3 = a3.__absoluteAndNot(o3, e4, o3), a3.__absoluteAddOne(o3, true, o3).__trim();
        } }, { key: "asIntN", value: function(e4, t4) {
          if (0 === t4.length)
            return t4;
          if (e4 = o2(e4), 0 > e4)
            throw new RangeError("Invalid value: not (convertible to) a safe integer");
          if (0 === e4)
            return a3.__zero();
          if (e4 >= a3.__kMaxLengthBits)
            return t4;
          var _3 = 0 | (e4 + 29) / 30;
          if (t4.length < _3)
            return t4;
          var l3 = t4.__unsignedDigit(_3 - 1), g3 = 1 << (e4 - 1) % 30;
          if (t4.length === _3 && l3 < g3)
            return t4;
          if (!((l3 & g3) === g3))
            return a3.__truncateToNBits(e4, t4);
          if (!t4.sign)
            return a3.__truncateAndSubFromPowerOfTwo(e4, t4, true);
          if (0 == (l3 & g3 - 1)) {
            for (var u4 = _3 - 2; 0 <= u4; u4--)
              if (0 !== t4.__digit(u4))
                return a3.__truncateAndSubFromPowerOfTwo(e4, t4, false);
            return t4.length === _3 && l3 === g3 ? t4 : a3.__truncateToNBits(e4, t4);
          }
          return a3.__truncateAndSubFromPowerOfTwo(e4, t4, false);
        } }, { key: "asUintN", value: function(e4, t4) {
          if (0 === t4.length)
            return t4;
          if (e4 = o2(e4), 0 > e4)
            throw new RangeError("Invalid value: not (convertible to) a safe integer");
          if (0 === e4)
            return a3.__zero();
          if (t4.sign) {
            if (e4 > a3.__kMaxLengthBits)
              throw new RangeError("BigInt too big");
            return a3.__truncateAndSubFromPowerOfTwo(e4, t4, false);
          }
          if (e4 >= a3.__kMaxLengthBits)
            return t4;
          var i3 = 0 | (e4 + 29) / 30;
          if (t4.length < i3)
            return t4;
          var _3 = e4 % 30;
          if (t4.length == i3) {
            if (0 === _3)
              return t4;
            var l3 = t4.__digit(i3 - 1);
            if (0 == l3 >>> _3)
              return t4;
          }
          return a3.__truncateToNBits(e4, t4);
        } }, { key: "ADD", value: function(e4, t4) {
          if (e4 = a3.__toPrimitive(e4), t4 = a3.__toPrimitive(t4), "string" == typeof e4)
            return "string" != typeof t4 && (t4 = t4.toString()), e4 + t4;
          if ("string" == typeof t4)
            return e4.toString() + t4;
          if (e4 = a3.__toNumeric(e4), t4 = a3.__toNumeric(t4), a3.__isBigInt(e4) && a3.__isBigInt(t4))
            return a3.add(e4, t4);
          if ("number" == typeof e4 && "number" == typeof t4)
            return e4 + t4;
          throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
        } }, { key: "LT", value: function(e4, t4) {
          return a3.__compare(e4, t4, 0);
        } }, { key: "LE", value: function(e4, t4) {
          return a3.__compare(e4, t4, 1);
        } }, { key: "GT", value: function(e4, t4) {
          return a3.__compare(e4, t4, 2);
        } }, { key: "GE", value: function(e4, t4) {
          return a3.__compare(e4, t4, 3);
        } }, { key: "EQ", value: function(e4, t4) {
          for (; ; ) {
            if (a3.__isBigInt(e4))
              return a3.__isBigInt(t4) ? a3.equal(e4, t4) : a3.EQ(t4, e4);
            if ("number" == typeof e4) {
              if (a3.__isBigInt(t4))
                return a3.__equalToNumber(t4, e4);
              if ("object" !== i2(t4))
                return e4 == t4;
              t4 = a3.__toPrimitive(t4);
            } else if ("string" == typeof e4) {
              if (a3.__isBigInt(t4))
                return e4 = a3.__fromString(e4), null !== e4 && a3.equal(e4, t4);
              if ("object" !== i2(t4))
                return e4 == t4;
              t4 = a3.__toPrimitive(t4);
            } else if ("boolean" == typeof e4) {
              if (a3.__isBigInt(t4))
                return a3.__equalToNumber(t4, +e4);
              if ("object" !== i2(t4))
                return e4 == t4;
              t4 = a3.__toPrimitive(t4);
            } else if ("symbol" === i2(e4)) {
              if (a3.__isBigInt(t4))
                return false;
              if ("object" !== i2(t4))
                return e4 == t4;
              t4 = a3.__toPrimitive(t4);
            } else if ("object" === i2(e4)) {
              if ("object" === i2(t4) && t4.constructor !== a3)
                return e4 == t4;
              e4 = a3.__toPrimitive(e4);
            } else
              return e4 == t4;
          }
        } }, { key: "NE", value: function(e4, t4) {
          return !a3.EQ(e4, t4);
        } }, { key: "DataViewGetBigInt64", value: function(e4, t4) {
          var i3 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2];
          return a3.asIntN(64, a3.DataViewGetBigUint64(e4, t4, i3));
        } }, { key: "DataViewGetBigUint64", value: function(e4, t4) {
          var i3 = !!(2 < arguments.length && void 0 !== arguments[2]) && arguments[2], _3 = i3 ? [4, 0] : [0, 4], n4 = v2(_3, 2), g3 = n4[0], o3 = n4[1], l3 = e4.getUint32(t4 + g3, i3), u4 = e4.getUint32(t4 + o3, i3), s3 = new a3(3, false);
          return s3.__setDigit(0, 1073741823 & u4), s3.__setDigit(1, (268435455 & l3) << 2 | u4 >>> 30), s3.__setDigit(2, l3 >>> 28), s3.__trim();
        } }, { key: "DataViewSetBigInt64", value: function(e4, t4, i3) {
          var _3 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
          a3.DataViewSetBigUint64(e4, t4, i3, _3);
        } }, { key: "DataViewSetBigUint64", value: function(e4, t4, i3) {
          var _3 = !!(3 < arguments.length && void 0 !== arguments[3]) && arguments[3];
          i3 = a3.asUintN(64, i3);
          var n4 = 0, g3 = 0;
          if (0 < i3.length && (g3 = i3.__digit(0), 1 < i3.length)) {
            var o3 = i3.__digit(1);
            g3 |= o3 << 30, n4 = o3 >>> 2, 2 < i3.length && (n4 |= i3.__digit(2) << 28);
          }
          var u4 = _3 ? [4, 0] : [0, 4], s3 = v2(u4, 2), r3 = s3[0], d3 = s3[1];
          e4.setUint32(t4 + r3, n4, _3), e4.setUint32(t4 + d3, g3, _3);
        } }, { key: "__zero", value: function() {
          return new a3(0, false);
        } }, { key: "__oneDigit", value: function(e4, t4) {
          var i3 = new a3(1, t4);
          return i3.__setDigit(0, e4), i3;
        } }, { key: "__decideRounding", value: function(e4, t4, i3, _3) {
          if (0 < t4)
            return -1;
          var n4;
          if (0 > t4)
            n4 = -t4 - 1;
          else {
            if (0 === i3)
              return -1;
            i3--, _3 = e4.__digit(i3), n4 = 29;
          }
          var l3 = 1 << n4;
          if (0 == (_3 & l3))
            return -1;
          if (l3 -= 1, 0 != (_3 & l3))
            return 1;
          for (; 0 < i3; )
            if (i3--, 0 !== e4.__digit(i3))
              return 1;
          return 0;
        } }, { key: "__fromDouble", value: function(e4) {
          a3.__kBitConversionDouble[0] = e4;
          var t4, i3 = 2047 & a3.__kBitConversionInts[1] >>> 20, _3 = i3 - 1023, n4 = (0 | _3 / 30) + 1, l3 = new a3(n4, 0 > e4), g3 = 1048575 & a3.__kBitConversionInts[1] | 1048576, o3 = a3.__kBitConversionInts[0], u4 = 20, s3 = _3 % 30, r3 = 0;
          if (s3 < u4) {
            var d3 = u4 - s3;
            r3 = d3 + 32, t4 = g3 >>> d3, g3 = g3 << 32 - d3 | o3 >>> d3, o3 <<= 32 - d3;
          } else if (s3 === u4)
            r3 = 32, t4 = g3, g3 = o3, o3 = 0;
          else {
            var h3 = s3 - u4;
            r3 = 32 - h3, t4 = g3 << h3 | o3 >>> 32 - h3, g3 = o3 << h3, o3 = 0;
          }
          l3.__setDigit(n4 - 1, t4);
          for (var b3 = n4 - 2; 0 <= b3; b3--)
            0 < r3 ? (r3 -= 30, t4 = g3 >>> 2, g3 = g3 << 30 | o3 >>> 2, o3 <<= 30) : t4 = 0, l3.__setDigit(b3, t4);
          return l3.__trim();
        } }, { key: "__isWhitespace", value: function(e4) {
          return !!(13 >= e4 && 9 <= e4) || (159 >= e4 ? 32 == e4 : 131071 >= e4 ? 160 == e4 || 5760 == e4 : 196607 >= e4 ? (e4 &= 131071, 10 >= e4 || 40 == e4 || 41 == e4 || 47 == e4 || 95 == e4 || 4096 == e4) : 65279 == e4);
        } }, { key: "__fromString", value: function(e4) {
          var t4 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 0, i3 = 0, _3 = e4.length, n4 = 0;
          if (n4 === _3)
            return a3.__zero();
          for (var l3 = e4.charCodeAt(n4); a3.__isWhitespace(l3); ) {
            if (++n4 === _3)
              return a3.__zero();
            l3 = e4.charCodeAt(n4);
          }
          if (43 === l3) {
            if (++n4 === _3)
              return null;
            l3 = e4.charCodeAt(n4), i3 = 1;
          } else if (45 === l3) {
            if (++n4 === _3)
              return null;
            l3 = e4.charCodeAt(n4), i3 = -1;
          }
          if (0 === t4) {
            if (t4 = 10, 48 === l3) {
              if (++n4 === _3)
                return a3.__zero();
              if (l3 = e4.charCodeAt(n4), 88 === l3 || 120 === l3) {
                if (t4 = 16, ++n4 === _3)
                  return null;
                l3 = e4.charCodeAt(n4);
              } else if (79 === l3 || 111 === l3) {
                if (t4 = 8, ++n4 === _3)
                  return null;
                l3 = e4.charCodeAt(n4);
              } else if (66 === l3 || 98 === l3) {
                if (t4 = 2, ++n4 === _3)
                  return null;
                l3 = e4.charCodeAt(n4);
              }
            }
          } else if (16 === t4 && 48 === l3) {
            if (++n4 === _3)
              return a3.__zero();
            if (l3 = e4.charCodeAt(n4), 88 === l3 || 120 === l3) {
              if (++n4 === _3)
                return null;
              l3 = e4.charCodeAt(n4);
            }
          }
          if (0 !== i3 && 10 !== t4)
            return null;
          for (; 48 === l3; ) {
            if (++n4 === _3)
              return a3.__zero();
            l3 = e4.charCodeAt(n4);
          }
          var g3 = _3 - n4, o3 = a3.__kMaxBitsPerChar[t4], u4 = a3.__kBitsPerCharTableMultiplier - 1;
          if (g3 > 1073741824 / o3)
            return null;
          var s3 = o3 * g3 + u4 >>> a3.__kBitsPerCharTableShift, r3 = new a3(0 | (s3 + 29) / 30, false), h3 = 10 > t4 ? t4 : 10, b3 = 10 < t4 ? t4 - 10 : 0;
          if (0 == (t4 & t4 - 1)) {
            o3 >>= a3.__kBitsPerCharTableShift;
            var c3 = [], v3 = [], y3 = false;
            do {
              for (var f3, D3 = 0, p3 = 0; ; ) {
                if (f3 = void 0, l3 - 48 >>> 0 < h3)
                  f3 = l3 - 48;
                else if ((32 | l3) - 97 >>> 0 < b3)
                  f3 = (32 | l3) - 87;
                else {
                  y3 = true;
                  break;
                }
                if (p3 += o3, D3 = D3 << o3 | f3, ++n4 === _3) {
                  y3 = true;
                  break;
                }
                if (l3 = e4.charCodeAt(n4), 30 < p3 + o3)
                  break;
              }
              c3.push(D3), v3.push(p3);
            } while (!y3);
            a3.__fillFromParts(r3, c3, v3);
          } else {
            r3.__initializeDigits();
            var k3 = false, B3 = 0;
            do {
              for (var S3, C2 = 0, I2 = 1; ; ) {
                if (S3 = void 0, l3 - 48 >>> 0 < h3)
                  S3 = l3 - 48;
                else if ((32 | l3) - 97 >>> 0 < b3)
                  S3 = (32 | l3) - 87;
                else {
                  k3 = true;
                  break;
                }
                var A2 = I2 * t4;
                if (1073741823 < A2)
                  break;
                if (I2 = A2, C2 = C2 * t4 + S3, B3++, ++n4 === _3) {
                  k3 = true;
                  break;
                }
                l3 = e4.charCodeAt(n4);
              }
              u4 = 30 * a3.__kBitsPerCharTableMultiplier - 1;
              var m3 = 0 | (o3 * B3 + u4 >>> a3.__kBitsPerCharTableShift) / 30;
              r3.__inplaceMultiplyAdd(I2, C2, m3);
            } while (!k3);
          }
          if (n4 !== _3) {
            if (!a3.__isWhitespace(l3))
              return null;
            for (n4++; n4 < _3; n4++)
              if (l3 = e4.charCodeAt(n4), !a3.__isWhitespace(l3))
                return null;
          }
          return r3.sign = -1 === i3, r3.__trim();
        } }, { key: "__fillFromParts", value: function(e4, t4, _3) {
          for (var n4 = 0, l3 = 0, g3 = 0, o3 = t4.length - 1; 0 <= o3; o3--) {
            var a4 = t4[o3], u4 = _3[o3];
            l3 |= a4 << g3, g3 += u4, 30 === g3 ? (e4.__setDigit(n4++, l3), g3 = 0, l3 = 0) : 30 < g3 && (e4.__setDigit(n4++, 1073741823 & l3), g3 -= 30, l3 = a4 >>> u4 - g3);
          }
          if (0 !== l3) {
            if (n4 >= e4.length)
              throw new Error("implementation bug");
            e4.__setDigit(n4++, l3);
          }
          for (; n4 < e4.length; n4++)
            e4.__setDigit(n4, 0);
        } }, { key: "__toStringBasePowerOfTwo", value: function(e4, t4) {
          var _3 = e4.length, n4 = t4 - 1;
          n4 = (85 & n4 >>> 1) + (85 & n4), n4 = (51 & n4 >>> 2) + (51 & n4), n4 = (15 & n4 >>> 4) + (15 & n4);
          var l3 = n4, g3 = t4 - 1, o3 = e4.__digit(_3 - 1), u4 = a3.__clz30(o3), s3 = 0 | (30 * _3 - u4 + l3 - 1) / l3;
          if (e4.sign && s3++, 268435456 < s3)
            throw new Error("string too long");
          for (var r3 = Array(s3), d3 = s3 - 1, h3 = 0, b3 = 0, m3 = 0; m3 < _3 - 1; m3++) {
            var c3 = e4.__digit(m3), v3 = (h3 | c3 << b3) & g3;
            r3[d3--] = a3.__kConversionChars[v3];
            var y3 = l3 - b3;
            for (h3 = c3 >>> y3, b3 = 30 - y3; b3 >= l3; )
              r3[d3--] = a3.__kConversionChars[h3 & g3], h3 >>>= l3, b3 -= l3;
          }
          var f3 = (h3 | o3 << b3) & g3;
          for (r3[d3--] = a3.__kConversionChars[f3], h3 = o3 >>> l3 - b3; 0 !== h3; )
            r3[d3--] = a3.__kConversionChars[h3 & g3], h3 >>>= l3;
          if (e4.sign && (r3[d3--] = "-"), -1 !== d3)
            throw new Error("implementation bug");
          return r3.join("");
        } }, { key: "__toStringGeneric", value: function(e4, t4, _3) {
          var n4 = e4.length;
          if (0 === n4)
            return "";
          if (1 === n4) {
            var l3 = e4.__unsignedDigit(0).toString(t4);
            return false === _3 && e4.sign && (l3 = "-" + l3), l3;
          }
          var g3 = 30 * n4 - a3.__clz30(e4.__digit(n4 - 1)), o3 = a3.__kMaxBitsPerChar[t4], u4 = o3 - 1, s3 = g3 * a3.__kBitsPerCharTableMultiplier;
          s3 += u4 - 1, s3 = 0 | s3 / u4;
          var r3, d3, h3 = s3 + 1 >> 1, b3 = a3.exponentiate(a3.__oneDigit(t4, false), a3.__oneDigit(h3, false)), m3 = b3.__unsignedDigit(0);
          if (1 === b3.length && 32767 >= m3) {
            r3 = new a3(e4.length, false), r3.__initializeDigits();
            for (var c3, v3 = 0, y3 = 2 * e4.length - 1; 0 <= y3; y3--)
              c3 = v3 << 15 | e4.__halfDigit(y3), r3.__setHalfDigit(y3, 0 | c3 / m3), v3 = 0 | c3 % m3;
            d3 = v3.toString(t4);
          } else {
            var f3 = a3.__absoluteDivLarge(e4, b3, true, true);
            r3 = f3.quotient;
            var D3 = f3.remainder.__trim();
            d3 = a3.__toStringGeneric(D3, t4, true);
          }
          r3.__trim();
          for (var p3 = a3.__toStringGeneric(r3, t4, true); d3.length < h3; )
            d3 = "0" + d3;
          return false === _3 && e4.sign && (p3 = "-" + p3), p3 + d3;
        } }, { key: "__unequalSign", value: function(e4) {
          return e4 ? -1 : 1;
        } }, { key: "__absoluteGreater", value: function(e4) {
          return e4 ? -1 : 1;
        } }, { key: "__absoluteLess", value: function(e4) {
          return e4 ? 1 : -1;
        } }, { key: "__compareToBigInt", value: function(e4, t4) {
          var i3 = e4.sign;
          if (i3 !== t4.sign)
            return a3.__unequalSign(i3);
          var _3 = a3.__absoluteCompare(e4, t4);
          return 0 < _3 ? a3.__absoluteGreater(i3) : 0 > _3 ? a3.__absoluteLess(i3) : 0;
        } }, { key: "__compareToNumber", value: function(e4, i3) {
          if (a3.__isOneDigitInt(i3)) {
            var _3 = e4.sign, n4 = 0 > i3;
            if (_3 !== n4)
              return a3.__unequalSign(_3);
            if (0 === e4.length) {
              if (n4)
                throw new Error("implementation bug");
              return 0 === i3 ? 0 : -1;
            }
            if (1 < e4.length)
              return a3.__absoluteGreater(_3);
            var l3 = t3(i3), g3 = e4.__unsignedDigit(0);
            return g3 > l3 ? a3.__absoluteGreater(_3) : g3 < l3 ? a3.__absoluteLess(_3) : 0;
          }
          return a3.__compareToDouble(e4, i3);
        } }, { key: "__compareToDouble", value: function(e4, t4) {
          if (t4 !== t4)
            return t4;
          if (t4 === 1 / 0)
            return -1;
          if (t4 === -Infinity)
            return 1;
          var i3 = e4.sign;
          if (i3 !== 0 > t4)
            return a3.__unequalSign(i3);
          if (0 === t4)
            throw new Error("implementation bug: should be handled elsewhere");
          if (0 === e4.length)
            return -1;
          a3.__kBitConversionDouble[0] = t4;
          var _3 = 2047 & a3.__kBitConversionInts[1] >>> 20;
          if (2047 == _3)
            throw new Error("implementation bug: handled elsewhere");
          var n4 = _3 - 1023;
          if (0 > n4)
            return a3.__absoluteGreater(i3);
          var l3 = e4.length, g3 = e4.__digit(l3 - 1), o3 = a3.__clz30(g3), u4 = 30 * l3 - o3, s3 = n4 + 1;
          if (u4 < s3)
            return a3.__absoluteLess(i3);
          if (u4 > s3)
            return a3.__absoluteGreater(i3);
          var r3 = 1048576 | 1048575 & a3.__kBitConversionInts[1], d3 = a3.__kBitConversionInts[0], h3 = 20, b3 = 29 - o3;
          if (b3 !== (0 | (u4 - 1) % 30))
            throw new Error("implementation bug");
          var m3, c3 = 0;
          if (b3 < h3) {
            var v3 = h3 - b3;
            c3 = v3 + 32, m3 = r3 >>> v3, r3 = r3 << 32 - v3 | d3 >>> v3, d3 <<= 32 - v3;
          } else if (b3 === h3)
            c3 = 32, m3 = r3, r3 = d3, d3 = 0;
          else {
            var y3 = b3 - h3;
            c3 = 32 - y3, m3 = r3 << y3 | d3 >>> 32 - y3, r3 = d3 << y3, d3 = 0;
          }
          if (g3 >>>= 0, m3 >>>= 0, g3 > m3)
            return a3.__absoluteGreater(i3);
          if (g3 < m3)
            return a3.__absoluteLess(i3);
          for (var f3 = l3 - 2; 0 <= f3; f3--) {
            0 < c3 ? (c3 -= 30, m3 = r3 >>> 2, r3 = r3 << 30 | d3 >>> 2, d3 <<= 30) : m3 = 0;
            var D3 = e4.__unsignedDigit(f3);
            if (D3 > m3)
              return a3.__absoluteGreater(i3);
            if (D3 < m3)
              return a3.__absoluteLess(i3);
          }
          if (0 !== r3 || 0 !== d3) {
            if (0 === c3)
              throw new Error("implementation bug");
            return a3.__absoluteLess(i3);
          }
          return 0;
        } }, { key: "__equalToNumber", value: function(e4, i3) {
          return a3.__isOneDigitInt(i3) ? 0 === i3 ? 0 === e4.length : 1 === e4.length && e4.sign === 0 > i3 && e4.__unsignedDigit(0) === t3(i3) : 0 === a3.__compareToDouble(e4, i3);
        } }, { key: "__comparisonResultToBool", value: function(e4, t4) {
          return 0 === t4 ? 0 > e4 : 1 === t4 ? 0 >= e4 : 2 === t4 ? 0 < e4 : 3 === t4 ? 0 <= e4 : void 0;
        } }, { key: "__compare", value: function(e4, t4, i3) {
          if (e4 = a3.__toPrimitive(e4), t4 = a3.__toPrimitive(t4), "string" == typeof e4 && "string" == typeof t4)
            switch (i3) {
              case 0:
                return e4 < t4;
              case 1:
                return e4 <= t4;
              case 2:
                return e4 > t4;
              case 3:
                return e4 >= t4;
            }
          if (a3.__isBigInt(e4) && "string" == typeof t4)
            return t4 = a3.__fromString(t4), null !== t4 && a3.__comparisonResultToBool(a3.__compareToBigInt(e4, t4), i3);
          if ("string" == typeof e4 && a3.__isBigInt(t4))
            return e4 = a3.__fromString(e4), null !== e4 && a3.__comparisonResultToBool(a3.__compareToBigInt(e4, t4), i3);
          if (e4 = a3.__toNumeric(e4), t4 = a3.__toNumeric(t4), a3.__isBigInt(e4)) {
            if (a3.__isBigInt(t4))
              return a3.__comparisonResultToBool(a3.__compareToBigInt(e4, t4), i3);
            if ("number" != typeof t4)
              throw new Error("implementation bug");
            return a3.__comparisonResultToBool(a3.__compareToNumber(e4, t4), i3);
          }
          if ("number" != typeof e4)
            throw new Error("implementation bug");
          if (a3.__isBigInt(t4))
            return a3.__comparisonResultToBool(a3.__compareToNumber(t4, e4), 2 ^ i3);
          if ("number" != typeof t4)
            throw new Error("implementation bug");
          return 0 === i3 ? e4 < t4 : 1 === i3 ? e4 <= t4 : 2 === i3 ? e4 > t4 : 3 === i3 ? e4 >= t4 : void 0;
        } }, { key: "__absoluteAdd", value: function(e4, t4, _3) {
          if (e4.length < t4.length)
            return a3.__absoluteAdd(t4, e4, _3);
          if (0 === e4.length)
            return e4;
          if (0 === t4.length)
            return e4.sign === _3 ? e4 : a3.unaryMinus(e4);
          var n4 = e4.length;
          (0 === e4.__clzmsd() || t4.length === e4.length && 0 === t4.__clzmsd()) && n4++;
          for (var l3, g3 = new a3(n4, _3), o3 = 0, u4 = 0; u4 < t4.length; u4++)
            l3 = e4.__digit(u4) + t4.__digit(u4) + o3, o3 = l3 >>> 30, g3.__setDigit(u4, 1073741823 & l3);
          for (; u4 < e4.length; u4++) {
            var s3 = e4.__digit(u4) + o3;
            o3 = s3 >>> 30, g3.__setDigit(u4, 1073741823 & s3);
          }
          return u4 < g3.length && g3.__setDigit(u4, o3), g3.__trim();
        } }, { key: "__absoluteSub", value: function(e4, t4, _3) {
          if (0 === e4.length)
            return e4;
          if (0 === t4.length)
            return e4.sign === _3 ? e4 : a3.unaryMinus(e4);
          for (var n4, l3 = new a3(e4.length, _3), g3 = 0, o3 = 0; o3 < t4.length; o3++)
            n4 = e4.__digit(o3) - t4.__digit(o3) - g3, g3 = 1 & n4 >>> 30, l3.__setDigit(o3, 1073741823 & n4);
          for (; o3 < e4.length; o3++) {
            var u4 = e4.__digit(o3) - g3;
            g3 = 1 & u4 >>> 30, l3.__setDigit(o3, 1073741823 & u4);
          }
          return l3.__trim();
        } }, { key: "__absoluteAddOne", value: function(e4, t4) {
          var _3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length;
          null === _3 ? _3 = new a3(n4, t4) : _3.sign = t4;
          for (var l3, g3 = 1, o3 = 0; o3 < n4; o3++)
            l3 = e4.__digit(o3) + g3, g3 = l3 >>> 30, _3.__setDigit(o3, 1073741823 & l3);
          return 0 !== g3 && _3.__setDigitGrow(n4, 1), _3;
        } }, { key: "__absoluteSubOne", value: function(e4, t4) {
          var _3 = e4.length;
          t4 = t4 || _3;
          for (var n4, l3 = new a3(t4, false), g3 = 1, o3 = 0; o3 < _3; o3++)
            n4 = e4.__digit(o3) - g3, g3 = 1 & n4 >>> 30, l3.__setDigit(o3, 1073741823 & n4);
          if (0 !== g3)
            throw new Error("implementation bug");
          for (var u4 = _3; u4 < t4; u4++)
            l3.__setDigit(u4, 0);
          return l3;
        } }, { key: "__absoluteAnd", value: function(e4, t4) {
          var _3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
          if (n4 < l3) {
            g3 = n4;
            var o3 = e4, u4 = n4;
            e4 = t4, n4 = l3, t4 = o3, l3 = u4;
          }
          var s3 = g3;
          null === _3 ? _3 = new a3(s3, false) : s3 = _3.length;
          for (var r3 = 0; r3 < g3; r3++)
            _3.__setDigit(r3, e4.__digit(r3) & t4.__digit(r3));
          for (; r3 < s3; r3++)
            _3.__setDigit(r3, 0);
          return _3;
        } }, { key: "__absoluteAndNot", value: function(e4, t4) {
          var _3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
          n4 < l3 && (g3 = n4);
          var o3 = n4;
          null === _3 ? _3 = new a3(o3, false) : o3 = _3.length;
          for (var u4 = 0; u4 < g3; u4++)
            _3.__setDigit(u4, e4.__digit(u4) & ~t4.__digit(u4));
          for (; u4 < n4; u4++)
            _3.__setDigit(u4, e4.__digit(u4));
          for (; u4 < o3; u4++)
            _3.__setDigit(u4, 0);
          return _3;
        } }, { key: "__absoluteOr", value: function(e4, t4) {
          var _3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
          if (n4 < l3) {
            g3 = n4;
            var o3 = e4, u4 = n4;
            e4 = t4, n4 = l3, t4 = o3, l3 = u4;
          }
          var s3 = n4;
          null === _3 ? _3 = new a3(s3, false) : s3 = _3.length;
          for (var r3 = 0; r3 < g3; r3++)
            _3.__setDigit(r3, e4.__digit(r3) | t4.__digit(r3));
          for (; r3 < n4; r3++)
            _3.__setDigit(r3, e4.__digit(r3));
          for (; r3 < s3; r3++)
            _3.__setDigit(r3, 0);
          return _3;
        } }, { key: "__absoluteXor", value: function(e4, t4) {
          var _3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null, n4 = e4.length, l3 = t4.length, g3 = l3;
          if (n4 < l3) {
            g3 = n4;
            var o3 = e4, u4 = n4;
            e4 = t4, n4 = l3, t4 = o3, l3 = u4;
          }
          var s3 = n4;
          null === _3 ? _3 = new a3(s3, false) : s3 = _3.length;
          for (var r3 = 0; r3 < g3; r3++)
            _3.__setDigit(r3, e4.__digit(r3) ^ t4.__digit(r3));
          for (; r3 < n4; r3++)
            _3.__setDigit(r3, e4.__digit(r3));
          for (; r3 < s3; r3++)
            _3.__setDigit(r3, 0);
          return _3;
        } }, { key: "__absoluteCompare", value: function(e4, t4) {
          var _3 = e4.length - t4.length;
          if (0 != _3)
            return _3;
          for (var n4 = e4.length - 1; 0 <= n4 && e4.__digit(n4) === t4.__digit(n4); )
            n4--;
          return 0 > n4 ? 0 : e4.__unsignedDigit(n4) > t4.__unsignedDigit(n4) ? 1 : -1;
        } }, { key: "__multiplyAccumulate", value: function(e4, t4, _3, n4) {
          if (0 !== t4) {
            for (var l3 = 32767 & t4, g3 = t4 >>> 15, o3 = 0, u4 = 0, s3 = 0; s3 < e4.length; s3++, n4++) {
              var r3 = _3.__digit(n4), d3 = e4.__digit(s3), h3 = 32767 & d3, b3 = d3 >>> 15, m3 = a3.__imul(h3, l3), c3 = a3.__imul(h3, g3), v3 = a3.__imul(b3, l3), y3 = a3.__imul(b3, g3);
              r3 += u4 + m3 + o3, o3 = r3 >>> 30, r3 &= 1073741823, r3 += ((32767 & c3) << 15) + ((32767 & v3) << 15), o3 += r3 >>> 30, u4 = y3 + (c3 >>> 15) + (v3 >>> 15), _3.__setDigit(n4, 1073741823 & r3);
            }
            for (; 0 !== o3 || 0 !== u4; n4++) {
              var f3 = _3.__digit(n4);
              f3 += o3 + u4, u4 = 0, o3 = f3 >>> 30, _3.__setDigit(n4, 1073741823 & f3);
            }
          }
        } }, { key: "__internalMultiplyAdd", value: function(e4, t4, _3, l3, g3) {
          for (var o3 = _3, u4 = 0, s3 = 0; s3 < l3; s3++) {
            var d3 = e4.__digit(s3), h3 = a3.__imul(32767 & d3, t4), b3 = a3.__imul(d3 >>> 15, t4), m3 = h3 + ((32767 & b3) << 15) + u4 + o3;
            o3 = m3 >>> 30, u4 = b3 >>> 15, g3.__setDigit(s3, 1073741823 & m3);
          }
          if (g3.length > l3)
            for (g3.__setDigit(l3++, o3 + u4); l3 < g3.length; )
              g3.__setDigit(l3++, 0);
          else if (0 !== o3 + u4)
            throw new Error("implementation bug");
        } }, { key: "__absoluteDivSmall", value: function(e4, t4) {
          var _3 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
          null === _3 && (_3 = new a3(e4.length, false));
          for (var n4 = 0, l3 = 2 * e4.length - 1; 0 <= l3; l3 -= 2) {
            var g3 = (n4 << 15 | e4.__halfDigit(l3)) >>> 0, o3 = 0 | g3 / t4;
            n4 = 0 | g3 % t4, g3 = (n4 << 15 | e4.__halfDigit(l3 - 1)) >>> 0;
            var u4 = 0 | g3 / t4;
            n4 = 0 | g3 % t4, _3.__setDigit(l3 >>> 1, o3 << 15 | u4);
          }
          return _3;
        } }, { key: "__absoluteModSmall", value: function(e4, t4) {
          for (var _3, n4 = 0, l3 = 2 * e4.length - 1; 0 <= l3; l3--)
            _3 = (n4 << 15 | e4.__halfDigit(l3)) >>> 0, n4 = 0 | _3 % t4;
          return n4;
        } }, { key: "__absoluteDivLarge", value: function(e4, t4, i3, _3) {
          var l3 = t4.__halfDigitLength(), n4 = t4.length, g3 = e4.__halfDigitLength() - l3, o3 = null;
          i3 && (o3 = new a3(g3 + 2 >>> 1, false), o3.__initializeDigits());
          var s3 = new a3(l3 + 2 >>> 1, false);
          s3.__initializeDigits();
          var r3 = a3.__clz15(t4.__halfDigit(l3 - 1));
          0 < r3 && (t4 = a3.__specialLeftShift(t4, r3, 0));
          for (var d3 = a3.__specialLeftShift(e4, r3, 1), u4 = t4.__halfDigit(l3 - 1), h3 = 0, b3 = g3; 0 <= b3; b3--) {
            var m3 = 32767, v3 = d3.__halfDigit(b3 + l3);
            if (v3 !== u4) {
              var y3 = (v3 << 15 | d3.__halfDigit(b3 + l3 - 1)) >>> 0;
              m3 = 0 | y3 / u4;
              for (var f3 = 0 | y3 % u4, D3 = t4.__halfDigit(l3 - 2), p3 = d3.__halfDigit(b3 + l3 - 2); a3.__imul(m3, D3) >>> 0 > (f3 << 16 | p3) >>> 0 && (m3--, f3 += u4, !(32767 < f3)); )
                ;
            }
            a3.__internalMultiplyAdd(t4, m3, 0, n4, s3);
            var k3 = d3.__inplaceSub(s3, b3, l3 + 1);
            0 !== k3 && (k3 = d3.__inplaceAdd(t4, b3, l3), d3.__setHalfDigit(b3 + l3, 32767 & d3.__halfDigit(b3 + l3) + k3), m3--), i3 && (1 & b3 ? h3 = m3 << 15 : o3.__setDigit(b3 >>> 1, h3 | m3));
          }
          if (_3)
            return d3.__inplaceRightShift(r3), i3 ? { quotient: o3, remainder: d3 } : d3;
          if (i3)
            return o3;
          throw new Error("unreachable");
        } }, { key: "__clz15", value: function(e4) {
          return a3.__clz30(e4) - 15;
        } }, { key: "__specialLeftShift", value: function(e4, t4, _3) {
          var l3 = e4.length, n4 = new a3(l3 + _3, false);
          if (0 === t4) {
            for (var g3 = 0; g3 < l3; g3++)
              n4.__setDigit(g3, e4.__digit(g3));
            return 0 < _3 && n4.__setDigit(l3, 0), n4;
          }
          for (var o3, u4 = 0, s3 = 0; s3 < l3; s3++)
            o3 = e4.__digit(s3), n4.__setDigit(s3, 1073741823 & o3 << t4 | u4), u4 = o3 >>> 30 - t4;
          return 0 < _3 && n4.__setDigit(l3, u4), n4;
        } }, { key: "__leftShiftByAbsolute", value: function(e4, t4) {
          var _3 = a3.__toShiftAmount(t4);
          if (0 > _3)
            throw new RangeError("BigInt too big");
          var n4 = 0 | _3 / 30, l3 = _3 % 30, g3 = e4.length, o3 = 0 !== l3 && 0 != e4.__digit(g3 - 1) >>> 30 - l3, u4 = g3 + n4 + (o3 ? 1 : 0), s3 = new a3(u4, e4.sign);
          if (0 === l3) {
            for (var r3 = 0; r3 < n4; r3++)
              s3.__setDigit(r3, 0);
            for (; r3 < u4; r3++)
              s3.__setDigit(r3, e4.__digit(r3 - n4));
          } else {
            for (var h3 = 0, b3 = 0; b3 < n4; b3++)
              s3.__setDigit(b3, 0);
            for (var m3, c3 = 0; c3 < g3; c3++)
              m3 = e4.__digit(c3), s3.__setDigit(c3 + n4, 1073741823 & m3 << l3 | h3), h3 = m3 >>> 30 - l3;
            if (o3)
              s3.__setDigit(g3 + n4, h3);
            else if (0 !== h3)
              throw new Error("implementation bug");
          }
          return s3.__trim();
        } }, { key: "__rightShiftByAbsolute", value: function(e4, t4) {
          var _3 = e4.length, n4 = e4.sign, l3 = a3.__toShiftAmount(t4);
          if (0 > l3)
            return a3.__rightShiftByMaximum(n4);
          var g3 = 0 | l3 / 30, o3 = l3 % 30, u4 = _3 - g3;
          if (0 >= u4)
            return a3.__rightShiftByMaximum(n4);
          var s3 = false;
          if (n4) {
            if (0 != (e4.__digit(g3) & (1 << o3) - 1))
              s3 = true;
            else
              for (var r3 = 0; r3 < g3; r3++)
                if (0 !== e4.__digit(r3)) {
                  s3 = true;
                  break;
                }
          }
          if (s3 && 0 === o3) {
            var h3 = e4.__digit(_3 - 1);
            0 == ~h3 && u4++;
          }
          var b3 = new a3(u4, n4);
          if (0 === o3) {
            b3.__setDigit(u4 - 1, 0);
            for (var m3 = g3; m3 < _3; m3++)
              b3.__setDigit(m3 - g3, e4.__digit(m3));
          } else {
            for (var c3, v3 = e4.__digit(g3) >>> o3, y3 = _3 - g3 - 1, f3 = 0; f3 < y3; f3++)
              c3 = e4.__digit(f3 + g3 + 1), b3.__setDigit(f3, 1073741823 & c3 << 30 - o3 | v3), v3 = c3 >>> o3;
            b3.__setDigit(y3, v3);
          }
          return s3 && (b3 = a3.__absoluteAddOne(b3, true, b3)), b3.__trim();
        } }, { key: "__rightShiftByMaximum", value: function(e4) {
          return e4 ? a3.__oneDigit(1, true) : a3.__zero();
        } }, { key: "__toShiftAmount", value: function(e4) {
          if (1 < e4.length)
            return -1;
          var t4 = e4.__unsignedDigit(0);
          return t4 > a3.__kMaxLengthBits ? -1 : t4;
        } }, { key: "__toPrimitive", value: function(e4) {
          var t4 = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : "default";
          if ("object" !== i2(e4))
            return e4;
          if (e4.constructor === a3)
            return e4;
          if ("undefined" != typeof Symbol && "symbol" === i2(Symbol.toPrimitive)) {
            var _3 = e4[Symbol.toPrimitive];
            if (_3) {
              var n4 = _3(t4);
              if ("object" !== i2(n4))
                return n4;
              throw new TypeError("Cannot convert object to primitive value");
            }
          }
          var l3 = e4.valueOf;
          if (l3) {
            var g3 = l3.call(e4);
            if ("object" !== i2(g3))
              return g3;
          }
          var o3 = e4.toString;
          if (o3) {
            var u4 = o3.call(e4);
            if ("object" !== i2(u4))
              return u4;
          }
          throw new TypeError("Cannot convert object to primitive value");
        } }, { key: "__toNumeric", value: function(e4) {
          return a3.__isBigInt(e4) ? e4 : +e4;
        } }, { key: "__isBigInt", value: function(e4) {
          return "object" === i2(e4) && null !== e4 && e4.constructor === a3;
        } }, { key: "__truncateToNBits", value: function(e4, t4) {
          for (var _3 = 0 | (e4 + 29) / 30, n4 = new a3(_3, t4.sign), l3 = _3 - 1, g3 = 0; g3 < l3; g3++)
            n4.__setDigit(g3, t4.__digit(g3));
          var o3 = t4.__digit(l3);
          if (0 != e4 % 30) {
            var u4 = 32 - e4 % 30;
            o3 = o3 << u4 >>> u4;
          }
          return n4.__setDigit(l3, o3), n4.__trim();
        } }, { key: "__truncateAndSubFromPowerOfTwo", value: function(e4, t4, _3) {
          for (var n4 = Math.min, l3, g3 = 0 | (e4 + 29) / 30, o3 = new a3(g3, _3), u4 = 0, s3 = g3 - 1, d3 = 0, h3 = n4(s3, t4.length); u4 < h3; u4++)
            l3 = 0 - t4.__digit(u4) - d3, d3 = 1 & l3 >>> 30, o3.__setDigit(u4, 1073741823 & l3);
          for (; u4 < s3; u4++)
            o3.__setDigit(u4, 0 | 1073741823 & -d3);
          var b3, m3 = s3 < t4.length ? t4.__digit(s3) : 0, c3 = e4 % 30;
          if (0 === c3)
            b3 = 0 - m3 - d3, b3 &= 1073741823;
          else {
            var v3 = 32 - c3;
            m3 = m3 << v3 >>> v3;
            var y3 = 1 << 32 - v3;
            b3 = y3 - m3 - d3, b3 &= y3 - 1;
          }
          return o3.__setDigit(s3, b3), o3.__trim();
        } }, { key: "__digitPow", value: function(e4, t4) {
          for (var i3 = 1; 0 < t4; )
            1 & t4 && (i3 *= e4), t4 >>>= 1, e4 *= e4;
          return i3;
        } }, { key: "__isOneDigitInt", value: function(e4) {
          return (1073741823 & e4) === e4;
        } }]), a3;
      }(h2(Array));
      return S2.__kMaxLength = 33554432, S2.__kMaxLengthBits = S2.__kMaxLength << 5, S2.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], S2.__kBitsPerCharTableShift = 5, S2.__kBitsPerCharTableMultiplier = 1 << S2.__kBitsPerCharTableShift, S2.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], S2.__kBitConversionBuffer = new ArrayBuffer(8), S2.__kBitConversionDouble = new Float64Array(S2.__kBitConversionBuffer), S2.__kBitConversionInts = new Int32Array(S2.__kBitConversionBuffer), S2.__clz30 = t2 ? function(e3) {
        return t2(e3) - 2;
      } : function(e3) {
        var t3 = Math.LN2, i3 = Math.log;
        return 0 === e3 ? 30 : 0 | 29 - (0 | i3(e3 >>> 0) / t3);
      }, S2.__imul = e2 || function(e3, t3) {
        return 0 | e3 * t3;
      }, S2;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => O2Plugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var JekyllSetting = class {
  constructor() {
    this.attachmentsFolder = "attachments";
    this.readyFolder = "ready";
    this.backupFolder = "backup";
    this._jekyllPath = "";
    this._jekyllRelativeResourcePath = "assets/img";
    this._isAutoCreateFolder = false;
  }
  get jekyllPath() {
    return this._jekyllPath;
  }
  set jekyllPath(value) {
    this._jekyllPath = value;
  }
  get jekyllRelativeResourcePath() {
    return this._jekyllRelativeResourcePath;
  }
  set jekyllRelativeResourcePath(value) {
    this._jekyllRelativeResourcePath = value;
  }
  get isEnableBanner() {
    return this._isEnableBanner;
  }
  set isEnableBanner(value) {
    this._isEnableBanner = value;
  }
  get isEnableCurlyBraceConvertMode() {
    return this._isEnableCurlyBraceConvertMode;
  }
  set isEnableCurlyBraceConvertMode(value) {
    this._isEnableCurlyBraceConvertMode = value;
  }
  get isEnableUpdateFrontmatterTimeOnEdit() {
    return this._isEnableUpdateFrontmatterTimeOnEdit;
  }
  set isEnableUpdateFrontmatterTimeOnEdit(value) {
    this._isEnableUpdateFrontmatterTimeOnEdit = value;
  }
  get isAutoCreateFolder() {
    return this._isAutoCreateFolder;
  }
  set isAutoCreateFolder(value) {
    this._isAutoCreateFolder = value;
  }
  targetPath() {
    return `${this._jekyllPath}/_posts`;
  }
  resourcePath() {
    return `${this._jekyllPath}/${this._jekyllRelativeResourcePath}`;
  }
  afterPropertiesSet() {
    if (this._jekyllPath === "") {
      new import_obsidian.Notice("Jekyll path is not set.", 5e3);
      return false;
    }
    return true;
  }
  // FIXME: As I know, abstraction is better solution but this is something weird.
  // temporary solution
  jekyllSetting() {
    return this;
  }
};
var O2SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h1", {
      text: "Settings for O2 plugin"
    });
    this.containerEl.createEl("h2", {
      text: "Path Settings"
    });
    this.addReadyFolderSetting();
    this.addBackupFolderSetting();
    this.addAttachmentsFolderSetting();
    this.addJekyllPathSetting();
    this.addJekyllRelativeResourcePathSetting();
    this.containerEl.createEl("h2", {
      text: "Features"
    });
    this.enableCurlyBraceSetting();
    this.enableUpdateFrontmatterTimeOnEditSetting();
    this.enableAutoCreateFolderSetting();
  }
  enableUpdateFrontmatterTimeOnEditSetting() {
    const jekyllSetting = this.plugin.settings.jekyllSetting();
    new import_obsidian.Setting(this.containerEl).setName("Replace date frontmatter to updated time").setDesc("If 'updated' frontmatter exists, replace the value of 'date' frontmatter with the value of 'updated' frontmatter.").addToggle((toggle) => toggle.setValue(jekyllSetting.isEnableUpdateFrontmatterTimeOnEdit).onChange(async (value) => {
      jekyllSetting.isEnableUpdateFrontmatterTimeOnEdit = value;
      await this.plugin.saveSettings();
    }));
  }
  enableAutoCreateFolderSetting() {
    const jekyllSetting = this.plugin.settings.jekyllSetting();
    new import_obsidian.Setting(this.containerEl).setName("Auto create folders").setDesc("Automatically create necessary folders if they do not exist.").addToggle((toggle) => toggle.setValue(jekyllSetting.isAutoCreateFolder).onChange(async (value) => {
      jekyllSetting.isAutoCreateFolder = value;
      await this.plugin.saveSettings();
    }));
  }
  enableCurlyBraceSetting() {
    const jekyllSetting = this.plugin.settings.jekyllSetting();
    new import_obsidian.Setting(this.containerEl).setName("Curly Brace Conversion").setDesc("Convert double curly braces to jekyll raw tag.").addToggle((toggle) => toggle.setValue(jekyllSetting.isEnableCurlyBraceConvertMode).onChange(async (value) => {
      jekyllSetting.isEnableCurlyBraceConvertMode = value;
      await this.plugin.saveSettings();
    }));
  }
  enableBannerSetting() {
    const jekyllSetting = this.plugin.settings.jekyllSetting();
    new import_obsidian.Setting(this.containerEl).setName("Banner Conversion").setDesc("Convert image path of front matter to jekyll banner.").addToggle((toggle) => toggle.setValue(jekyllSetting.isEnableBanner).onChange(async (value) => {
      jekyllSetting.isEnableBanner = value;
      await this.plugin.saveSettings();
    }));
  }
  addJekyllPathSetting() {
    const jekyllSetting = this.plugin.settings.jekyllSetting();
    new import_obsidian.Setting(this.containerEl).setName("Jekyll path").setDesc("The absolute path where Jekyll is installed.").addText((text) => text.setPlaceholder("Enter path").setValue(jekyllSetting.jekyllPath).onChange(async (value) => {
      jekyllSetting.jekyllPath = value;
      await this.plugin.saveSettings();
    }));
  }
  addJekyllRelativeResourcePathSetting() {
    const jekyllSetting = this.plugin.settings.jekyllSetting();
    new import_obsidian.Setting(this.containerEl).setName("Relative resource path").setDesc("The relative path where resources are stored. (default: assets/img)").addText((text) => text.setPlaceholder("Enter path").setValue(jekyllSetting.jekyllRelativeResourcePath).onChange(async (value) => {
      jekyllSetting.jekyllRelativeResourcePath = value;
      await this.plugin.saveSettings();
    }));
  }
  addAttachmentsFolderSetting() {
    new import_obsidian.Setting(this.containerEl).setName("Folder to store attachments in").setDesc("Where the attachments will be stored.").addText((text) => text.setPlaceholder("Enter folder name").setValue(this.plugin.settings.attachmentsFolder).onChange(async (value) => {
      this.plugin.settings.attachmentsFolder = value;
      await this.plugin.saveSettings();
    }));
  }
  addReadyFolderSetting() {
    new import_obsidian.Setting(this.containerEl).setName("Folder to convert notes to another syntax in").setDesc("Where the notes will be converted to another syntax.").addText((text) => text.setPlaceholder("Enter folder name").setValue(this.plugin.settings.readyFolder).onChange(async (value) => {
      this.plugin.settings.readyFolder = value;
      await this.plugin.saveSettings();
    }));
  }
  addBackupFolderSetting() {
    new import_obsidian.Setting(this.containerEl).setName("Folder to backup notes before execute converting process in").setDesc("Where the notes will be backup before converting.").addText((text) => text.setPlaceholder("Enter folder name").setValue(this.plugin.settings.backupFolder).onChange(async (value) => {
      this.plugin.settings.backupFolder = value;
      await this.plugin.saveSettings();
    }));
  }
};

// node_modules/@js-temporal/polyfill/dist/index.esm.js
var import_jsbi = __toESM(require_jsbi_umd(), 1);
var t = {};
function MakeIntrinsicClass(e2, t2) {
  Object.defineProperty(e2.prototype, Symbol.toStringTag, { value: t2, writable: false, enumerable: false, configurable: true });
  for (const t3 of Object.getOwnPropertyNames(e2)) {
    const r2 = Object.getOwnPropertyDescriptor(e2, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2, t3, r2));
  }
  for (const t3 of Object.getOwnPropertyNames(e2.prototype)) {
    const r2 = Object.getOwnPropertyDescriptor(e2.prototype, t3);
    r2.configurable && r2.enumerable && (r2.enumerable = false, Object.defineProperty(e2.prototype, t3, r2));
  }
  DefineIntrinsic(t2, e2), DefineIntrinsic(`${t2}.prototype`, e2.prototype);
}
function DefineIntrinsic(e2, r2) {
  const o2 = `%${e2}%`;
  if (void 0 !== t[o2])
    throw new Error(`intrinsic ${e2} already exists`);
  t[o2] = r2;
}
function GetIntrinsic(e2) {
  return t[e2];
}
var r;
var o;
var n = "slot-epochNanoSeconds";
var a = "slot-timezone-identifier";
var i = "slot-year";
var s = "slot-month";
var l = "slot-day";
var d = "slot-hour";
var m = "slot-minute";
var c = "slot-second";
var h = "slot-millisecond";
var u = "slot-microsecond";
var T = "slot-nanosecond";
var p = "slot-calendar";
var f = "slot-date-brand";
var y = "slot-year-month-brand";
var I = "slot-month-day-brand";
var S = "slot-cached-instant";
var g = "slot-time-zone";
var w = "slot-years";
var D = "slot-months";
var G = "slot-weeks";
var v = "slot-days";
var C = "slot-hours";
var O = "slot-minutes";
var b = "slot-seconds";
var E = "slot-milliseconds";
var M = "slot-microseconds";
var R = "slot-nanoseconds";
var F = "slot-calendar-identifier";
var Y = /* @__PURE__ */ new WeakMap();
var P = Symbol.for("@@Temporal__GetSlots");
(r = globalThis)[P] || (r[P] = function _GetSlots(e2) {
  return Y.get(e2);
});
var Z = globalThis[P];
var B = Symbol.for("@@Temporal__CreateSlots");
(o = globalThis)[B] || (o[B] = function _CreateSlots(e2) {
  Y.set(e2, /* @__PURE__ */ Object.create(null));
});
var N = globalThis[B];
function HasSlot(e2, ...t2) {
  if (!e2 || "object" != typeof e2)
    return false;
  const r2 = Z(e2);
  return !!r2 && t2.every((e3) => e3 in r2);
}
function GetSlot(e2, t2) {
  var _a;
  const r2 = (_a = Z(e2)) == null ? void 0 : _a[t2];
  if (void 0 === r2)
    throw new TypeError(`Missing internal slot ${t2}`);
  return r2;
}
function SetSlot(e2, t2, r2) {
  const o2 = Z(e2);
  if (void 0 === o2)
    throw new TypeError("Missing slots for the given container");
  if (o2[t2])
    throw new TypeError(`${t2} already has set`);
  o2[t2] = r2;
}
var j = /\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;
var $ = new RegExp("(?:" + [`(?:${j.source})(?:\\/(?:${j.source}))*`, "Etc/GMT(?:0|[-+]\\d{1,2})", "GMT[-+]?0", "EST5EDT", "CST6CDT", "MST7MDT", "PST8PDT", /(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source].join("|") + ")");
var k = /(?:[+\u2212-]\d{6}|\d{4})/;
var U = /(?:0[1-9]|1[0-2])/;
var A = /(?:0[1-9]|[12]\d|3[01])/;
var L = new RegExp(`(${k.source})(?:-(${U.source})-(${A.source})|(${U.source})(${A.source}))`);
var x = /(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/;
var W = /([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/;
var q = new RegExp(`([zZ])|${W.source}?`);
var H = /\[(!)?([a-z_][a-z0-9_-]*)=([A-Za-z0-9]+(?:-[A-Za-z0-9]+)*)\]/g;
var V = new RegExp([`^${L.source}`, `(?:(?:T|\\s+)${x.source}(?:${q.source})?)?`, `(?:\\[!?(${$.source})\\])?`, `((?:${H.source})*)$`].join(""), "i");
var z = new RegExp([`^T?${x.source}`, `(?:${q.source})?`, `(?:\\[!?${$.source}\\])?`, `((?:${H.source})*)$`].join(""), "i");
var _ = new RegExp(`^(${k.source})-?(${U.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var J = new RegExp(`^(?:--)?(${U.source})-?(${A.source})(?:\\[!?${$.source}\\])?((?:${H.source})*)$`);
var K = /(\d+)(?:[.,](\d{1,9}))?/;
var X = new RegExp(`(?:${K.source}H)?(?:${K.source}M)?(?:${K.source}S)?`);
var Q = new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${X.source})?$`, "i");
var ee = Array.prototype.includes;
var te = Array.prototype.push;
var re = globalThis.Intl.DateTimeFormat;
var oe = Math.min;
var ne = Math.max;
var ae = Math.abs;
var ie = Math.floor;
var se = Math.sign;
var le = Math.trunc;
var de = Number.isNaN;
var me = Number.isFinite;
var ce = Number;
var he = String;
var ue = Number.MAX_SAFE_INTEGER;
var Te = Object.create;
var pe = Object.getOwnPropertyDescriptor;
var fe = Reflect.apply;
var ye = Reflect.ownKeys;
var Ie = import_jsbi.default.BigInt(0);
var Se = import_jsbi.default.BigInt(1);
var ge = import_jsbi.default.BigInt(60);
var we = import_jsbi.default.BigInt(24);
var De = import_jsbi.default.BigInt(1e3);
var Ge = import_jsbi.default.BigInt(1e6);
var ve = import_jsbi.default.BigInt(1e9);
var Ce = import_jsbi.default.BigInt(-1);
var Oe = import_jsbi.default.multiply(import_jsbi.default.BigInt(3600), ve);
var be = import_jsbi.default.multiply(ge, ve);
var Ee = import_jsbi.default.multiply(Oe, we);
var Me = import_jsbi.default.multiply(import_jsbi.default.BigInt(-86400), import_jsbi.default.BigInt(1e17));
var Re = import_jsbi.default.multiply(import_jsbi.default.BigInt(86400), import_jsbi.default.BigInt(1e17));
var Fe = -271821;
var Ye = 275760;
var Pe = import_jsbi.default.multiply(import_jsbi.default.BigInt(-388152), import_jsbi.default.BigInt(1e13));
var Ze = import_jsbi.default.multiply(Ee, import_jsbi.default.BigInt(3660));
var Be = import_jsbi.default.multiply(Ee, import_jsbi.default.BigInt(366));
var Ne = import_jsbi.default.multiply(Ee, import_jsbi.default.BigInt(14));
var je = ["iso8601", "hebrew", "islamic", "islamic-umalqura", "islamic-tbla", "islamic-civil", "islamic-rgsa", "islamicc", "persian", "ethiopic", "ethioaa", "coptic", "chinese", "dangi", "roc", "indian", "buddhist", "japanese", "gregory"];
function isZero(t2) {
  return import_jsbi.default.equal(t2, Ie);
}
function GetMethod(e2, t2) {
  const r2 = e2[t2];
  if (void 0 !== r2)
    return r2;
}
function Call(e2, t2, r2) {
  const o2 = arguments.length > 2 ? r2 : [];
  return fe(e2, t2, o2);
}
function IsObject(e2) {
  return "object" == typeof e2 && null !== e2 || "function" == typeof e2;
}
function ToNumber(e2) {
  if ("bigint" == typeof e2)
    throw new TypeError("Cannot convert BigInt to number");
  return ce(e2);
}
function ToIntegerOrInfinity(e2) {
  const t2 = ToNumber(e2);
  if (de(t2) || 0 === t2)
    return 0;
  if (!me(t2))
    return t2;
  const r2 = ie(ae(t2));
  return 0 === r2 ? 0 : se(t2) * r2;
}
function IsIntegralNumber(e2) {
  if ("number" != typeof e2 || de(e2) || !me(e2))
    return false;
  const t2 = ae(e2);
  return ie(t2) === t2;
}
function ToString(e2) {
  if ("symbol" == typeof e2)
    throw new TypeError("Cannot convert a Symbol value to a String");
  return he(e2);
}
function ToIntegerWithTruncation(e2) {
  const t2 = ToNumber(e2);
  if (0 === t2)
    return 0;
  if (de(t2) || !me(t2))
    throw new RangeError("invalid number value");
  const r2 = le(t2);
  return 0 === r2 ? 0 : r2;
}
function ToPositiveIntegerWithTruncation(e2, t2) {
  const r2 = ToIntegerWithTruncation(e2);
  if (r2 <= 0) {
    if (void 0 !== t2)
      throw new RangeError(`property '${t2}' cannot be a a number less than one`);
    throw new RangeError("Cannot convert a number less than one to a positive integer");
  }
  return r2;
}
function ToIntegerIfIntegral(e2) {
  const t2 = ToNumber(e2);
  if (!me(t2))
    throw new RangeError("infinity is out of range");
  if (!IsIntegralNumber(t2))
    throw new RangeError(`unsupported fractional value ${e2}`);
  return 0 === t2 ? 0 : t2;
}
function divmod(t2, r2) {
  return { quotient: import_jsbi.default.divide(t2, r2), remainder: import_jsbi.default.remainder(t2, r2) };
}
function isNegativeJSBI(t2) {
  return import_jsbi.default.lessThan(t2, Ie);
}
function signJSBI(e2) {
  return isZero(e2) ? 0 : isNegativeJSBI(e2) ? -1 : 1;
}
function abs(t2) {
  return import_jsbi.default.lessThan(t2, Ie) ? import_jsbi.default.multiply(t2, Ce) : t2;
}
var $e = /* @__PURE__ */ new Map([["year", ToIntegerWithTruncation], ["month", ToPositiveIntegerWithTruncation], ["monthCode", ToString], ["day", ToPositiveIntegerWithTruncation], ["hour", ToIntegerWithTruncation], ["minute", ToIntegerWithTruncation], ["second", ToIntegerWithTruncation], ["millisecond", ToIntegerWithTruncation], ["microsecond", ToIntegerWithTruncation], ["nanosecond", ToIntegerWithTruncation], ["years", ToIntegerIfIntegral], ["months", ToIntegerIfIntegral], ["weeks", ToIntegerIfIntegral], ["days", ToIntegerIfIntegral], ["hours", ToIntegerIfIntegral], ["minutes", ToIntegerIfIntegral], ["seconds", ToIntegerIfIntegral], ["milliseconds", ToIntegerIfIntegral], ["microseconds", ToIntegerIfIntegral], ["nanoseconds", ToIntegerIfIntegral], ["era", ToString], ["eraYear", ToIntegerOrInfinity], ["offset", ToString]]);
var ke = /* @__PURE__ */ new Map([["hour", 0], ["minute", 0], ["second", 0], ["millisecond", 0], ["microsecond", 0], ["nanosecond", 0]]);
var Ue = [["years", "year", "date"], ["months", "month", "date"], ["weeks", "week", "date"], ["days", "day", "date"], ["hours", "hour", "time"], ["minutes", "minute", "time"], ["seconds", "second", "time"], ["milliseconds", "millisecond", "time"], ["microseconds", "microsecond", "time"], ["nanoseconds", "nanosecond", "time"]];
var Ae = new Map(Ue.map((e2) => [e2[0], e2[1]]));
var Le = new Map(Ue.map(([e2, t2]) => [t2, e2]));
var xe = Ue.map(([, e2]) => e2);
var We = Array.from(Ae.keys()).sort();
var qe = /* @__PURE__ */ new Map();
function getIntlDateTimeFormatEnUsForTimeZone(e2) {
  let t2 = qe.get(e2);
  return void 0 === t2 && (t2 = new re("en-us", { timeZone: he(e2), hour12: false, era: "short", year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" }), qe.set(e2, t2)), t2;
}
function ToObject(e2) {
  if (null == e2)
    throw new TypeError(`Expected object not ${e2}`);
  return Object(e2);
}
function CopyDataProperties(e2, t2, r2, o2) {
  if (null == t2)
    return;
  const n2 = ye(t2);
  for (const a2 of n2)
    if (!r2.some((e3) => Object.is(e3, a2)) && Object.prototype.propertyIsEnumerable.call(t2, a2)) {
      const r3 = t2[a2];
      if (o2 && o2.some((e3) => Object.is(e3, r3)))
        continue;
      e2[a2] = r3;
    }
}
function IsTemporalInstant(e2) {
  return HasSlot(e2, n) && !HasSlot(e2, g, p);
}
function IsTemporalTimeZone(e2) {
  return HasSlot(e2, a);
}
function IsTemporalCalendar(e2) {
  return HasSlot(e2, F);
}
function IsTemporalDuration(e2) {
  return HasSlot(e2, w, D, v, C, O, b, E, M, R);
}
function IsTemporalDate(e2) {
  return HasSlot(e2, f);
}
function IsTemporalTime(e2) {
  return HasSlot(e2, d, m, c, h, u, T) && !HasSlot(e2, i, s, l);
}
function IsTemporalDateTime(e2) {
  return HasSlot(e2, i, s, l, d, m, c, h, u, T);
}
function IsTemporalYearMonth(e2) {
  return HasSlot(e2, y);
}
function IsTemporalMonthDay(e2) {
  return HasSlot(e2, I);
}
function IsTemporalZonedDateTime(e2) {
  return HasSlot(e2, n, g, p);
}
function RejectTemporalLikeObject(e2) {
  if (HasSlot(e2, p) || HasSlot(e2, g))
    throw new TypeError("with() does not support a calendar or timeZone property");
  if (IsTemporalTime(e2))
    throw new TypeError("with() does not accept Temporal.PlainTime, use withPlainTime() instead");
  if (void 0 !== e2.calendar)
    throw new TypeError("with() does not support a calendar property");
  if (void 0 !== e2.timeZone)
    throw new TypeError("with() does not support a timeZone property");
}
function ParseTemporalTimeZone(e2) {
  const { ianaName: t2, offset: r2, z: o2 } = function ParseTemporalTimeZoneString(e3) {
    if (new RegExp(`^${$.source}$`, "i").test(e3))
      return { ianaName: e3 };
    try {
      const t3 = ParseISODateTime(e3);
      if (t3.z || t3.offset || t3.ianaName)
        return t3;
    } catch (e4) {
    }
    throw new RangeError(`Invalid time zone: ${e3}`);
  }(e2);
  if (t2)
    return GetCanonicalTimeZoneIdentifier(t2);
  if (o2)
    return "UTC";
  return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(r2));
}
function MaybeFormatCalendarAnnotation(e2, t2) {
  return "never" === t2 ? "" : FormatCalendarAnnotation(ToTemporalCalendarIdentifier(e2), t2);
}
function FormatCalendarAnnotation(e2, t2) {
  if ("never" === t2)
    return "";
  if ("auto" === t2 && "iso8601" === e2)
    return "";
  return `[${"critical" === t2 ? "!" : ""}u-ca=${e2}]`;
}
function ParseISODateTime(e2) {
  const t2 = V.exec(e2);
  if (!t2)
    throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  let r2 = t2[1];
  if ("\u2212" === r2[0] && (r2 = `-${r2.slice(1)}`), "-000000" === r2)
    throw new RangeError(`invalid ISO 8601 string: ${e2}`);
  const o2 = ToIntegerOrInfinity(r2), n2 = ToIntegerOrInfinity(t2[2] || t2[4]), a2 = ToIntegerOrInfinity(t2[3] || t2[5]), i2 = ToIntegerOrInfinity(t2[6]), s2 = void 0 !== t2[6], l2 = ToIntegerOrInfinity(t2[7] || t2[10]);
  let d2 = ToIntegerOrInfinity(t2[8] || t2[11]);
  60 === d2 && (d2 = 59);
  const m2 = (t2[9] || t2[12]) + "000000000", c2 = ToIntegerOrInfinity(m2.slice(0, 3)), h2 = ToIntegerOrInfinity(m2.slice(3, 6)), u2 = ToIntegerOrInfinity(m2.slice(6, 9));
  let T2, p2 = false;
  if (t2[13])
    T2 = void 0, p2 = true;
  else if (t2[14] && t2[15]) {
    const e3 = "-" === t2[14] || "\u2212" === t2[14] ? "-" : "+", r3 = t2[15] || "00", o3 = t2[16] || "00", n3 = t2[17] || "00";
    let a3 = t2[18] || "0";
    if (T2 = `${e3}${r3}:${o3}`, +a3) {
      for (; a3.endsWith("0"); )
        a3 = a3.slice(0, -1);
      T2 += `:${n3}.${a3}`;
    } else
      +n3 && (T2 += `:${n3}`);
    "-00:00" === T2 && (T2 = "+00:00");
  }
  const f2 = t2[19], y2 = t2[20];
  let I2;
  for (const [, e3, t3, r3] of y2.matchAll(H))
    if ("u-ca" === t3)
      void 0 === I2 && (I2 = r3);
    else if ("!" === e3)
      throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
  return RejectDateTime(o2, n2, a2, i2, l2, d2, c2, h2, u2), { year: o2, month: n2, day: a2, hasTime: s2, hour: i2, minute: l2, second: d2, millisecond: c2, microsecond: h2, nanosecond: u2, ianaName: f2, offset: T2, z: p2, calendar: I2 };
}
function ParseTemporalYearMonthString(e2) {
  const t2 = _.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    let a3 = t2[1];
    if ("\u2212" === a3[0] && (a3 = `-${a3.slice(1)}`), "-000000" === a3)
      throw new RangeError(`invalid ISO 8601 string: ${e2}`);
    r2 = ToIntegerOrInfinity(a3), o2 = ToIntegerOrInfinity(t2[2]);
    const i2 = t2[3];
    for (const [, e3, t3, r3] of i2.matchAll(H))
      if ("u-ca" === t3)
        void 0 === n2 && (n2 = r3);
      else if ("!" === e3)
        throw new RangeError(`Unrecognized annotation: !${t3}=${r3}`);
    if (void 0 !== n2 && "iso8601" !== n2)
      throw new RangeError("YYYY-MM format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ year: r2, month: o2, calendar: n2, day: a2, z: t3 } = ParseISODateTime(e2), t3)
      throw new RangeError("Z designator not supported for PlainYearMonth");
  }
  return { year: r2, month: o2, calendar: n2, referenceISODay: a2 };
}
function ParseTemporalMonthDayString(e2) {
  const t2 = J.exec(e2);
  let r2, o2, n2, a2;
  if (t2) {
    r2 = ToIntegerOrInfinity(t2[1]), o2 = ToIntegerOrInfinity(t2[2]);
    const e3 = t2[3];
    for (const [, t3, r3, o3] of e3.matchAll(H))
      if ("u-ca" === r3)
        void 0 === n2 && (n2 = o3);
      else if ("!" === t3)
        throw new RangeError(`Unrecognized annotation: !${r3}=${o3}`);
    if (void 0 !== n2 && "iso8601" !== n2)
      throw new RangeError("MM-DD format is only valid with iso8601 calendar");
  } else {
    let t3;
    if ({ month: r2, day: o2, calendar: n2, year: a2, z: t3 } = ParseISODateTime(e2), t3)
      throw new RangeError("Z designator not supported for PlainMonthDay");
  }
  return { month: r2, day: o2, calendar: n2, referenceISOYear: a2 };
}
function ParseTemporalInstant(e2) {
  let { year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2, offset: m2, z: c2 } = function ParseTemporalInstantString(e3) {
    const t3 = ParseISODateTime(e3);
    if (!t3.z && !t3.offset)
      throw new RangeError("Temporal.Instant requires a time zone offset");
    return t3;
  }(e2);
  if (!c2 && !m2)
    throw new RangeError("Temporal.Instant requires a time zone offset");
  const h2 = c2 ? 0 : ParseTimeZoneOffsetString(m2);
  ({ year: t2, month: r2, day: o2, hour: n2, minute: a2, second: i2, millisecond: s2, microsecond: l2, nanosecond: d2 } = BalanceISODateTime(t2, r2, o2, n2, a2, i2, s2, l2, d2 - h2));
  const u2 = GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2);
  if (null === u2)
    throw new RangeError("DateTime outside of supported range");
  return u2;
}
function RegulateISODate(e2, t2, r2, o2) {
  let n2 = e2, a2 = t2, i2 = r2;
  switch (o2) {
    case "reject":
      RejectISODate(n2, a2, i2);
      break;
    case "constrain":
      ({ year: n2, month: a2, day: i2 } = ConstrainISODate(n2, a2, i2));
  }
  return { year: n2, month: a2, day: i2 };
}
function RegulateTime(e2, t2, r2, o2, n2, a2, i2) {
  let s2 = e2, l2 = t2, d2 = r2, m2 = o2, c2 = n2, h2 = a2;
  switch (i2) {
    case "reject":
      RejectTime(s2, l2, d2, m2, c2, h2);
      break;
    case "constrain":
      ({ hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 } = function ConstrainTime(e3, t3, r3, o3, n3, a3) {
        const i3 = ConstrainToRange(e3, 0, 23), s3 = ConstrainToRange(t3, 0, 59), l3 = ConstrainToRange(r3, 0, 59), d3 = ConstrainToRange(o3, 0, 999), m3 = ConstrainToRange(n3, 0, 999), c3 = ConstrainToRange(a3, 0, 999);
        return { hour: i3, minute: s3, second: l3, millisecond: d3, microsecond: m3, nanosecond: c3 };
      }(s2, l2, d2, m2, c2, h2));
  }
  return { hour: s2, minute: l2, second: d2, millisecond: m2, microsecond: c2, nanosecond: h2 };
}
function ToTemporalDurationRecord(e2) {
  if (!IsObject(e2))
    return function ParseTemporalDurationString(e3) {
      var _a, _b;
      const t3 = Q.exec(e3);
      if (!t3)
        throw new RangeError(`invalid duration: ${e3}`);
      if (t3.slice(2).every((e4) => void 0 === e4))
        throw new RangeError(`invalid duration: ${e3}`);
      const r3 = "-" === t3[1] || "\u2212" === t3[1] ? -1 : 1, o3 = void 0 === t3[2] ? 0 : ToIntegerWithTruncation(t3[2]) * r3, n3 = void 0 === t3[3] ? 0 : ToIntegerWithTruncation(t3[3]) * r3, a3 = void 0 === t3[4] ? 0 : ToIntegerWithTruncation(t3[4]) * r3, i3 = void 0 === t3[5] ? 0 : ToIntegerWithTruncation(t3[5]) * r3, s3 = void 0 === t3[6] ? 0 : ToIntegerWithTruncation(t3[6]) * r3, l3 = t3[7], d3 = t3[8], m3 = t3[9], c3 = t3[10], h3 = t3[11];
      let u2 = 0, T2 = 0, p2 = 0;
      if (void 0 !== l3) {
        if ((_b = (_a = d3 != null ? d3 : m3) != null ? _a : c3) != null ? _b : h3)
          throw new RangeError("only the smallest unit can be fractional");
        p2 = 3600 * ToIntegerOrInfinity((l3 + "000000000").slice(0, 9)) * r3;
      } else if (u2 = void 0 === d3 ? 0 : ToIntegerWithTruncation(d3) * r3, void 0 !== m3) {
        if (c3 != null ? c3 : h3)
          throw new RangeError("only the smallest unit can be fractional");
        p2 = 60 * ToIntegerOrInfinity((m3 + "000000000").slice(0, 9)) * r3;
      } else
        T2 = void 0 === c3 ? 0 : ToIntegerWithTruncation(c3) * r3, void 0 !== h3 && (p2 = ToIntegerOrInfinity((h3 + "000000000").slice(0, 9)) * r3);
      const f2 = p2 % 1e3, y2 = le(p2 / 1e3) % 1e3, I2 = le(p2 / 1e6) % 1e3;
      return T2 += le(p2 / 1e9) % 60, u2 += le(p2 / 6e10), RejectDuration(o3, n3, a3, i3, s3, u2, T2, I2, y2, f2), { years: o3, months: n3, weeks: a3, days: i3, hours: s3, minutes: u2, seconds: T2, milliseconds: I2, microseconds: y2, nanoseconds: f2 };
    }(ToString(e2));
  if (IsTemporalDuration(e2))
    return { years: GetSlot(e2, w), months: GetSlot(e2, D), weeks: GetSlot(e2, G), days: GetSlot(e2, v), hours: GetSlot(e2, C), minutes: GetSlot(e2, O), seconds: GetSlot(e2, b), milliseconds: GetSlot(e2, E), microseconds: GetSlot(e2, M), nanoseconds: GetSlot(e2, R) };
  const t2 = { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  let r2 = function ToTemporalPartialDurationRecord(e3) {
    if (!IsObject(e3))
      throw new TypeError("invalid duration-like");
    const t3 = { years: void 0, months: void 0, weeks: void 0, days: void 0, hours: void 0, minutes: void 0, seconds: void 0, milliseconds: void 0, microseconds: void 0, nanoseconds: void 0 };
    let r3 = false;
    for (const o3 of We) {
      const n3 = e3[o3];
      void 0 !== n3 && (r3 = true, t3[o3] = ToIntegerIfIntegral(n3));
    }
    if (!r3)
      throw new TypeError("invalid duration-like");
    return t3;
  }(e2);
  for (const e3 of We) {
    const o3 = r2[e3];
    void 0 !== o3 && (t2[e3] = o3);
  }
  let { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 } = t2;
  return RejectDuration(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { years: o2, months: n2, weeks: a2, days: i2, hours: s2, minutes: l2, seconds: d2, milliseconds: m2, microseconds: c2, nanoseconds: h2 };
}
function ToTemporalOverflow(e2) {
  return void 0 === e2 ? "constrain" : GetOption(e2, "overflow", ["constrain", "reject"], "constrain");
}
function ToTemporalDisambiguation(e2) {
  return void 0 === e2 ? "compatible" : GetOption(e2, "disambiguation", ["compatible", "earlier", "later", "reject"], "compatible");
}
function ToTemporalRoundingMode(e2, t2) {
  return GetOption(e2, "roundingMode", ["ceil", "floor", "expand", "trunc", "halfCeil", "halfFloor", "halfExpand", "halfTrunc", "halfEven"], t2);
}
function ToTemporalOffset(e2, t2) {
  return void 0 === e2 ? t2 : GetOption(e2, "offset", ["prefer", "use", "ignore", "reject"], t2);
}
function ToCalendarNameOption(e2) {
  return GetOption(e2, "calendarName", ["auto", "always", "never", "critical"], "auto");
}
function ToTemporalRoundingIncrement(e2) {
  let t2 = e2.roundingIncrement;
  if (void 0 === t2)
    return 1;
  if (t2 = ToNumber(t2), !me(t2))
    throw new RangeError("roundingIncrement must be finite");
  const r2 = le(t2);
  if (r2 < 1 || r2 > 1e9)
    throw new RangeError(`roundingIncrement must be at least 1 and at most 1e9, not ${t2}`);
  return r2;
}
function ValidateTemporalRoundingIncrement(e2, t2, r2) {
  const o2 = r2 ? t2 : t2 - 1;
  if (e2 > o2)
    throw new RangeError(`roundingIncrement must be at least 1 and less than ${o2}, not ${e2}`);
  if (t2 % e2 != 0)
    throw new RangeError(`Rounding increment must divide evenly into ${t2}`);
}
function ToFractionalSecondDigits(e2) {
  const t2 = e2.fractionalSecondDigits;
  if (void 0 === t2)
    return "auto";
  if ("number" != typeof t2) {
    if ("auto" !== ToString(t2))
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
    return "auto";
  }
  const r2 = ie(t2);
  if (!me(r2) || r2 < 0 || r2 > 9)
    throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  return r2;
}
function ToSecondsStringPrecisionRecord(e2, t2) {
  switch (e2) {
    case "minute":
      return { precision: "minute", unit: "minute", increment: 1 };
    case "second":
      return { precision: 0, unit: "second", increment: 1 };
    case "millisecond":
      return { precision: 3, unit: "millisecond", increment: 1 };
    case "microsecond":
      return { precision: 6, unit: "microsecond", increment: 1 };
    case "nanosecond":
      return { precision: 9, unit: "nanosecond", increment: 1 };
  }
  switch (t2) {
    case "auto":
      return { precision: t2, unit: "nanosecond", increment: 1 };
    case 0:
      return { precision: t2, unit: "second", increment: 1 };
    case 1:
    case 2:
    case 3:
      return { precision: t2, unit: "millisecond", increment: 10 ** (3 - t2) };
    case 4:
    case 5:
    case 6:
      return { precision: t2, unit: "microsecond", increment: 10 ** (6 - t2) };
    case 7:
    case 8:
    case 9:
      return { precision: t2, unit: "nanosecond", increment: 10 ** (9 - t2) };
    default:
      throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${t2}`);
  }
}
var He = Symbol("~required~");
function GetTemporalUnit(e2, t2, r2, o2, n2 = []) {
  const a2 = [];
  for (const [, e3, t3] of Ue)
    "datetime" !== r2 && r2 !== t3 || a2.push(e3);
  a2.push(...n2);
  let i2 = o2;
  i2 === He ? i2 = void 0 : void 0 !== i2 && a2.push(i2);
  const s2 = [...a2];
  for (const e3 of a2) {
    const t3 = Le.get(e3);
    void 0 !== t3 && s2.push(t3);
  }
  let l2 = GetOption(e2, t2, s2, i2);
  if (void 0 === l2 && o2 === He)
    throw new RangeError(`${t2} is required`);
  return Ae.has(l2) ? Ae.get(l2) : l2;
}
function ToRelativeTemporalObject(e2) {
  const t2 = e2.relativeTo;
  if (void 0 === t2)
    return t2;
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2 = "option", p2 = false;
  if (IsObject(t2)) {
    if (IsTemporalZonedDateTime(t2) || IsTemporalDate(t2))
      return t2;
    if (IsTemporalDateTime(t2))
      return TemporalDateTimeToDate(t2);
    c2 = GetTemporalCalendarSlotValueWithISODefault(t2);
    const e3 = CalendarFields(c2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    e3.push("timeZone", "offset");
    const p3 = PrepareTemporalFields(t2, e3, []), f2 = Te(null);
    f2.overflow = "constrain", { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(c2, p3, f2), u2 = p3.offset, void 0 === u2 && (T2 = "wall"), h2 = p3.timeZone, void 0 !== h2 && (h2 = ToTemporalTimeZoneSlotValue(h2));
  } else {
    let e3, f2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, calendar: c2, ianaName: e3, offset: u2, z: f2 } = ParseISODateTime(ToString(t2)), e3)
      h2 = ToTemporalTimeZoneSlotValue(e3), f2 ? T2 = "exact" : u2 || (T2 = "wall"), p2 = true;
    else if (f2)
      throw new RangeError("Z designator not supported for PlainDate relativeTo; either remove the Z or add a bracketed time zone");
    if (c2 || (c2 = "iso8601"), !IsBuiltinCalendar(c2))
      throw new RangeError(`invalid calendar identifier ${c2}`);
    c2 = ASCIILowercase(c2);
  }
  if (void 0 === h2)
    return CreateTemporalDate(r2, o2, n2, c2);
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, T2, "option" === T2 ? ParseTimeZoneOffsetString(u2) : 0, h2, "compatible", "reject", p2), h2, c2);
}
function DefaultTemporalLargestUnit(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const [m2, c2] of [["years", e2], ["months", t2], ["weeks", r2], ["days", o2], ["hours", n2], ["minutes", a2], ["seconds", i2], ["milliseconds", s2], ["microseconds", l2], ["nanoseconds", d2]])
    if (0 !== c2)
      return Ae.get(m2);
  return "nanosecond";
}
function LargerOfTwoTemporalUnits(e2, t2) {
  return xe.indexOf(e2) > xe.indexOf(t2) ? t2 : e2;
}
function PrepareTemporalFields(e2, t2, r2, { emptySourceErrorMessage: o2 } = { emptySourceErrorMessage: "no supported properties found" }) {
  const n2 = Te(null);
  let a2 = false;
  t2.sort();
  for (const o3 of t2) {
    let t3 = e2[o3];
    if (void 0 !== t3)
      a2 = true, $e.has(o3) && (t3 = $e.get(o3)(t3)), n2[o3] = t3;
    else if ("partial" !== r2) {
      if (ee.call(r2, o3))
        throw new TypeError(`required property '${o3}' missing or undefined`);
      t3 = ke.get(o3), n2[o3] = t3;
    }
  }
  if ("partial" === r2 && !a2)
    throw new TypeError(o2);
  return n2;
}
function ToTemporalTimeRecord(e2, t2 = "complete") {
  const r2 = ["hour", "microsecond", "millisecond", "minute", "nanosecond", "second"], o2 = PrepareTemporalFields(e2, r2, "partial", { emptySourceErrorMessage: "invalid time-like" }), n2 = {};
  for (const e3 of r2) {
    const r3 = pe(o2, e3);
    void 0 !== r3 ? n2[e3] = r3.value : "complete" === t2 && (n2[e3] = 0);
  }
  return n2;
}
function ToTemporalDate(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalDate(r2))
      return r2;
    if (IsTemporalZonedDateTime(r2) && (ToTemporalOverflow(t2), r2 = GetPlainDateTimeFor(GetSlot(r2, g), GetSlot(r2, S), GetSlot(r2, p))), IsTemporalDateTime(r2))
      return ToTemporalOverflow(t2), CreateTemporalDate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, p));
    const e3 = GetTemporalCalendarSlotValueWithISODefault(r2);
    return CalendarDateFromFields(e3, PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: o2, month: n2, day: a2, calendar: d2, z: m2 } = function ParseTemporalDateString(e3) {
    return ParseISODateTime(e3);
  }(ToString(r2));
  if (m2)
    throw new RangeError("Z designator not supported for PlainDate");
  if (d2 || (d2 = "iso8601"), !IsBuiltinCalendar(d2))
    throw new RangeError(`invalid calendar identifier ${d2}`);
  return d2 = ASCIILowercase(d2), CreateTemporalDate(o2, n2, a2, d2);
}
function InterpretTemporalDateTimeFields(e2, t2, r2) {
  let { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = ToTemporalTimeRecord(t2);
  const h2 = ToTemporalOverflow(r2), u2 = CalendarDateFromFields(e2, t2, r2), T2 = GetSlot(u2, i), p2 = GetSlot(u2, s), f2 = GetSlot(u2, l);
  return { hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 } = RegulateTime(o2, n2, a2, d2, m2, c2, h2), { year: T2, month: p2, day: f2, hour: o2, minute: n2, second: a2, millisecond: d2, microsecond: m2, nanosecond: c2 };
}
function ToTemporalDateTime(e2, t2) {
  let r2, o2, n2, a2, d2, m2, c2, h2, u2, T2;
  if (IsObject(e2)) {
    if (IsTemporalDateTime(e2))
      return e2;
    if (IsTemporalZonedDateTime(e2))
      return ToTemporalOverflow(t2), GetPlainDateTimeFor(GetSlot(e2, g), GetSlot(e2, S), GetSlot(e2, p));
    if (IsTemporalDate(e2))
      return ToTemporalOverflow(t2), CreateTemporalDateTime(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), 0, 0, 0, 0, 0, 0, GetSlot(e2, p));
    T2 = GetTemporalCalendarSlotValueWithISODefault(e2);
    const f2 = PrepareTemporalFields(e2, CalendarFields(T2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]), []);
    ({ year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2 } = InterpretTemporalDateTimeFields(T2, f2, t2));
  } else {
    let i2;
    if (ToTemporalOverflow(t2), { year: r2, month: o2, day: n2, hour: a2, minute: d2, second: m2, millisecond: c2, microsecond: h2, nanosecond: u2, calendar: T2, z: i2 } = function ParseTemporalDateTimeString(e3) {
      return ParseISODateTime(e3);
    }(ToString(e2)), i2)
      throw new RangeError("Z designator not supported for PlainDateTime");
    if (RejectDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2), T2 || (T2 = "iso8601"), !IsBuiltinCalendar(T2))
      throw new RangeError(`invalid calendar identifier ${T2}`);
    T2 = ASCIILowercase(T2);
  }
  return CreateTemporalDateTime(r2, o2, n2, a2, d2, m2, c2, h2, u2, T2);
}
function ToTemporalDuration(e2) {
  if (IsTemporalDuration(e2))
    return e2;
  let { years: t2, months: r2, weeks: o2, days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = ToTemporalDurationRecord(e2);
  return new (GetIntrinsic("%Temporal.Duration%"))(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2);
}
function ToTemporalInstant(e2) {
  if (IsTemporalInstant(e2))
    return e2;
  if (IsTemporalZonedDateTime(e2)) {
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, n));
  }
  const t2 = ParseTemporalInstant(ToString(e2));
  return new (GetIntrinsic("%Temporal.Instant%"))(t2);
}
function ToTemporalMonthDay(e2, t2) {
  let r2 = e2;
  if (IsObject(r2)) {
    if (IsTemporalMonthDay(r2))
      return r2;
    let e3, o3;
    if (HasSlot(r2, p))
      e3 = GetSlot(r2, p), o3 = false;
    else {
      let t3 = r2.calendar;
      o3 = void 0 === t3, void 0 === t3 && (t3 = "iso8601"), e3 = ToTemporalCalendarSlotValue(t3);
    }
    const n3 = PrepareTemporalFields(r2, CalendarFields(e3, ["day", "month", "monthCode", "year"]), []);
    return o3 && void 0 !== n3.month && void 0 === n3.monthCode && void 0 === n3.year && (n3.year = 1972), CalendarMonthDayFromFields(e3, n3, t2);
  }
  ToTemporalOverflow(t2);
  let { month: o2, day: n2, referenceISOYear: a2, calendar: i2 } = ParseTemporalMonthDayString(ToString(r2));
  if (void 0 === i2 && (i2 = "iso8601"), !IsBuiltinCalendar(i2))
    throw new RangeError(`invalid calendar identifier ${i2}`);
  if (i2 = ASCIILowercase(i2), void 0 === a2)
    return RejectISODate(1972, o2, n2), CreateTemporalMonthDay(o2, n2, i2);
  return CalendarMonthDayFromFields(i2, CreateTemporalMonthDay(o2, n2, i2, a2));
}
function ToTemporalTime(e2, t2 = "constrain") {
  let r2, o2, n2, a2, i2, s2, l2 = e2;
  if (IsObject(l2)) {
    if (IsTemporalTime(l2))
      return l2;
    if (IsTemporalZonedDateTime(l2) && (l2 = GetPlainDateTimeFor(GetSlot(l2, g), GetSlot(l2, S), GetSlot(l2, p))), IsTemporalDateTime(l2)) {
      return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(l2, d), GetSlot(l2, m), GetSlot(l2, c), GetSlot(l2, h), GetSlot(l2, u), GetSlot(l2, T));
    }
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = ToTemporalTimeRecord(l2)), { hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = RegulateTime(r2, o2, n2, a2, i2, s2, t2);
  } else
    ({ hour: r2, minute: o2, second: n2, millisecond: a2, microsecond: i2, nanosecond: s2 } = function ParseTemporalTimeString(e3) {
      const t3 = z.exec(e3);
      let r3, o3, n3, a3, i3, s3, l3;
      if (t3) {
        r3 = ToIntegerOrInfinity(t3[1]), o3 = ToIntegerOrInfinity(t3[2] || t3[5]), n3 = ToIntegerOrInfinity(t3[3] || t3[6]), 60 === n3 && (n3 = 59);
        const e4 = (t3[4] || t3[7]) + "000000000";
        a3 = ToIntegerOrInfinity(e4.slice(0, 3)), i3 = ToIntegerOrInfinity(e4.slice(3, 6)), s3 = ToIntegerOrInfinity(e4.slice(6, 9)), l3 = t3[14];
        for (const [, e5, t4, r4] of l3.matchAll(H))
          if ("u-ca" !== t4 && "!" === e5)
            throw new RangeError(`Unrecognized annotation: !${t4}=${r4}`);
        if (t3[8])
          throw new RangeError("Z designator not supported for PlainTime");
      } else {
        let t4, l4;
        if ({ hasTime: l4, hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3, z: t4 } = ParseISODateTime(e3), !l4)
          throw new RangeError(`time is missing in string: ${e3}`);
        if (t4)
          throw new RangeError("Z designator not supported for PlainTime");
      }
      if (/[tT ][0-9][0-9]/.test(e3))
        return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3 };
      try {
        const { month: t4, day: r4 } = ParseTemporalMonthDayString(e3);
        RejectISODate(1972, t4, r4);
      } catch (e4) {
        try {
          const { year: t4, month: r4 } = ParseTemporalYearMonthString(e3);
          RejectISODate(t4, r4, 1);
        } catch (e5) {
          return { hour: r3, minute: o3, second: n3, millisecond: a3, microsecond: i3, nanosecond: s3 };
        }
      }
      throw new RangeError(`invalid ISO 8601 time-only string ${e3}; may need a T prefix`);
    }(ToString(l2))), RejectTime(r2, o2, n2, a2, i2, s2);
  return new (GetIntrinsic("%Temporal.PlainTime%"))(r2, o2, n2, a2, i2, s2);
}
function ToTemporalYearMonth(e2, t2) {
  if (IsObject(e2)) {
    if (IsTemporalYearMonth(e2))
      return e2;
    const r3 = GetTemporalCalendarSlotValueWithISODefault(e2);
    return CalendarYearMonthFromFields(r3, PrepareTemporalFields(e2, CalendarFields(r3, ["month", "monthCode", "year"]), []), t2);
  }
  ToTemporalOverflow(t2);
  let { year: r2, month: o2, referenceISODay: n2, calendar: a2 } = ParseTemporalYearMonthString(ToString(e2));
  if (void 0 === a2 && (a2 = "iso8601"), !IsBuiltinCalendar(a2))
    throw new RangeError(`invalid calendar identifier ${a2}`);
  if (a2 = ASCIILowercase(a2), void 0 === n2)
    return RejectISODate(r2, o2, 1), CreateTemporalYearMonth(r2, o2, a2);
  return CalendarYearMonthFromFields(a2, CreateTemporalYearMonth(r2, o2, a2, n2));
}
function InterpretISODateTimeOffset(t2, r2, o2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2) {
  const I2 = new (GetIntrinsic("%Temporal.PlainDateTime%"))(t2, r2, o2, i2, s2, l2, d2, m2, c2);
  if ("wall" === h2 || "ignore" === f2) {
    return GetSlot(GetInstantFor(T2, I2, p2), n);
  }
  if ("exact" === h2 || "use" === f2) {
    const n2 = GetUTCEpochNanoseconds(t2, r2, o2, i2, s2, l2, d2, m2, c2);
    if (null === n2)
      throw new RangeError("ZonedDateTime outside of supported range");
    return import_jsbi.default.subtract(n2, import_jsbi.default.BigInt(u2));
  }
  const S2 = GetPossibleInstantsFor(T2, I2);
  for (const t3 of S2) {
    const r3 = GetOffsetNanosecondsFor(T2, t3), o3 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(r3), be, "halfExpand"));
    if (r3 === u2 || y2 && o3 === u2)
      return GetSlot(t3, n);
  }
  if ("reject" === f2) {
    const e2 = FormatTimeZoneOffsetString(u2), t3 = IsTemporalTimeZone(T2) ? GetSlot(T2, a) : "time zone";
    throw new RangeError(`Offset ${e2} is invalid for ${I2.toString()} in ${t3}`);
  }
  return GetSlot(DisambiguatePossibleInstants(S2, T2, I2, p2), n);
}
function ToTemporalZonedDateTime(e2, t2) {
  let r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2 = false, y2 = "option";
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2))
      return e2;
    u2 = GetTemporalCalendarSlotValueWithISODefault(e2);
    const f3 = CalendarFields(u2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    f3.push("timeZone", "offset");
    const I3 = PrepareTemporalFields(e2, f3, ["timeZone"]);
    c2 = ToTemporalTimeZoneSlotValue(I3.timeZone), h2 = I3.offset, void 0 === h2 && (y2 = "wall"), T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), { year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = InterpretTemporalDateTimeFields(u2, I3, t2);
  } else {
    let I3, S2;
    if ({ year: r2, month: o2, day: n2, hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2, ianaName: I3, offset: h2, z: S2, calendar: u2 } = function ParseTemporalZonedDateTimeString(e3) {
      const t3 = ParseISODateTime(e3);
      if (!t3.ianaName)
        throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");
      return t3;
    }(ToString(e2)), c2 = ToTemporalTimeZoneSlotValue(I3), S2 ? y2 = "exact" : h2 || (y2 = "wall"), u2 || (u2 = "iso8601"), !IsBuiltinCalendar(u2))
      throw new RangeError(`invalid calendar identifier ${u2}`);
    u2 = ASCIILowercase(u2), f2 = true, T2 = ToTemporalDisambiguation(t2), p2 = ToTemporalOffset(t2, "reject"), ToTemporalOverflow(t2);
  }
  let I2 = 0;
  "option" === y2 && (I2 = ParseTimeZoneOffsetString(h2));
  return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(r2, o2, n2, a2, i2, s2, l2, d2, m2, y2, I2, c2, T2, p2, f2), c2, u2);
}
function CreateTemporalDateSlots(e2, t2, r2, o2, n2) {
  RejectISODate(t2, r2, o2), RejectDateRange(t2, r2, o2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, o2), SetSlot(e2, p, n2), SetSlot(e2, f, true);
}
function CreateTemporalDate(e2, t2, r2, o2 = "iso8601") {
  const n2 = GetIntrinsic("%Temporal.PlainDate%"), a2 = Te(n2.prototype);
  return CreateTemporalDateSlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalDateTimeSlots(e2, t2, r2, o2, n2, a2, f2, y2, I2, S2, g2) {
  RejectDateTime(t2, r2, o2, n2, a2, f2, y2, I2, S2), RejectDateTimeRange(t2, r2, o2, n2, a2, f2, y2, I2, S2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, o2), SetSlot(e2, d, n2), SetSlot(e2, m, a2), SetSlot(e2, c, f2), SetSlot(e2, h, y2), SetSlot(e2, u, I2), SetSlot(e2, T, S2), SetSlot(e2, p, g2);
}
function CreateTemporalDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2 = "iso8601") {
  const m2 = GetIntrinsic("%Temporal.PlainDateTime%"), c2 = Te(m2.prototype);
  return CreateTemporalDateTimeSlots(c2, e2, t2, r2, o2, n2, a2, i2, s2, l2, d2), c2;
}
function CreateTemporalMonthDaySlots(e2, t2, r2, o2, n2) {
  RejectISODate(n2, t2, r2), RejectDateRange(n2, t2, r2), N(e2), SetSlot(e2, s, t2), SetSlot(e2, l, r2), SetSlot(e2, i, n2), SetSlot(e2, p, o2), SetSlot(e2, I, true);
}
function CreateTemporalMonthDay(e2, t2, r2 = "iso8601", o2 = 1972) {
  const n2 = GetIntrinsic("%Temporal.PlainMonthDay%"), a2 = Te(n2.prototype);
  return CreateTemporalMonthDaySlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalYearMonthSlots(e2, t2, r2, o2, n2) {
  RejectISODate(t2, r2, n2), function RejectYearMonthRange(e3, t3) {
    RejectToRange(e3, Fe, Ye), e3 === Fe ? RejectToRange(t3, 4, 12) : e3 === Ye && RejectToRange(t3, 1, 9);
  }(t2, r2), N(e2), SetSlot(e2, i, t2), SetSlot(e2, s, r2), SetSlot(e2, l, n2), SetSlot(e2, p, o2), SetSlot(e2, y, true);
}
function CreateTemporalYearMonth(e2, t2, r2 = "iso8601", o2 = 1) {
  const n2 = GetIntrinsic("%Temporal.PlainYearMonth%"), a2 = Te(n2.prototype);
  return CreateTemporalYearMonthSlots(a2, e2, t2, r2, o2), a2;
}
function CreateTemporalZonedDateTimeSlots(e2, t2, r2, o2) {
  ValidateEpochNanoseconds(t2), N(e2), SetSlot(e2, n, t2), SetSlot(e2, g, r2), SetSlot(e2, p, o2);
  const a2 = new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(e2, n));
  SetSlot(e2, S, a2);
}
function CreateTemporalZonedDateTime(e2, t2, r2 = "iso8601") {
  const o2 = GetIntrinsic("%Temporal.ZonedDateTime%"), n2 = Te(o2.prototype);
  return CreateTemporalZonedDateTimeSlots(n2, e2, t2, r2), n2;
}
function CalendarFields(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.fields%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "fields"), e2, [t2]), o2 = [];
  for (const e3 of r2) {
    if ("string" != typeof e3)
      throw new TypeError("bad return from calendar.fields()");
    te.call(o2, e3);
  }
  return o2;
}
function CalendarMergeFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.mergeFields%"), o3, [t2, r2]);
  }
  const o2 = Call(GetMethod(e2, "mergeFields"), e2, [t2, r2]);
  if (!IsObject(o2))
    throw new TypeError("bad return from calendar.mergeFields()");
  return o2;
}
function CalendarDateAdd(e2, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e2) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateAdd%"), n3, [t2, r2, o2]);
  }
  void 0 === a2 && (a2 = GetMethod(e2, "dateAdd"));
  const i2 = fe(a2, e2, [t2, r2, o2]);
  if (!IsTemporalDate(i2))
    throw new TypeError("invalid result");
  return i2;
}
function CalendarDateUntil(e2, t2, r2, o2, n2) {
  let a2 = n2;
  if ("string" == typeof e2) {
    const n3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateUntil%"), n3, [t2, r2, o2]);
  }
  void 0 === a2 && (a2 = GetMethod(e2, "dateUntil"));
  const i2 = fe(a2, e2, [t2, r2, o2]);
  if (!IsTemporalDuration(i2))
    throw new TypeError("invalid result");
  return i2;
}
function CalendarYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.year%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "year"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar year result must be an integer");
  if (!IsIntegralNumber(r2))
    throw new RangeError("calendar year result must be an integer");
  return r2;
}
function CalendarMonth(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.month%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "month"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar month result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar month result must be a positive integer");
  return r2;
}
function CalendarMonthCode(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthCode%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "monthCode"), e2, [t2]);
  if ("string" != typeof r2)
    throw new TypeError("calendar monthCode result must be a string");
  return r2;
}
function CalendarDay(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.day%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "day"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar day result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar day result must be a positive integer");
  return r2;
}
function CalendarEra(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.era%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "era"), e2, [t2]);
  if (void 0 === r2)
    return r2;
  if ("string" != typeof r2)
    throw new TypeError("calendar era result must be a string or undefined");
  return r2;
}
function CalendarEraYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.eraYear%"), r3, [t2]);
  }
  let r2 = Call(GetMethod(e2, "eraYear"), e2, [t2]);
  if (void 0 === r2)
    return r2;
  if ("number" != typeof r2)
    throw new TypeError("calendar eraYear result must be an integer or undefined");
  if (!IsIntegralNumber(r2))
    throw new RangeError("calendar eraYear result must be an integer or undefined");
  return r2;
}
function CalendarDayOfWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "dayOfWeek"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar dayOfWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar dayOfWeek result must be a positive integer");
  return r2;
}
function CalendarDayOfYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dayOfYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "dayOfYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar dayOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar dayOfYear result must be a positive integer");
  return r2;
}
function CalendarWeekOfYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.weekOfYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "weekOfYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar weekOfYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar weekOfYear result must be a positive integer");
  return r2;
}
function CalendarYearOfWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearOfWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "yearOfWeek"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar yearOfWeek result must be an integer");
  if (!IsIntegralNumber(r2))
    throw new RangeError("calendar yearOfWeek result must be an integer");
  return r2;
}
function CalendarDaysInWeek(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInWeek%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "daysInWeek"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar daysInWeek result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar daysInWeek result must be a positive integer");
  return r2;
}
function CalendarDaysInMonth(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInMonth%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "daysInMonth"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar daysInMonth result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar daysInMonth result must be a positive integer");
  return r2;
}
function CalendarDaysInYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.daysInYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "daysInYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar daysInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar daysInYear result must be a positive integer");
  return r2;
}
function CalendarMonthsInYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthsInYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "monthsInYear"), e2, [t2]);
  if ("number" != typeof r2)
    throw new TypeError("calendar monthsInYear result must be a positive integer");
  if (!IsIntegralNumber(r2) || r2 < 1)
    throw new RangeError("calendar monthsInYear result must be a positive integer");
  return r2;
}
function CalendarInLeapYear(e2, t2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.inLeapYear%"), r3, [t2]);
  }
  const r2 = Call(GetMethod(e2, "inLeapYear"), e2, [t2]);
  if ("boolean" != typeof r2)
    throw new TypeError("calendar inLeapYear result must be a boolean");
  return r2;
}
function ToTemporalCalendarSlotValue(e2) {
  if (IsObject(e2)) {
    if (HasSlot(e2, p))
      return GetSlot(e2, p);
    if (!function ObjectImplementsTemporalCalendarProtocol(e3) {
      return !!IsTemporalCalendar(e3) || "dateAdd" in e3 && "dateFromFields" in e3 && "dateUntil" in e3 && "day" in e3 && "dayOfWeek" in e3 && "dayOfYear" in e3 && "daysInMonth" in e3 && "daysInWeek" in e3 && "daysInYear" in e3 && "fields" in e3 && "id" in e3 && "inLeapYear" in e3 && "mergeFields" in e3 && "month" in e3 && "monthCode" in e3 && "monthDayFromFields" in e3 && "monthsInYear" in e3 && "weekOfYear" in e3 && "year" in e3 && "yearMonthFromFields" in e3 && "yearOfWeek" in e3;
    }(e2))
      throw new TypeError("expected a Temporal.Calendar or object implementing the Temporal.Calendar protocol");
    return e2;
  }
  const t2 = ToString(e2);
  if (IsBuiltinCalendar(t2))
    return ASCIILowercase(t2);
  let r2;
  try {
    ({ calendar: r2 } = ParseISODateTime(t2));
  } catch (e3) {
    try {
      ({ calendar: r2 } = ParseTemporalYearMonthString(t2));
    } catch (e4) {
      ({ calendar: r2 } = ParseTemporalMonthDayString(t2));
    }
  }
  if (r2 || (r2 = "iso8601"), !IsBuiltinCalendar(r2))
    throw new RangeError(`invalid calendar identifier ${r2}`);
  return ASCIILowercase(r2);
}
function GetTemporalCalendarSlotValueWithISODefault(e2) {
  if (HasSlot(e2, p))
    return GetSlot(e2, p);
  const { calendar: t2 } = e2;
  return void 0 === t2 ? "iso8601" : ToTemporalCalendarSlotValue(t2);
}
function ToTemporalCalendarIdentifier(e2) {
  if ("string" == typeof e2)
    return e2;
  const t2 = e2.id;
  if ("string" != typeof t2)
    throw new TypeError("calendar.id should be a string");
  return t2;
}
function ToTemporalCalendarObject(e2) {
  if (IsObject(e2))
    return e2;
  return new (GetIntrinsic("%Temporal.Calendar%"))(e2);
}
function CalendarEquals(e2, t2) {
  if (e2 === t2)
    return true;
  return ToTemporalCalendarIdentifier(e2) === ToTemporalCalendarIdentifier(t2);
}
function ThrowIfCalendarsNotEqual(e2, t2, r2) {
  if (e2 === t2)
    return;
  const o2 = ToTemporalCalendarIdentifier(e2), n2 = ToTemporalCalendarIdentifier(t2);
  if (o2 !== n2)
    throw new RangeError(`cannot ${r2} of ${o2} and ${n2} calendars`);
}
function ConsolidateCalendars(e2, t2) {
  if (e2 === t2)
    return t2;
  const r2 = ToTemporalCalendarIdentifier(e2), o2 = ToTemporalCalendarIdentifier(t2);
  if (r2 === o2 || "iso8601" === r2)
    return t2;
  if ("iso8601" === o2)
    return e2;
  throw new RangeError("irreconcilable calendars");
}
function CalendarDateFromFields(e2, t2, r2, o2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.dateFromFields%"), o3, [t2, r2]);
  }
  const n2 = Call(o2 != null ? o2 : GetMethod(e2, "dateFromFields"), e2, [t2, r2]);
  if (!IsTemporalDate(n2))
    throw new TypeError("invalid result");
  return n2;
}
function CalendarYearMonthFromFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.yearMonthFromFields%"), o3, [t2, r2]);
  }
  let o2 = Call(GetMethod(e2, "yearMonthFromFields"), e2, [t2, r2]);
  if (!IsTemporalYearMonth(o2))
    throw new TypeError("invalid result");
  return o2;
}
function CalendarMonthDayFromFields(e2, t2, r2) {
  if ("string" == typeof e2) {
    const o3 = new (GetIntrinsic("%Temporal.Calendar%"))(e2);
    return Call(GetIntrinsic("%Temporal.Calendar.prototype.monthDayFromFields%"), o3, [t2, r2]);
  }
  let o2 = Call(GetMethod(e2, "monthDayFromFields"), e2, [t2, r2]);
  if (!IsTemporalMonthDay(o2))
    throw new TypeError("invalid result");
  return o2;
}
function ToTemporalTimeZoneSlotValue(e2) {
  if (IsObject(e2)) {
    if (IsTemporalZonedDateTime(e2))
      return GetSlot(e2, g);
    if (!function ObjectImplementsTemporalTimeZoneProtocol(e3) {
      return !!IsTemporalTimeZone(e3) || "getOffsetNanosecondsFor" in e3 && "getPossibleInstantsFor" in e3 && "id" in e3;
    }(e2))
      throw new TypeError("expected a Temporal.TimeZone or object implementing the Temporal.TimeZone protocol");
    return e2;
  }
  return ParseTemporalTimeZone(ToString(e2));
}
function ToTemporalTimeZoneIdentifier(e2) {
  if ("string" == typeof e2)
    return e2;
  const t2 = e2.id;
  if ("string" != typeof t2)
    throw new TypeError("timeZone.id should be a string");
  return t2;
}
function ToTemporalTimeZoneObject(e2) {
  if (IsObject(e2))
    return e2;
  return new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
}
function TimeZoneEquals(e2, t2) {
  if (e2 === t2)
    return true;
  return ToTemporalTimeZoneIdentifier(e2) === ToTemporalTimeZoneIdentifier(t2);
}
function TemporalDateTimeToDate(e2) {
  return CreateTemporalDate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p));
}
function TemporalDateTimeToTime(e2) {
  return new (GetIntrinsic("%Temporal.PlainTime%"))(GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T));
}
function GetOffsetNanosecondsFor(e2, t2, r2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getOffsetNanosecondsFor%"), r3, [t2]);
  }
  const o2 = Call(r2 != null ? r2 : GetMethod(e2, "getOffsetNanosecondsFor"), e2, [t2]);
  if ("number" != typeof o2)
    throw new TypeError("bad return from getOffsetNanosecondsFor");
  if (!IsIntegralNumber(o2) || ae(o2) >= 864e11)
    throw new RangeError("out-of-range return from getOffsetNanosecondsFor");
  return o2;
}
function GetOffsetStringFor(e2, t2) {
  return FormatTimeZoneOffsetString(GetOffsetNanosecondsFor(e2, t2));
}
function GetPlainDateTimeFor(e2, t2, r2) {
  const o2 = GetSlot(t2, n), a2 = GetOffsetNanosecondsFor(e2, t2);
  let { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = GetISOPartsFromEpoch(o2);
  return { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = BalanceISODateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2 + a2), CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, r2);
}
function GetInstantFor(e2, t2, r2) {
  return DisambiguatePossibleInstants(GetPossibleInstantsFor(e2, t2), e2, t2, r2);
}
function DisambiguatePossibleInstants(t2, r2, o2, n2) {
  const a2 = GetIntrinsic("%Temporal.Instant%"), f2 = t2.length;
  if (1 === f2)
    return t2[0];
  if (f2)
    switch (n2) {
      case "compatible":
      case "earlier":
        return t2[0];
      case "later":
        return t2[f2 - 1];
      case "reject":
        throw new RangeError("multiple instants found");
    }
  const y2 = GetSlot(o2, i), I2 = GetSlot(o2, s), S2 = GetSlot(o2, l), g2 = GetSlot(o2, d), w2 = GetSlot(o2, m), D2 = GetSlot(o2, c), G2 = GetSlot(o2, h), v2 = GetSlot(o2, u), C2 = GetSlot(o2, T), O2 = GetUTCEpochNanoseconds(y2, I2, S2, g2, w2, D2, G2, v2, C2);
  if (null === O2)
    throw new RangeError("DateTime outside of supported range");
  const b2 = new a2(import_jsbi.default.subtract(O2, Ee)), E2 = new a2(import_jsbi.default.add(O2, Ee)), M2 = GetOffsetNanosecondsFor(r2, b2), R2 = GetOffsetNanosecondsFor(r2, E2) - M2;
  switch (n2) {
    case "earlier": {
      const e2 = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -R2, void 0);
      return GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e2))[0];
    }
    case "compatible":
    case "later": {
      const e2 = GetSlot(o2, p), t3 = GetIntrinsic("%Temporal.PlainDateTime%"), n3 = AddDateTime(y2, I2, S2, g2, w2, D2, G2, v2, C2, e2, 0, 0, 0, 0, 0, 0, 0, 0, 0, R2, void 0), a3 = GetPossibleInstantsFor(r2, new t3(n3.year, n3.month, n3.day, n3.hour, n3.minute, n3.second, n3.millisecond, n3.microsecond, n3.nanosecond, e2));
      return a3[a3.length - 1];
    }
    case "reject":
      throw new RangeError("no such instant found");
  }
}
function GetPossibleInstantsFor(e2, t2, r2) {
  if ("string" == typeof e2) {
    const r3 = new (GetIntrinsic("%Temporal.TimeZone%"))(e2);
    return Call(GetIntrinsic("%Temporal.TimeZone.prototype.getPossibleInstantsFor%"), r3, [t2]);
  }
  const o2 = Call(r2 != null ? r2 : GetMethod(e2, "getPossibleInstantsFor"), e2, [t2]), n2 = [];
  for (const e3 of o2) {
    if (!IsTemporalInstant(e3))
      throw new TypeError("bad return from getPossibleInstantsFor");
    te.call(n2, e3);
  }
  return n2;
}
function ISOYearString(e2) {
  let t2;
  if (e2 < 0 || e2 > 9999) {
    t2 = (e2 < 0 ? "-" : "+") + `000000${ae(e2)}`.slice(-6);
  } else
    t2 = `0000${e2}`.slice(-4);
  return t2;
}
function ISODateTimePartString(e2) {
  return `00${e2}`.slice(-2);
}
function FormatSecondsStringPart(e2, t2, r2, o2, n2) {
  if ("minute" === n2)
    return "";
  const a2 = `:${ISODateTimePartString(e2)}`;
  let i2, s2 = 1e6 * t2 + 1e3 * r2 + o2;
  if ("auto" === n2) {
    if (0 === s2)
      return a2;
    for (i2 = `${s2}`.padStart(9, "0"); "0" === i2[i2.length - 1]; )
      i2 = i2.slice(0, -1);
  } else {
    if (0 === n2)
      return a2;
    i2 = `${s2}`.padStart(9, "0").slice(0, n2);
  }
  return `${a2}.${i2}`;
}
function TemporalInstantToString(e2, t2, r2) {
  let o2 = t2;
  void 0 === o2 && (o2 = "UTC");
  const n2 = GetPlainDateTimeFor(o2, e2, "iso8601"), a2 = ISOYearString(GetSlot(n2, i)), p2 = ISODateTimePartString(GetSlot(n2, s)), f2 = ISODateTimePartString(GetSlot(n2, l)), y2 = ISODateTimePartString(GetSlot(n2, d)), I2 = ISODateTimePartString(GetSlot(n2, m)), S2 = FormatSecondsStringPart(GetSlot(n2, c), GetSlot(n2, h), GetSlot(n2, u), GetSlot(n2, T), r2);
  let g2 = "Z";
  if (void 0 !== t2) {
    g2 = FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(o2, e2));
  }
  return `${a2}-${p2}-${f2}T${y2}:${I2}${S2}${g2}`;
}
function TemporalDurationToString(t2, r2 = "auto", o2) {
  function formatNumber(t3) {
    return t3 <= ue ? t3.toString(10) : import_jsbi.default.BigInt(t3).toString(10);
  }
  const n2 = GetSlot(t2, w), a2 = GetSlot(t2, D), i2 = GetSlot(t2, G), s2 = GetSlot(t2, v), l2 = GetSlot(t2, C), d2 = GetSlot(t2, O);
  let m2 = GetSlot(t2, b), c2 = GetSlot(t2, E), h2 = GetSlot(t2, M), u2 = GetSlot(t2, R);
  const T2 = DurationSign(n2, a2, i2, s2, l2, d2, m2, c2, h2, u2);
  if (o2) {
    const { unit: e2, increment: t3, roundingMode: r3 } = o2;
    ({ seconds: m2, milliseconds: c2, microseconds: h2, nanoseconds: u2 } = RoundDuration(0, 0, 0, 0, 0, 0, m2, c2, h2, u2, t3, e2, r3));
  }
  const p2 = [];
  n2 && p2.push(`${formatNumber(ae(n2))}Y`), a2 && p2.push(`${formatNumber(ae(a2))}M`), i2 && p2.push(`${formatNumber(ae(i2))}W`), s2 && p2.push(`${formatNumber(ae(s2))}D`);
  const f2 = [];
  l2 && f2.push(`${formatNumber(ae(l2))}H`), d2 && f2.push(`${formatNumber(ae(d2))}M`);
  const y2 = [];
  let I2, S2, g2, F2, Y2 = TotalDurationNanoseconds(0, 0, 0, m2, c2, h2, u2, 0);
  ({ quotient: Y2, remainder: I2 } = divmod(Y2, De)), { quotient: Y2, remainder: S2 } = divmod(Y2, De), { quotient: F2, remainder: g2 } = divmod(Y2, De);
  const P2 = 1e6 * ae(import_jsbi.default.toNumber(g2)) + 1e3 * ae(import_jsbi.default.toNumber(S2)) + ae(import_jsbi.default.toNumber(I2));
  let Z2;
  if ("auto" === r2) {
    if (0 !== P2)
      for (Z2 = `${P2}`.padStart(9, "0"); "0" === Z2[Z2.length - 1]; )
        Z2 = Z2.slice(0, -1);
  } else
    0 !== r2 && (Z2 = `${P2}`.padStart(9, "0").slice(0, r2));
  return Z2 && y2.unshift(".", Z2), import_jsbi.default.equal(F2, Ie) && !y2.length && "auto" === r2 || y2.unshift(abs(F2).toString()), y2.length && f2.push(`${y2.join("")}S`), f2.length && f2.unshift("T"), p2.length || f2.length ? `${T2 < 0 ? "-" : ""}P${p2.join("")}${f2.join("")}` : "PT0S";
}
function TemporalDateToString(e2, t2 = "auto") {
  return `${ISOYearString(GetSlot(e2, i))}-${ISODateTimePartString(GetSlot(e2, s))}-${ISODateTimePartString(GetSlot(e2, l))}${MaybeFormatCalendarAnnotation(GetSlot(e2, p), t2)}`;
}
function TemporalDateTimeToString(e2, t2, r2 = "auto", o2) {
  let n2 = GetSlot(e2, i), a2 = GetSlot(e2, s), f2 = GetSlot(e2, l), y2 = GetSlot(e2, d), I2 = GetSlot(e2, m), S2 = GetSlot(e2, c), g2 = GetSlot(e2, h), w2 = GetSlot(e2, u), D2 = GetSlot(e2, T);
  if (o2) {
    const { unit: e3, increment: t3, roundingMode: r3 } = o2;
    ({ year: n2, month: a2, day: f2, hour: y2, minute: I2, second: S2, millisecond: g2, microsecond: w2, nanosecond: D2 } = RoundISODateTime(n2, a2, f2, y2, I2, S2, g2, w2, D2, t3, e3, r3));
  }
  return `${ISOYearString(n2)}-${ISODateTimePartString(a2)}-${ISODateTimePartString(f2)}T${ISODateTimePartString(y2)}:${ISODateTimePartString(I2)}${FormatSecondsStringPart(S2, g2, w2, D2, t2)}${MaybeFormatCalendarAnnotation(GetSlot(e2, p), r2)}`;
}
function TemporalMonthDayToString(e2, t2 = "auto") {
  let r2 = `${ISODateTimePartString(GetSlot(e2, s))}-${ISODateTimePartString(GetSlot(e2, l))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 = `${ISOYearString(GetSlot(e2, i))}-${r2}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
function TemporalYearMonthToString(e2, t2 = "auto") {
  let r2 = `${ISOYearString(GetSlot(e2, i))}-${ISODateTimePartString(GetSlot(e2, s))}`;
  const o2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
  if ("always" === t2 || "critical" === t2 || "iso8601" !== o2) {
    r2 += `-${ISODateTimePartString(GetSlot(e2, l))}`;
  }
  const n2 = FormatCalendarAnnotation(o2, t2);
  return n2 && (r2 += n2), r2;
}
function TemporalZonedDateTimeToString(e2, t2, r2 = "auto", o2 = "auto", a2 = "auto", f2) {
  let y2 = GetSlot(e2, S);
  if (f2) {
    const { unit: t3, increment: r3, roundingMode: o3 } = f2, a3 = RoundInstant(GetSlot(e2, n), r3, t3, o3);
    y2 = new (GetIntrinsic("%Temporal.Instant%"))(a3);
  }
  const I2 = GetSlot(e2, g), w2 = GetPlainDateTimeFor(I2, y2, "iso8601");
  let D2 = `${ISOYearString(GetSlot(w2, i))}-${ISODateTimePartString(GetSlot(w2, s))}-${ISODateTimePartString(GetSlot(w2, l))}T${ISODateTimePartString(GetSlot(w2, d))}:${ISODateTimePartString(GetSlot(w2, m))}${FormatSecondsStringPart(GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), t2)}`;
  if ("never" !== a2) {
    D2 += FormatISOTimeZoneOffsetString(GetOffsetNanosecondsFor(I2, y2));
  }
  if ("never" !== o2) {
    D2 += `[${"critical" === o2 ? "!" : ""}${ToTemporalTimeZoneIdentifier(I2)}]`;
  }
  return D2 += MaybeFormatCalendarAnnotation(GetSlot(e2, p), r2), D2;
}
function IsTimeZoneOffsetString(e2) {
  return ze.test(he(e2));
}
function ParseTimeZoneOffsetString(e2) {
  const t2 = ze.exec(he(e2));
  if (!t2)
    throw new RangeError(`invalid time zone offset: ${e2}`);
  return ("-" === t2[1] || "\u2212" === t2[1] ? -1 : 1) * (1e9 * (60 * (60 * +t2[2] + +(t2[3] || 0)) + +(t2[4] || 0)) + +((t2[5] || 0) + "000000000").slice(0, 9));
}
function GetCanonicalTimeZoneIdentifier(e2) {
  if (IsTimeZoneOffsetString(e2)) {
    return FormatTimeZoneOffsetString(ParseTimeZoneOffsetString(e2));
  }
  return getIntlDateTimeFormatEnUsForTimeZone(he(e2)).resolvedOptions().timeZone;
}
function GetNamedTimeZoneOffsetNanoseconds(t2, r2) {
  const { year: o2, month: n2, day: a2, hour: i2, minute: s2, second: l2, millisecond: d2, microsecond: m2, nanosecond: c2 } = GetNamedTimeZoneDateTimeParts(t2, r2), h2 = o2 % 400, u2 = (o2 - h2) / 400, T2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(146097), Ee), p2 = GetUTCEpochNanoseconds(h2, n2, a2, i2, s2, l2, d2, m2, c2), f2 = import_jsbi.default.add(p2, import_jsbi.default.multiply(T2, import_jsbi.default.BigInt(u2)));
  return import_jsbi.default.toNumber(import_jsbi.default.subtract(f2, r2));
}
function FormatTimeZoneOffsetString(e2) {
  const t2 = e2 < 0 ? "-" : "+", r2 = ae(e2), o2 = r2 % 1e9, n2 = ie(r2 / 1e9) % 60, a2 = ie(r2 / 6e10) % 60, i2 = ISODateTimePartString(ie(r2 / 36e11)), s2 = ISODateTimePartString(a2), l2 = ISODateTimePartString(n2);
  let d2 = "";
  if (o2) {
    let e3 = `${o2}`.padStart(9, "0");
    for (; "0" === e3[e3.length - 1]; )
      e3 = e3.slice(0, -1);
    d2 = `:${l2}.${e3}`;
  } else
    n2 && (d2 = `:${l2}`);
  return `${t2}${i2}:${s2}${d2}`;
}
function FormatISOTimeZoneOffsetString(t2) {
  let r2 = import_jsbi.default.toNumber(RoundNumberToIncrement(import_jsbi.default.BigInt(t2), be, "halfExpand"));
  const o2 = r2 < 0 ? "-" : "+";
  r2 = ae(r2);
  const n2 = r2 / 6e10 % 60;
  return `${o2}${ISODateTimePartString(ie(r2 / 36e11))}:${ISODateTimePartString(n2)}`;
}
function GetUTCEpochNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = /* @__PURE__ */ new Date();
  m2.setUTCHours(n2, a2, i2, s2), m2.setUTCFullYear(t2, r2 - 1, o2);
  const c2 = m2.getTime();
  if (de(c2))
    return null;
  let h2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(c2), Ge);
  return h2 = import_jsbi.default.add(h2, import_jsbi.default.multiply(import_jsbi.default.BigInt(l2), De)), h2 = import_jsbi.default.add(h2, import_jsbi.default.BigInt(d2)), import_jsbi.default.lessThan(h2, Me) || import_jsbi.default.greaterThan(h2, Re) ? null : h2;
}
function GetISOPartsFromEpoch(t2) {
  const { quotient: r2, remainder: o2 } = divmod(t2, Ge);
  let n2 = import_jsbi.default.toNumber(r2), a2 = import_jsbi.default.toNumber(o2);
  a2 < 0 && (a2 += 1e6, n2 -= 1);
  const i2 = ie(a2 / 1e3) % 1e3, s2 = a2 % 1e3, l2 = new Date(n2);
  return { epochMilliseconds: n2, year: l2.getUTCFullYear(), month: l2.getUTCMonth() + 1, day: l2.getUTCDate(), hour: l2.getUTCHours(), minute: l2.getUTCMinutes(), second: l2.getUTCSeconds(), millisecond: l2.getUTCMilliseconds(), microsecond: i2, nanosecond: s2 };
}
function GetNamedTimeZoneDateTimeParts(e2, t2) {
  const { epochMilliseconds: r2, millisecond: o2, microsecond: n2, nanosecond: a2 } = GetISOPartsFromEpoch(t2), { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2 } = function GetFormatterParts(e3, t3) {
    const r3 = getIntlDateTimeFormatEnUsForTimeZone(e3).format(new Date(t3));
    return function parseFromEnUsFormat(e4) {
      const t4 = e4.split(/[^\w]+/);
      if (7 !== t4.length)
        throw new RangeError(`expected 7 parts in "${e4}`);
      const r4 = +t4[0], o3 = +t4[1];
      let n3 = +t4[2];
      const a3 = t4[3].toUpperCase();
      if ("B" === a3 || "BC" === a3)
        n3 = 1 - n3;
      else if ("A" !== a3 && "AD" !== a3)
        throw new RangeError(`Unknown era ${a3} in "${e4}`);
      let i3 = +t4[4];
      24 === i3 && (i3 = 0);
      const s3 = +t4[5], l3 = +t4[6];
      if (!(me(n3) && me(r4) && me(o3) && me(i3) && me(s3) && me(l3)))
        throw new RangeError(`Invalid number in "${e4}`);
      return { year: n3, month: r4, day: o3, hour: i3, minute: s3, second: l3 };
    }(r3);
  }(e2, r2);
  return BalanceISODateTime(i2, s2, l2, d2, m2, c2, o2, n2, a2);
}
function maxJSBI(t2, r2) {
  return import_jsbi.default.lessThan(t2, r2) ? r2 : t2;
}
function afterLatestPossibleTzdbRuleChange() {
  return import_jsbi.default.add(Ve(), Ze);
}
function GetNamedTimeZoneNextTransition(t2, r2) {
  if (import_jsbi.default.lessThan(r2, Pe))
    return GetNamedTimeZoneNextTransition(t2, Pe);
  const o2 = import_jsbi.default.add(r2, Be), n2 = maxJSBI(afterLatestPossibleTzdbRuleChange(), o2);
  let a2 = maxJSBI(Pe, r2);
  const i2 = GetNamedTimeZoneOffsetNanoseconds(t2, a2);
  let s2 = a2, l2 = i2;
  for (; i2 === l2 && import_jsbi.default.lessThan(import_jsbi.default.BigInt(a2), n2); ) {
    if (s2 = import_jsbi.default.add(a2, Ne), import_jsbi.default.greaterThan(s2, Re))
      return null;
    l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2), i2 === l2 && (a2 = s2);
  }
  if (i2 === l2)
    return null;
  return bisect((e2) => GetNamedTimeZoneOffsetNanoseconds(t2, e2), a2, s2, i2, l2);
}
function GetNamedTimeZonePreviousTransition(t2, r2) {
  const o2 = afterLatestPossibleTzdbRuleChange(), a2 = import_jsbi.default.greaterThan(r2, o2), i2 = a2 ? import_jsbi.default.subtract(r2, Be) : Pe;
  if ("Africa/Casablanca" === t2 || "Africa/El_Aaiun" === t2) {
    const o3 = GetSlot(ToTemporalInstant("2088-01-01T00Z"), n);
    if (import_jsbi.default.lessThan(o3, r2))
      return GetNamedTimeZonePreviousTransition(t2, o3);
  }
  let s2 = import_jsbi.default.subtract(r2, Se);
  if (import_jsbi.default.lessThan(s2, Pe))
    return null;
  const l2 = GetNamedTimeZoneOffsetNanoseconds(t2, s2);
  let d2 = s2, m2 = l2;
  for (; l2 === m2 && import_jsbi.default.greaterThan(s2, i2); ) {
    if (d2 = import_jsbi.default.subtract(s2, Ne), import_jsbi.default.lessThan(d2, Pe))
      return null;
    m2 = GetNamedTimeZoneOffsetNanoseconds(t2, d2), l2 === m2 && (s2 = d2);
  }
  if (l2 === m2) {
    if (a2) {
      const r3 = import_jsbi.default.subtract(o2, Ee);
      return GetNamedTimeZonePreviousTransition(t2, r3);
    }
    return null;
  }
  return bisect((e2) => GetNamedTimeZoneOffsetNanoseconds(t2, e2), d2, s2, m2, l2);
}
function LeapYear(e2) {
  if (void 0 === e2)
    return false;
  return e2 % 4 == 0 && (!(e2 % 100 == 0) || e2 % 400 == 0);
}
function ISODaysInMonth(e2, t2) {
  return { standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] }[LeapYear(e2) ? "leapyear" : "standard"][t2 - 1];
}
function DayOfWeek(e2, t2, r2) {
  const o2 = t2 + (t2 < 3 ? 10 : -2), n2 = e2 - (t2 < 3 ? 1 : 0), a2 = ie(n2 / 100), i2 = n2 - 100 * a2, s2 = (r2 + ie(2.6 * o2 - 0.2) + (i2 + ie(i2 / 4)) + (ie(a2 / 4) - 2 * a2)) % 7;
  return s2 + (s2 <= 0 ? 7 : 0);
}
function DayOfYear(e2, t2, r2) {
  let o2 = r2;
  for (let r3 = t2 - 1; r3 > 0; r3--)
    o2 += ISODaysInMonth(e2, r3);
  return o2;
}
function WeekOfYear(e2, t2, r2) {
  const o2 = DayOfYear(e2, t2, r2), n2 = DayOfWeek(e2, t2, r2) || 7, a2 = DayOfWeek(e2, 1, 1), i2 = ie((o2 - n2 + 10) / 7);
  return i2 < 1 ? 5 === a2 || 6 === a2 && LeapYear(e2 - 1) ? { week: 53, year: e2 - 1 } : { week: 52, year: e2 - 1 } : 53 === i2 && (LeapYear(e2) ? 366 : 365) - o2 < 4 - n2 ? { week: 1, year: e2 + 1 } : { week: i2, year: e2 };
}
function DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  for (const m2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2])
    if (0 !== m2)
      return m2 < 0 ? -1 : 1;
  return 0;
}
function BalanceISOYearMonth(e2, t2) {
  let r2 = e2, o2 = t2;
  if (!me(r2) || !me(o2))
    throw new RangeError("infinity is out of range");
  return o2 -= 1, r2 += ie(o2 / 12), o2 %= 12, o2 < 0 && (o2 += 12), o2 += 1, { year: r2, month: o2 };
}
function BalanceISODate(e2, t2, r2) {
  let o2 = e2, n2 = t2, a2 = r2;
  if (!me(a2))
    throw new RangeError("infinity is out of range");
  ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2));
  const i2 = 146097;
  if (ae(a2) > i2) {
    const e3 = le(a2 / i2);
    o2 += 400 * e3, a2 -= e3 * i2;
  }
  let s2 = 0, l2 = n2 > 2 ? o2 : o2 - 1;
  for (; s2 = LeapYear(l2) ? 366 : 365, a2 < -s2; )
    o2 -= 1, l2 -= 1, a2 += s2;
  for (l2 += 1; s2 = LeapYear(l2) ? 366 : 365, a2 > s2; )
    o2 += 1, l2 += 1, a2 -= s2;
  for (; a2 < 1; )
    ({ year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 - 1)), a2 += ISODaysInMonth(o2, n2);
  for (; a2 > ISODaysInMonth(o2, n2); )
    a2 -= ISODaysInMonth(o2, n2), { year: o2, month: n2 } = BalanceISOYearMonth(o2, n2 + 1);
  return { year: o2, month: n2, day: a2 };
}
function BalanceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  const { deltaDays: d2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 } = BalanceTime(o2, n2, a2, i2, s2, l2), { year: f2, month: y2, day: I2 } = BalanceISODate(e2, t2, r2 + d2);
  return { year: f2, month: y2, day: I2, hour: m2, minute: c2, second: h2, millisecond: u2, microsecond: T2, nanosecond: p2 };
}
function BalanceTime(t2, r2, o2, n2, a2, i2) {
  let s2, l2 = import_jsbi.default.BigInt(t2), d2 = import_jsbi.default.BigInt(r2), m2 = import_jsbi.default.BigInt(o2), c2 = import_jsbi.default.BigInt(n2), h2 = import_jsbi.default.BigInt(a2), u2 = import_jsbi.default.BigInt(i2);
  return { quotient: s2, remainder: u2 } = NonNegativeBigIntDivmod(u2, De), h2 = import_jsbi.default.add(h2, s2), { quotient: s2, remainder: h2 } = NonNegativeBigIntDivmod(h2, De), c2 = import_jsbi.default.add(c2, s2), { quotient: s2, remainder: c2 } = NonNegativeBigIntDivmod(c2, De), m2 = import_jsbi.default.add(m2, s2), { quotient: s2, remainder: m2 } = NonNegativeBigIntDivmod(m2, ge), d2 = import_jsbi.default.add(d2, s2), { quotient: s2, remainder: d2 } = NonNegativeBigIntDivmod(d2, ge), l2 = import_jsbi.default.add(l2, s2), { quotient: s2, remainder: l2 } = NonNegativeBigIntDivmod(l2, we), { deltaDays: import_jsbi.default.toNumber(s2), hour: import_jsbi.default.toNumber(l2), minute: import_jsbi.default.toNumber(d2), second: import_jsbi.default.toNumber(m2), millisecond: import_jsbi.default.toNumber(c2), microsecond: import_jsbi.default.toNumber(h2), nanosecond: import_jsbi.default.toNumber(u2) };
}
function TotalDurationNanoseconds(t2, r2, o2, n2, a2, i2, s2, l2) {
  const d2 = import_jsbi.default.BigInt(t2);
  let m2 = import_jsbi.default.BigInt(s2);
  0 !== t2 && (m2 = import_jsbi.default.subtract(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(l2)));
  const c2 = import_jsbi.default.add(import_jsbi.default.BigInt(r2), import_jsbi.default.multiply(d2, import_jsbi.default.BigInt(24))), h2 = import_jsbi.default.add(import_jsbi.default.BigInt(o2), import_jsbi.default.multiply(c2, ge)), u2 = import_jsbi.default.add(import_jsbi.default.BigInt(n2), import_jsbi.default.multiply(h2, ge)), T2 = import_jsbi.default.add(import_jsbi.default.BigInt(a2), import_jsbi.default.multiply(u2, De)), p2 = import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.multiply(T2, De));
  return import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.multiply(p2, De));
}
function NanosecondsToDays(t2, r2) {
  const o2 = GetIntrinsic("%Temporal.Instant%"), a2 = se(import_jsbi.default.toNumber(t2));
  let f2 = import_jsbi.default.BigInt(t2), y2 = 864e11;
  if (0 === a2)
    return { days: 0, nanoseconds: Ie, dayLengthNs: y2 };
  if (!IsTemporalZonedDateTime(r2)) {
    let t3;
    return { quotient: t3, remainder: f2 } = divmod(f2, import_jsbi.default.BigInt(y2)), { days: import_jsbi.default.toNumber(t3), nanoseconds: f2, dayLengthNs: y2 };
  }
  const I2 = GetSlot(r2, n), w2 = GetSlot(r2, S), D2 = import_jsbi.default.add(I2, f2), G2 = new o2(D2), v2 = GetSlot(r2, g), C2 = GetSlot(r2, p), O2 = GetPlainDateTimeFor(v2, w2, C2), b2 = GetPlainDateTimeFor(v2, G2, C2);
  let { days: E2 } = DifferenceISODateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(O2, d), GetSlot(O2, m), GetSlot(O2, c), GetSlot(O2, h), GetSlot(O2, u), GetSlot(O2, T), GetSlot(b2, i), GetSlot(b2, s), GetSlot(b2, l), GetSlot(b2, d), GetSlot(b2, m), GetSlot(b2, c), GetSlot(b2, h), GetSlot(b2, u), GetSlot(b2, T), C2, "day", Te(null)), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, E2, 0, 0, 0, 0, 0, 0), R2 = import_jsbi.default.BigInt(E2);
  if (1 === a2)
    for (; import_jsbi.default.greaterThan(R2, Ie) && import_jsbi.default.greaterThan(M2, D2); )
      R2 = import_jsbi.default.subtract(R2, Se), M2 = AddZonedDateTime(w2, v2, C2, 0, 0, 0, import_jsbi.default.toNumber(R2), 0, 0, 0, 0, 0, 0);
  f2 = import_jsbi.default.subtract(D2, M2);
  let F2 = false, Y2 = new o2(M2);
  do {
    const t3 = AddZonedDateTime(Y2, v2, C2, 0, 0, 0, a2, 0, 0, 0, 0, 0, 0), r3 = GetSlot(Y2, n);
    y2 = import_jsbi.default.toNumber(import_jsbi.default.subtract(t3, r3)), F2 = import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(f2, import_jsbi.default.BigInt(y2)), import_jsbi.default.BigInt(a2)), Ie), F2 && (f2 = import_jsbi.default.subtract(f2, import_jsbi.default.BigInt(y2)), Y2 = new o2(t3), R2 = import_jsbi.default.add(R2, import_jsbi.default.BigInt(a2)));
  } while (F2);
  if (!isZero(R2) && signJSBI(R2) !== a2)
    throw new RangeError("Time zone or calendar converted nanoseconds into a number of days with the opposite sign");
  if (!isZero(f2) && signJSBI(f2) !== a2) {
    if (isNegativeJSBI(f2) && 1 === a2)
      throw new Error("assert not reached");
    throw new RangeError("Time zone or calendar ended up with a remainder of nanoseconds with the opposite sign");
  }
  if (import_jsbi.default.greaterThanOrEqual(abs(f2), abs(import_jsbi.default.BigInt(y2))))
    throw new Error("assert not reached");
  return { days: import_jsbi.default.toNumber(R2), nanoseconds: f2, dayLengthNs: ae(y2) };
}
function BalanceDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  let d2 = BalancePossiblyInfiniteDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2);
  if ("positive overflow" === d2 || "negative overflow" === d2)
    throw new RangeError("Duration out of range");
  return d2;
}
function BalancePossiblyInfiniteDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2) {
  let c2, h2, u2, T2, f2, y2, I2 = t2;
  if (IsTemporalZonedDateTime(m2)) {
    const t3 = AddZonedDateTime(GetSlot(m2, S), GetSlot(m2, g), GetSlot(m2, p), 0, 0, 0, I2, r2, o2, a2, i2, s2, l2), d3 = GetSlot(m2, n);
    c2 = import_jsbi.default.subtract(t3, d3);
  } else
    c2 = TotalDurationNanoseconds(I2, r2, o2, a2, i2, s2, l2, 0);
  "year" === d2 || "month" === d2 || "week" === d2 || "day" === d2 ? { days: I2, nanoseconds: c2 } = NanosecondsToDays(c2, m2) : I2 = 0;
  const w2 = import_jsbi.default.lessThan(c2, Ie) ? -1 : 1;
  switch (c2 = abs(c2), h2 = u2 = T2 = f2 = y2 = Ie, d2) {
    case "year":
    case "month":
    case "week":
    case "day":
    case "hour":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge), { quotient: y2, remainder: f2 } = divmod(f2, ge);
      break;
    case "minute":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De), { quotient: f2, remainder: T2 } = divmod(T2, ge);
      break;
    case "second":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De), { quotient: T2, remainder: u2 } = divmod(u2, De);
      break;
    case "millisecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De)), { quotient: u2, remainder: h2 } = divmod(h2, De);
      break;
    case "microsecond":
      ({ quotient: h2, remainder: c2 } = divmod(c2, De));
      break;
    case "nanosecond":
      break;
    default:
      throw new Error("assert not reached");
  }
  const D2 = import_jsbi.default.toNumber(y2) * w2, G2 = import_jsbi.default.toNumber(f2) * w2, v2 = import_jsbi.default.toNumber(T2) * w2, C2 = import_jsbi.default.toNumber(u2) * w2, O2 = import_jsbi.default.toNumber(h2) * w2, b2 = import_jsbi.default.toNumber(c2) * w2;
  for (const e2 of [I2, D2, G2, v2, C2, O2, b2])
    if (!me(e2))
      return 1 === w2 ? "positive overflow" : "negative overflow";
  return { days: I2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
}
function UnbalanceDurationRelative(t2, r2, o2, n2, a2, i2) {
  const s2 = GetIntrinsic("%Temporal.Duration%"), l2 = DurationSign(t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
  if (0 === l2)
    return { years: t2, months: r2, weeks: o2, days: n2 };
  const d2 = import_jsbi.default.BigInt(l2);
  let m2, c2, h2 = import_jsbi.default.BigInt(t2), u2 = import_jsbi.default.BigInt(r2), T2 = import_jsbi.default.BigInt(o2), f2 = import_jsbi.default.BigInt(n2);
  i2 && (c2 = ToTemporalDate(i2), m2 = GetSlot(c2, p));
  const y2 = new s2(l2), I2 = new s2(0, l2), S2 = new s2(0, 0, l2);
  switch (a2) {
    case "year":
      break;
    case "month":
      {
        if (!m2)
          throw new RangeError("a starting point is required for months balancing");
        let t3, r3;
        for ("string" != typeof m2 && (t3 = GetMethod(m2, "dateAdd"), r3 = GetMethod(m2, "dateUntil")); !isZero(h2); ) {
          const o3 = CalendarDateAdd(m2, c2, y2, void 0, t3), n3 = Te(null);
          n3.largestUnit = "month";
          const a3 = CalendarDateUntil(m2, c2, o3, n3, r3), i3 = import_jsbi.default.BigInt(GetSlot(a3, D));
          c2 = o3, u2 = import_jsbi.default.add(u2, i3), h2 = import_jsbi.default.subtract(h2, d2);
        }
      }
      break;
    case "week": {
      if (!m2)
        throw new RangeError("a starting point is required for weeks balancing");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), h2 = import_jsbi.default.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), u2 = import_jsbi.default.subtract(u2, d2);
      }
      break;
    }
    default: {
      if (isZero(h2) && isZero(u2) && isZero(T2))
        break;
      if (!m2)
        throw new RangeError("a starting point is required for balancing calendar units");
      const t3 = "string" != typeof m2 ? GetMethod(m2, "dateAdd") : void 0;
      for (; !isZero(h2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, y2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), h2 = import_jsbi.default.subtract(h2, d2);
      }
      for (; !isZero(u2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, I2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), u2 = import_jsbi.default.subtract(u2, d2);
      }
      for (; !isZero(T2); ) {
        let r3;
        ({ relativeTo: c2, days: r3 } = MoveRelativeDate(m2, c2, S2, t3)), f2 = import_jsbi.default.add(f2, import_jsbi.default.BigInt(r3)), T2 = import_jsbi.default.subtract(T2, d2);
      }
      break;
    }
  }
  return { years: import_jsbi.default.toNumber(h2), months: import_jsbi.default.toNumber(u2), weeks: import_jsbi.default.toNumber(T2), days: import_jsbi.default.toNumber(f2) };
}
function CalculateOffsetShift(e2, t2, r2, o2, n2) {
  if (IsTemporalZonedDateTime(e2)) {
    const a2 = GetSlot(e2, S), i2 = GetSlot(e2, g), s2 = GetSlot(e2, p), l2 = GetOffsetNanosecondsFor(i2, a2), d2 = AddZonedDateTime(a2, i2, s2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0);
    return GetOffsetNanosecondsFor(i2, new (GetIntrinsic("%Temporal.Instant%"))(d2)) - l2;
  }
  return 0;
}
function CreateNegatedTemporalDuration(e2) {
  return new (GetIntrinsic("%Temporal.Duration%"))(-GetSlot(e2, w), -GetSlot(e2, D), -GetSlot(e2, G), -GetSlot(e2, v), -GetSlot(e2, C), -GetSlot(e2, O), -GetSlot(e2, b), -GetSlot(e2, E), -GetSlot(e2, M), -GetSlot(e2, R));
}
function ConstrainToRange(e2, t2, r2) {
  return oe(r2, ne(t2, e2));
}
function ConstrainISODate(e2, t2, r2) {
  const o2 = ConstrainToRange(t2, 1, 12);
  return { year: e2, month: o2, day: ConstrainToRange(r2, 1, ISODaysInMonth(e2, o2)) };
}
function RejectToRange(e2, t2, r2) {
  if (e2 < t2 || e2 > r2)
    throw new RangeError(`value out of range: ${t2} <= ${e2} <= ${r2}`);
}
function RejectISODate(e2, t2, r2) {
  RejectToRange(t2, 1, 12), RejectToRange(r2, 1, ISODaysInMonth(e2, t2));
}
function RejectDateRange(e2, t2, r2) {
  RejectDateTimeRange(e2, t2, r2, 12, 0, 0, 0, 0, 0);
}
function RejectTime(e2, t2, r2, o2, n2, a2) {
  RejectToRange(e2, 0, 23), RejectToRange(t2, 0, 59), RejectToRange(r2, 0, 59), RejectToRange(o2, 0, 999), RejectToRange(n2, 0, 999), RejectToRange(a2, 0, 999);
}
function RejectDateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  RejectISODate(e2, t2, r2), RejectTime(o2, n2, a2, i2, s2, l2);
}
function RejectDateTimeRange(e2, t2, r2, o2, n2, a2, i2, s2, l2) {
  if (RejectToRange(e2, Fe, Ye), e2 === Fe && null == GetUTCEpochNanoseconds(e2, t2, r2 + 1, o2, n2, a2, i2, s2, l2 - 1) || e2 === Ye && null == GetUTCEpochNanoseconds(e2, t2, r2 - 1, o2, n2, a2, i2, s2, l2 + 1))
    throw new RangeError("DateTime outside of supported range");
}
function ValidateEpochNanoseconds(t2) {
  if (import_jsbi.default.lessThan(t2, Me) || import_jsbi.default.greaterThan(t2, Re))
    throw new RangeError("Instant outside of supported range");
}
function RejectDuration(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2) {
  const m2 = DurationSign(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2);
  for (const c2 of [e2, t2, r2, o2, n2, a2, i2, s2, l2, d2]) {
    if (!me(c2))
      throw new RangeError("infinite values not allowed as duration fields");
    const e3 = se(c2);
    if (0 !== e3 && e3 !== m2)
      throw new RangeError("mixed-sign values not allowed as duration fields");
  }
}
function DifferenceISODate(e2, t2, r2, o2, n2, a2, i2) {
  switch (i2) {
    case "year":
    case "month": {
      const s2 = -CompareISODate(e2, t2, r2, o2, n2, a2);
      if (0 === s2)
        return { years: 0, months: 0, weeks: 0, days: 0 };
      const l2 = { year: e2, month: t2, day: r2 }, d2 = { year: o2, month: n2, day: a2 };
      let m2 = d2.year - l2.year, c2 = AddISODate(e2, t2, r2, m2, 0, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2);
      if (0 === h2)
        return "year" === i2 ? { years: m2, months: 0, weeks: 0, days: 0 } : { years: 0, months: 12 * m2, weeks: 0, days: 0 };
      let u2 = d2.month - l2.month;
      if (h2 !== s2 && (m2 -= s2, u2 += 12 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"), h2 = -CompareISODate(c2.year, c2.month, c2.day, o2, n2, a2), 0 === h2)
        return "year" === i2 ? { years: m2, months: u2, weeks: 0, days: 0 } : { years: 0, months: u2 + 12 * m2, weeks: 0, days: 0 };
      h2 !== s2 && (u2 -= s2, u2 === -s2 && (m2 -= s2, u2 = 11 * s2), c2 = AddISODate(e2, t2, r2, m2, u2, 0, 0, "constrain"));
      let T2 = 0;
      return T2 = c2.month === d2.month ? d2.day - c2.day : s2 < 0 ? -c2.day - (ISODaysInMonth(d2.year, d2.month) - d2.day) : d2.day + (ISODaysInMonth(c2.year, c2.month) - c2.day), "month" === i2 && (u2 += 12 * m2, m2 = 0), { years: m2, months: u2, weeks: 0, days: T2 };
    }
    case "week":
    case "day": {
      let s2, l2, d2;
      CompareISODate(e2, t2, r2, o2, n2, a2) < 0 ? (l2 = { year: e2, month: t2, day: r2 }, s2 = { year: o2, month: n2, day: a2 }, d2 = 1) : (l2 = { year: o2, month: n2, day: a2 }, s2 = { year: e2, month: t2, day: r2 }, d2 = -1);
      let m2 = DayOfYear(s2.year, s2.month, s2.day) - DayOfYear(l2.year, l2.month, l2.day);
      for (let e3 = l2.year; e3 < s2.year; ++e3)
        m2 += LeapYear(e3) ? 366 : 365;
      let c2 = 0;
      return "week" === i2 && (c2 = ie(m2 / 7), m2 %= 7), c2 *= d2, m2 *= d2, { years: 0, months: 0, weeks: c2, days: m2 };
    }
    default:
      throw new Error("assert not reached");
  }
}
function DifferenceTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = i2 - e2, u2 = s2 - t2, T2 = l2 - r2, p2 = d2 - o2, f2 = m2 - n2, y2 = c2 - a2;
  const I2 = DurationSign(0, 0, 0, 0, h2, u2, T2, p2, f2, y2);
  h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2;
  let S2 = 0;
  if ({ deltaDays: S2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), 0 != S2)
    throw new Error("assertion failure in DifferenceTime: _bt_.[[Days]] should be 0");
  return h2 *= I2, u2 *= I2, T2 *= I2, p2 *= I2, f2 *= I2, y2 *= I2, { hours: h2, minutes: u2, seconds: T2, milliseconds: p2, microseconds: f2, nanoseconds: y2 };
}
function DifferenceInstant(t2, r2, o2, n2, a2, i2) {
  const s2 = import_jsbi.default.subtract(r2, t2);
  let l2 = 0, d2 = 0, m2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(s2, De)), c2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(s2, De), De)), h2 = import_jsbi.default.toNumber(import_jsbi.default.remainder(import_jsbi.default.divide(s2, Ge), De)), u2 = import_jsbi.default.toNumber(import_jsbi.default.divide(s2, ve));
  return { hours: l2, minutes: d2, seconds: u2, milliseconds: h2, microseconds: c2, nanoseconds: m2 } = RoundDuration(0, 0, 0, 0, 0, 0, u2, h2, c2, m2, o2, n2, i2), BalanceDuration(0, l2, d2, u2, h2, c2, m2, a2);
}
function DifferenceISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2) {
  let w2 = e2, D2 = t2, G2 = r2, { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = DifferenceTime(o2, n2, a2, i2, s2, l2, h2, u2, T2, p2, f2, y2);
  const R2 = DurationSign(0, 0, 0, 0, v2, C2, O2, b2, E2, M2);
  CompareISODate(d2, m2, c2, w2, D2, G2) === -R2 && ({ year: w2, month: D2, day: G2 } = BalanceISODate(w2, D2, G2 - R2), { hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration(-R2, v2, C2, O2, b2, E2, M2, S2));
  const F2 = CreateTemporalDate(w2, D2, G2, I2), Y2 = CreateTemporalDate(d2, m2, c2, I2), P2 = LargerOfTwoTemporalUnits("day", S2), Z2 = CopyOptions(g2);
  Z2.largestUnit = P2;
  let { years: B2, months: N2, weeks: j2, days: $2 } = CalendarDateUntil(I2, F2, Y2, Z2);
  return { days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 } = BalanceDuration($2, v2, C2, O2, b2, E2, M2, S2), { years: B2, months: N2, weeks: j2, days: $2, hours: v2, minutes: C2, seconds: O2, milliseconds: b2, microseconds: E2, nanoseconds: M2 };
}
function DifferenceZonedDateTime(t2, r2, o2, n2, a2, p2) {
  const f2 = import_jsbi.default.subtract(r2, t2);
  if (import_jsbi.default.equal(f2, Ie))
    return { years: 0, months: 0, weeks: 0, days: 0, hours: 0, minutes: 0, seconds: 0, milliseconds: 0, microseconds: 0, nanoseconds: 0 };
  const y2 = GetIntrinsic("%Temporal.Instant%"), I2 = new y2(t2), S2 = new y2(r2), g2 = GetPlainDateTimeFor(o2, I2, n2), w2 = GetPlainDateTimeFor(o2, S2, n2);
  let { years: D2, months: G2, weeks: v2, days: C2 } = DifferenceISODateTime(GetSlot(g2, i), GetSlot(g2, s), GetSlot(g2, l), GetSlot(g2, d), GetSlot(g2, m), GetSlot(g2, c), GetSlot(g2, h), GetSlot(g2, u), GetSlot(g2, T), GetSlot(w2, i), GetSlot(w2, s), GetSlot(w2, l), GetSlot(w2, d), GetSlot(w2, m), GetSlot(w2, c), GetSlot(w2, h), GetSlot(w2, u), GetSlot(w2, T), n2, a2, p2);
  const O2 = AddZonedDateTime(I2, o2, n2, D2, G2, v2, 0, 0, 0, 0, 0, 0, 0);
  let b2 = import_jsbi.default.subtract(r2, O2);
  const E2 = CreateTemporalZonedDateTime(O2, o2, n2);
  ({ nanoseconds: b2, days: C2 } = NanosecondsToDays(b2, E2));
  const { hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(b2), "hour");
  return { years: D2, months: G2, weeks: v2, days: C2, hours: M2, minutes: R2, seconds: F2, milliseconds: Y2, microseconds: P2, nanoseconds: Z2 };
}
function GetDifferenceSettings(e2, t2, r2, o2, n2, a2) {
  const i2 = Ue.reduce((e3, t3) => {
    const n3 = t3[0], a3 = t3[1], i3 = t3[2];
    return "datetime" !== r2 && i3 !== r2 || o2.includes(a3) || e3.push(a3, n3), e3;
  }, []);
  let s2 = GetTemporalUnit(t2, "largestUnit", r2, "auto");
  if (o2.includes(s2))
    throw new RangeError(`largestUnit must be one of ${i2.join(", ")}, not ${s2}`);
  const l2 = ToTemporalRoundingIncrement(t2);
  let d2 = ToTemporalRoundingMode(t2, "trunc");
  "since" === e2 && (d2 = function NegateTemporalRoundingMode(e3) {
    switch (e3) {
      case "ceil":
        return "floor";
      case "floor":
        return "ceil";
      case "halfCeil":
        return "halfFloor";
      case "halfFloor":
        return "halfCeil";
      default:
        return e3;
    }
  }(d2));
  const m2 = GetTemporalUnit(t2, "smallestUnit", r2, n2);
  if (o2.includes(m2))
    throw new RangeError(`smallestUnit must be one of ${i2.join(", ")}, not ${m2}`);
  const c2 = LargerOfTwoTemporalUnits(a2, m2);
  if ("auto" === s2 && (s2 = c2), LargerOfTwoTemporalUnits(s2, m2) !== s2)
    throw new RangeError(`largestUnit ${s2} cannot be smaller than smallestUnit ${m2}`);
  const h2 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[m2];
  return void 0 !== h2 && ValidateTemporalRoundingIncrement(l2, h2, false), { largestUnit: s2, roundingIncrement: l2, roundingMode: d2, smallestUnit: m2 };
}
function DifferenceTemporalInstant(e2, t2, r2, o2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalInstant(r2), s2 = GetDifferenceSettings(e2, CopyOptions(o2), "time", [], "nanosecond", "second"), l2 = GetSlot(t2, n), d2 = GetSlot(i2, n);
  let { hours: m2, minutes: c2, seconds: h2, milliseconds: u2, microseconds: T2, nanoseconds: p2 } = DifferenceInstant(l2, d2, s2.roundingIncrement, s2.smallestUnit, s2.largestUnit, s2.roundingMode);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, a2 * m2, a2 * c2, a2 * h2, a2 * u2, a2 * T2, a2 * p2);
}
function DifferenceTemporalPlainDate(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDate(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between dates");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e2, s2, "date", [], "day", "day");
  s2.largestUnit = l2.largestUnit;
  let { years: d2, months: m2, weeks: c2, days: h2 } = CalendarDateUntil(i2, t2, a2, s2);
  "day" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: d2, months: m2, weeks: c2, days: h2 } = RoundDuration(d2, m2, c2, h2, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, t2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * d2, n2 * m2, n2 * c2, n2 * h2, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalPlainDateTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalDateTime(r2), f2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(f2, GetSlot(a2, p), "compute difference between dates");
  const y2 = CopyOptions(o2), I2 = GetDifferenceSettings(e2, y2, "datetime", [], "nanosecond", "day");
  let { years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = DifferenceISODateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, i), GetSlot(a2, s), GetSlot(a2, l), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), f2, I2.largestUnit, y2);
  const M2 = TemporalDateTimeToDate(t2);
  ({ years: S2, months: g2, weeks: w2, days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = RoundDuration(S2, g2, w2, D2, G2, v2, C2, O2, b2, E2, I2.roundingIncrement, I2.smallestUnit, I2.roundingMode, M2)), { days: D2, hours: G2, minutes: v2, seconds: C2, milliseconds: O2, microseconds: b2, nanoseconds: E2 } = BalanceDuration(D2, G2, v2, C2, O2, b2, E2, I2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, n2 * C2, n2 * O2, n2 * b2, n2 * E2);
}
function DifferenceTemporalPlainTime(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalTime(r2), i2 = GetDifferenceSettings(e2, CopyOptions(o2), "time", [], "nanosecond", "hour");
  let { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = DifferenceTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T));
  ({ hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = RoundDuration(0, 0, 0, 0, s2, l2, p2, f2, y2, I2, i2.roundingIncrement, i2.smallestUnit, i2.roundingMode)), { hours: s2, minutes: l2, seconds: p2, milliseconds: f2, microseconds: y2, nanoseconds: I2 } = BalanceDuration(0, s2, l2, p2, f2, y2, I2, i2.largestUnit);
  return new (GetIntrinsic("%Temporal.Duration%"))(0, 0, 0, 0, n2 * s2, n2 * l2, n2 * p2, n2 * f2, n2 * y2, n2 * I2);
}
function DifferenceTemporalPlainYearMonth(e2, t2, r2, o2) {
  const n2 = "since" === e2 ? -1 : 1, a2 = ToTemporalYearMonth(r2), i2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(i2, GetSlot(a2, p), "compute difference between months");
  const s2 = CopyOptions(o2), l2 = GetDifferenceSettings(e2, s2, "date", ["week", "day"], "month", "year");
  s2.largestUnit = l2.largestUnit;
  const d2 = CalendarFields(i2, ["monthCode", "year"]), m2 = PrepareTemporalFields(t2, d2, []);
  m2.day = 1;
  const c2 = CalendarDateFromFields(i2, m2), h2 = PrepareTemporalFields(a2, d2, []);
  h2.day = 1;
  const u2 = CalendarDateFromFields(i2, h2);
  let { years: T2, months: f2 } = CalendarDateUntil(i2, c2, u2, s2);
  "month" === l2.smallestUnit && 1 === l2.roundingIncrement || ({ years: T2, months: f2 } = RoundDuration(T2, f2, 0, 0, 0, 0, 0, 0, 0, 0, l2.roundingIncrement, l2.smallestUnit, l2.roundingMode, c2));
  return new (GetIntrinsic("%Temporal.Duration%"))(n2 * T2, n2 * f2, 0, 0, 0, 0, 0, 0, 0, 0);
}
function DifferenceTemporalZonedDateTime(e2, t2, r2, o2) {
  const a2 = "since" === e2 ? -1 : 1, i2 = ToTemporalZonedDateTime(r2), s2 = GetSlot(t2, p);
  ThrowIfCalendarsNotEqual(s2, GetSlot(i2, p), "compute difference between dates");
  const l2 = CopyOptions(o2), d2 = GetDifferenceSettings(e2, l2, "datetime", [], "nanosecond", "hour");
  l2.largestUnit = d2.largestUnit;
  const m2 = GetSlot(t2, n), c2 = GetSlot(i2, n);
  let h2, u2, T2, f2, y2, I2, S2, w2, D2, G2;
  if ("year" !== d2.largestUnit && "month" !== d2.largestUnit && "week" !== d2.largestUnit && "day" !== d2.largestUnit)
    h2 = 0, u2 = 0, T2 = 0, f2 = 0, { hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceInstant(m2, c2, d2.roundingIncrement, d2.smallestUnit, d2.largestUnit, d2.roundingMode);
  else {
    const e3 = GetSlot(t2, g);
    if (!TimeZoneEquals(e3, GetSlot(i2, g)))
      throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");
    ({ years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = DifferenceZonedDateTime(m2, c2, e3, s2, d2.largestUnit, l2)), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = RoundDuration(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2), { years: h2, months: u2, weeks: T2, days: f2, hours: y2, minutes: I2, seconds: S2, milliseconds: w2, microseconds: D2, nanoseconds: G2 } = AdjustRoundedDurationDays(h2, u2, T2, f2, y2, I2, S2, w2, D2, G2, d2.roundingIncrement, d2.smallestUnit, d2.roundingMode, t2);
  }
  return new (GetIntrinsic("%Temporal.Duration%"))(a2 * h2, a2 * u2, a2 * T2, a2 * f2, a2 * y2, a2 * I2, a2 * S2, a2 * w2, a2 * D2, a2 * G2);
}
function AddISODate(e2, t2, r2, o2, n2, a2, i2, s2) {
  let l2 = e2, d2 = t2, m2 = r2, c2 = a2, h2 = i2;
  return l2 += o2, d2 += n2, { year: l2, month: d2 } = BalanceISOYearMonth(l2, d2), { year: l2, month: d2, day: m2 } = RegulateISODate(l2, d2, m2, s2), h2 += 7 * c2, m2 += h2, { year: l2, month: d2, day: m2 } = BalanceISODate(l2, d2, m2), { year: l2, month: d2, day: m2 };
}
function AddTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2) {
  let h2 = e2, u2 = t2, T2 = r2, p2 = o2, f2 = n2, y2 = a2;
  h2 += i2, u2 += s2, T2 += l2, p2 += d2, f2 += m2, y2 += c2;
  let I2 = 0;
  return { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 } = BalanceTime(h2, u2, T2, p2, f2, y2), { deltaDays: I2, hour: h2, minute: u2, second: T2, millisecond: p2, microsecond: f2, nanosecond: y2 };
}
function AddDuration(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2, C2) {
  const O2 = LargerOfTwoTemporalUnits(DefaultTemporalLargestUnit(t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), DefaultTemporalLargestUnit(h2, u2, T2, f2, y2, I2, w2, D2, G2, v2));
  let b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2;
  if (C2)
    if (IsTemporalDate(C2)) {
      const n2 = GetIntrinsic("%Temporal.Duration%"), S2 = GetSlot(C2, p), g2 = new n2(t2, r2, o2, a2, 0, 0, 0, 0, 0, 0), j2 = new n2(h2, u2, T2, f2, 0, 0, 0, 0, 0, 0), $2 = "string" != typeof S2 ? GetMethod(S2, "dateAdd") : void 0, k2 = CalendarDateAdd(S2, C2, g2, void 0, $2), U2 = CalendarDateAdd(S2, k2, j2, void 0, $2), A2 = LargerOfTwoTemporalUnits("day", O2), L2 = Te(null);
      L2.largestUnit = A2, { years: b2, months: E2, weeks: M2, days: R2 } = CalendarDateUntil(S2, C2, U2, L2), { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(R2, import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(y2)), import_jsbi.default.add(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(I2)), import_jsbi.default.add(import_jsbi.default.BigInt(l2), import_jsbi.default.BigInt(w2)), import_jsbi.default.add(import_jsbi.default.BigInt(d2), import_jsbi.default.BigInt(D2)), import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.BigInt(G2)), import_jsbi.default.add(import_jsbi.default.BigInt(c2), import_jsbi.default.BigInt(v2)), O2);
    } else {
      const e2 = GetIntrinsic("%Temporal.Instant%"), j2 = GetSlot(C2, g), $2 = GetSlot(C2, p), k2 = AddZonedDateTime(GetSlot(C2, S), j2, $2, t2, r2, o2, a2, i2, s2, l2, d2, m2, c2), U2 = AddZonedDateTime(new e2(k2), j2, $2, h2, u2, T2, f2, y2, I2, w2, D2, G2, v2);
      "year" !== O2 && "month" !== O2 && "week" !== O2 && "day" !== O2 ? (b2 = 0, E2 = 0, M2 = 0, R2 = 0, { hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceInstant(GetSlot(C2, n), U2, 1, "nanosecond", O2, "halfExpand")) : { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = DifferenceZonedDateTime(GetSlot(C2, n), U2, j2, $2, O2, Te(null));
    }
  else {
    if ("year" === O2 || "month" === O2 || "week" === O2)
      throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");
    b2 = E2 = M2 = 0, { days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 } = BalanceDuration(a2 + f2, import_jsbi.default.add(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(y2)), import_jsbi.default.add(import_jsbi.default.BigInt(s2), import_jsbi.default.BigInt(I2)), import_jsbi.default.add(import_jsbi.default.BigInt(l2), import_jsbi.default.BigInt(w2)), import_jsbi.default.add(import_jsbi.default.BigInt(d2), import_jsbi.default.BigInt(D2)), import_jsbi.default.add(import_jsbi.default.BigInt(m2), import_jsbi.default.BigInt(G2)), import_jsbi.default.add(import_jsbi.default.BigInt(c2), import_jsbi.default.BigInt(v2)), O2);
  }
  return RejectDuration(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, N2), { years: b2, months: E2, weeks: M2, days: R2, hours: F2, minutes: Y2, seconds: P2, milliseconds: Z2, microseconds: B2, nanoseconds: N2 };
}
function AddInstant(t2, r2, o2, n2, a2, i2, s2) {
  let l2 = Ie;
  l2 = import_jsbi.default.add(l2, import_jsbi.default.BigInt(s2)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(i2), De)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(a2), Ge)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(n2), ve)), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(6e10))), l2 = import_jsbi.default.add(l2, import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), import_jsbi.default.BigInt(36e11)));
  const d2 = import_jsbi.default.add(t2, l2);
  return ValidateEpochNanoseconds(d2), d2;
}
function AddDateTime(e2, t2, r2, o2, n2, a2, d2, m2, c2, h2, u2, T2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  let v2 = f2, { deltaDays: C2, hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 } = AddTime(o2, n2, a2, d2, m2, c2, y2, I2, S2, g2, w2, D2);
  v2 += C2;
  const Y2 = GetIntrinsic("%Temporal.Duration%"), P2 = CalendarDateAdd(h2, CreateTemporalDate(e2, t2, r2, h2), new Y2(u2, T2, p2, v2, 0, 0, 0, 0, 0, 0), G2);
  return { year: GetSlot(P2, i), month: GetSlot(P2, s), day: GetSlot(P2, l), hour: O2, minute: b2, second: E2, millisecond: M2, microsecond: R2, nanosecond: F2 };
}
function AddZonedDateTime(e2, t2, r2, o2, a2, p2, f2, y2, I2, S2, g2, w2, D2, G2) {
  const v2 = GetIntrinsic("%Temporal.Duration%");
  if (0 === DurationSign(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0))
    return AddInstant(GetSlot(e2, n), y2, I2, S2, g2, w2, D2);
  const C2 = GetPlainDateTimeFor(t2, e2, r2), O2 = CalendarDateAdd(r2, CreateTemporalDate(GetSlot(C2, i), GetSlot(C2, s), GetSlot(C2, l), r2), new v2(o2, a2, p2, f2, 0, 0, 0, 0, 0, 0), G2), b2 = CreateTemporalDateTime(GetSlot(O2, i), GetSlot(O2, s), GetSlot(O2, l), GetSlot(C2, d), GetSlot(C2, m), GetSlot(C2, c), GetSlot(C2, h), GetSlot(C2, u), GetSlot(C2, T), r2);
  return AddInstant(GetSlot(GetInstantFor(t2, b2, "compatible"), n), y2, I2, S2, g2, w2, D2);
}
function AddDurationToOrSubtractDurationFromDuration(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1;
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2);
  const p2 = ToRelativeTemporalObject(GetOptionsObject(o2));
  ({ years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = AddDuration(GetSlot(t2, w), GetSlot(t2, D), GetSlot(t2, G), GetSlot(t2, v), GetSlot(t2, C), GetSlot(t2, O), GetSlot(t2, b), GetSlot(t2, E), GetSlot(t2, M), GetSlot(t2, R), n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, p2));
  return new (GetIntrinsic("%Temporal.Duration%"))(a2, i2, s2, l2, d2, m2, c2, h2, u2, T2);
}
function AddDurationToOrSubtractDurationFromInstant(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = function ToLimitedTemporalDuration(e3, t3) {
    let r3 = ToTemporalDurationRecord(e3);
    for (const e4 of t3)
      if (0 !== r3[e4])
        throw new RangeError(`Duration field ${e4} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);
    return r3;
  }(r2, ["years", "months", "weeks", "days"]), c2 = AddInstant(GetSlot(t2, n), o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * d2, o2 * m2);
  return new (GetIntrinsic("%Temporal.Instant%"))(c2);
}
function AddDurationToOrSubtractDurationFromPlainDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: f2, weeks: y2, days: I2, hours: S2, minutes: g2, seconds: w2, milliseconds: D2, microseconds: G2, nanoseconds: v2 } = ToTemporalDurationRecord(r2), C2 = GetOptionsObject(o2), O2 = GetSlot(t2, p), { year: b2, month: E2, day: M2, hour: R2, minute: F2, second: Y2, millisecond: P2, microsecond: Z2, nanosecond: B2 } = AddDateTime(GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), O2, n2 * a2, n2 * f2, n2 * y2, n2 * I2, n2 * S2, n2 * g2, n2 * w2, n2 * D2, n2 * G2, n2 * v2, C2);
  return CreateTemporalDateTime(b2, E2, M2, R2, F2, Y2, P2, Z2, B2, O2);
}
function AddDurationToOrSubtractDurationFromPlainTime(e2, t2, r2) {
  const o2 = "subtract" === e2 ? -1 : 1, { hours: n2, minutes: a2, seconds: i2, milliseconds: s2, microseconds: l2, nanoseconds: p2 } = ToTemporalDurationRecord(r2);
  let { hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = AddTime(GetSlot(t2, d), GetSlot(t2, m), GetSlot(t2, c), GetSlot(t2, h), GetSlot(t2, u), GetSlot(t2, T), o2 * n2, o2 * a2, o2 * i2, o2 * s2, o2 * l2, o2 * p2);
  ({ hour: f2, minute: y2, second: I2, millisecond: S2, microsecond: g2, nanosecond: w2 } = RegulateTime(f2, y2, I2, S2, g2, w2, "reject"));
  return new (GetIntrinsic("%Temporal.PlainTime%"))(f2, y2, I2, S2, g2, w2);
}
function AddDurationToOrSubtractDurationFromPlainYearMonth(e2, t2, r2, o2) {
  let n2 = ToTemporalDurationRecord(r2);
  "subtract" === e2 && (n2 = { years: -n2.years, months: -n2.months, weeks: -n2.weeks, days: -n2.days, hours: -n2.hours, minutes: -n2.minutes, seconds: -n2.seconds, milliseconds: -n2.milliseconds, microseconds: -n2.microseconds, nanoseconds: -n2.nanoseconds });
  let { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = n2;
  ({ days: l2 } = BalanceDuration(l2, d2, m2, c2, h2, u2, T2, "day"));
  const f2 = GetOptionsObject(o2), y2 = GetSlot(t2, p), I2 = CalendarFields(y2, ["monthCode", "year"]), S2 = PrepareTemporalFields(t2, I2, []), g2 = Te(null);
  CopyDataProperties(g2, S2, []), S2.day = 1;
  let w2 = CalendarDateFromFields(y2, S2);
  const D2 = DurationSign(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), G2 = GetMethod(y2, "dateAdd"), v2 = GetIntrinsic("%Temporal.Duration%");
  if (D2 < 0) {
    const e3 = CalendarDateAdd(y2, w2, new v2(0, 1, 0, 0, 0, 0, 0, 0, 0, 0), void 0, G2), t3 = CalendarDateAdd(y2, e3, new v2(0, 0, 0, -1, 0, 0, 0, 0, 0, 0), void 0, G2);
    g2.day = CalendarDay(y2, t3), w2 = CalendarDateFromFields(y2, g2);
  }
  const C2 = new v2(a2, i2, s2, l2, 0, 0, 0, 0, 0, 0), O2 = CopyOptions(f2);
  return CalendarYearMonthFromFields(y2, PrepareTemporalFields(CalendarDateAdd(y2, w2, C2, f2, G2), I2, []), O2);
}
function AddDurationToOrSubtractDurationFromZonedDateTime(e2, t2, r2, o2) {
  const n2 = "subtract" === e2 ? -1 : 1, { years: a2, months: i2, weeks: s2, days: l2, hours: d2, minutes: m2, seconds: c2, milliseconds: h2, microseconds: u2, nanoseconds: T2 } = ToTemporalDurationRecord(r2), f2 = GetOptionsObject(o2), y2 = GetSlot(t2, g), I2 = GetSlot(t2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(t2, S), y2, I2, n2 * a2, n2 * i2, n2 * s2, n2 * l2, n2 * d2, n2 * m2, n2 * c2, n2 * h2, n2 * u2, n2 * T2, f2), y2, I2);
}
function RoundNumberToIncrement(t2, r2, o2) {
  if (import_jsbi.default.equal(r2, Se))
    return t2;
  let { quotient: n2, remainder: a2 } = divmod(t2, r2);
  if (import_jsbi.default.equal(a2, Ie))
    return t2;
  const i2 = import_jsbi.default.lessThan(a2, Ie) ? -1 : 1, s2 = abs(import_jsbi.default.multiply(a2, import_jsbi.default.BigInt(2))), l2 = import_jsbi.default.equal(s2, r2), d2 = import_jsbi.default.greaterThan(s2, r2);
  switch (o2) {
    case "ceil":
      i2 > 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "floor":
      i2 < 0 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "expand":
      n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2));
      break;
    case "trunc":
      break;
    case "halfCeil":
      (d2 || l2 && i2 > 0) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfFloor":
      (d2 || l2 && i2 < 0) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfExpand":
      (d2 || l2) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfTrunc":
      d2 && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
      break;
    case "halfEven":
      (d2 || l2 && 1 === import_jsbi.default.toNumber(import_jsbi.default.remainder(abs(n2), import_jsbi.default.BigInt(2)))) && (n2 = import_jsbi.default.add(n2, import_jsbi.default.BigInt(i2)));
  }
  return import_jsbi.default.multiply(n2, r2);
}
function RoundInstant(t2, r2, o2, n2) {
  let { remainder: a2 } = NonNegativeBigIntDivmod(t2, Ee);
  const i2 = import_jsbi.default.subtract(t2, a2), s2 = RoundNumberToIncrement(a2, import_jsbi.default.BigInt(_e[o2] * r2), n2);
  return import_jsbi.default.add(i2, s2);
}
function RoundISODateTime(e2, t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2 = 864e11) {
  const { deltaDays: u2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 } = RoundTime(o2, n2, a2, i2, s2, l2, d2, m2, c2, h2), { year: g2, month: w2, day: D2 } = BalanceISODate(e2, t2, r2 + u2);
  return { year: g2, month: w2, day: D2, hour: T2, minute: p2, second: f2, millisecond: y2, microsecond: I2, nanosecond: S2 };
}
function RoundTime(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2 = 864e11) {
  let c2 = Ie;
  switch (l2) {
    case "day":
    case "hour":
      c2 = import_jsbi.default.BigInt(t2);
    case "minute":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, ge), import_jsbi.default.BigInt(r2));
    case "second":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, ge), import_jsbi.default.BigInt(o2));
    case "millisecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, De), import_jsbi.default.BigInt(n2));
    case "microsecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, De), import_jsbi.default.BigInt(a2));
    case "nanosecond":
      c2 = import_jsbi.default.add(import_jsbi.default.multiply(c2, De), import_jsbi.default.BigInt(i2));
  }
  const h2 = "day" === l2 ? m2 : _e[l2], u2 = RoundNumberToIncrement(c2, import_jsbi.default.BigInt(h2 * s2), d2), T2 = import_jsbi.default.toNumber(import_jsbi.default.divide(u2, import_jsbi.default.BigInt(h2)));
  switch (l2) {
    case "day":
      return { deltaDays: T2, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };
    case "hour":
      return BalanceTime(T2, 0, 0, 0, 0, 0);
    case "minute":
      return BalanceTime(t2, T2, 0, 0, 0, 0);
    case "second":
      return BalanceTime(t2, r2, T2, 0, 0, 0);
    case "millisecond":
      return BalanceTime(t2, r2, o2, T2, 0, 0);
    case "microsecond":
      return BalanceTime(t2, r2, o2, n2, T2, 0);
    case "nanosecond":
      return BalanceTime(t2, r2, o2, n2, a2, T2);
    default:
      throw new Error(`Invalid unit ${l2}`);
  }
}
function DaysUntil(e2, t2) {
  return DifferenceISODate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), "day").days;
}
function MoveRelativeDate(e2, t2, r2, o2) {
  const n2 = CalendarDateAdd(e2, t2, r2, void 0, o2);
  return { relativeTo: n2, days: DaysUntil(t2, n2) };
}
function MoveRelativeZonedDateTime(e2, t2, r2, o2, n2) {
  const a2 = GetSlot(e2, g), i2 = GetSlot(e2, p);
  return CreateTemporalZonedDateTime(AddZonedDateTime(GetSlot(e2, S), a2, i2, t2, r2, o2, n2, 0, 0, 0, 0, 0, 0), a2, i2);
}
function AdjustRoundedDurationDays(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, w2 = n2, D2 = a2, G2 = i2, v2 = s2, C2 = l2, O2 = d2, b2 = m2;
  if (!IsTemporalZonedDateTime(T2) || "year" === h2 || "month" === h2 || "week" === h2 || "day" === h2 || "nanosecond" === h2 && 1 === c2)
    return { years: f2, months: y2, weeks: I2, days: w2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
  let E2 = TotalDurationNanoseconds(0, D2, G2, v2, C2, O2, b2, 0);
  const M2 = se(import_jsbi.default.toNumber(E2)), R2 = GetSlot(T2, g), F2 = GetSlot(T2, p), Y2 = AddZonedDateTime(GetSlot(T2, S), R2, F2, f2, y2, I2, w2, 0, 0, 0, 0, 0, 0), P2 = AddZonedDateTime(new (GetIntrinsic("%Temporal.Instant%"))(Y2), R2, F2, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0), Z2 = import_jsbi.default.subtract(P2, Y2);
  return import_jsbi.default.greaterThanOrEqual(import_jsbi.default.multiply(import_jsbi.default.subtract(E2, Z2), import_jsbi.default.BigInt(M2)), Ie) && ({ years: f2, months: y2, weeks: I2, days: w2 } = AddDuration(f2, y2, I2, w2, 0, 0, 0, 0, 0, 0, 0, 0, 0, M2, 0, 0, 0, 0, 0, 0, T2), E2 = RoundInstant(import_jsbi.default.subtract(E2, Z2), c2, h2, u2), { hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 } = BalanceDuration(0, 0, 0, 0, 0, 0, import_jsbi.default.toNumber(E2), "hour")), { years: f2, months: y2, weeks: I2, days: w2, hours: D2, minutes: G2, seconds: v2, milliseconds: C2, microseconds: O2, nanoseconds: b2 };
}
function RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, h2, u2, T2) {
  let f2 = t2, y2 = r2, I2 = o2, S2 = n2, g2 = a2, w2 = i2, D2 = s2, G2 = l2, v2 = d2, C2 = import_jsbi.default.BigInt(m2);
  const O2 = GetIntrinsic("%Temporal.Duration%");
  let b2, E2, M2, R2, F2 = T2;
  if (F2) {
    if (IsTemporalZonedDateTime(F2))
      E2 = F2, F2 = ToTemporalDate(F2);
    else if (!IsTemporalDate(F2))
      throw new TypeError("starting point must be PlainDate or ZonedDateTime");
    b2 = GetSlot(F2, p);
  }
  if ("year" === h2 || "month" === h2 || "week" === h2 || "day" === h2) {
    let t3, r3, o3;
    C2 = TotalDurationNanoseconds(0, g2, w2, D2, G2, v2, m2, 0), E2 && (t3 = MoveRelativeZonedDateTime(E2, f2, y2, I2, S2)), { days: r3, nanoseconds: C2, dayLengthNs: o3 } = NanosecondsToDays(C2, t3), M2 = import_jsbi.default.BigInt(o3), S2 += r3, g2 = w2 = D2 = G2 = v2 = 0;
  }
  switch (h2) {
    case "year": {
      if (!b2)
        throw new RangeError("A starting point is required for years rounding");
      const t3 = new O2(f2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = CalendarDateAdd(b2, F2, new O2(0, 0, 0, S2), void 0, r3), i3 = Te(null);
      i3.largestUnit = "year";
      const s3 = CalendarDateUntil(b2, F2, a3, i3).years;
      f2 += s3;
      const l3 = F2;
      F2 = CalendarDateAdd(b2, F2, new O2(s3), void 0, r3);
      S2 -= DaysUntil(l3, F2);
      const d3 = new O2(S2 < 0 ? -1 : 1);
      let { days: m3 } = MoveRelativeDate(b2, F2, d3, r3);
      m3 = ae(m3);
      const h3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(m3), M2);
      C2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(f2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(S2), M2)), C2);
      const T3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(h3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, h3), f2 = import_jsbi.default.toNumber(import_jsbi.default.divide(T3, h3)), C2 = Ie, y2 = I2 = S2 = 0;
      break;
    }
    case "month": {
      if (!b2)
        throw new RangeError("A starting point is required for months rounding");
      const t3 = new O2(f2, y2), r3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0, o3 = CalendarDateAdd(b2, F2, t3, void 0, r3), n3 = CalendarDateAdd(b2, F2, new O2(f2, y2, I2), void 0, r3);
      F2 = o3, S2 += DaysUntil(o3, n3);
      const a3 = se(S2), i3 = new O2(0, S2 < 0 ? -1 : 1);
      let s3;
      for ({ relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3); ae(S2) >= ae(s3); )
        y2 += a3, S2 -= s3, { relativeTo: F2, days: s3 } = MoveRelativeDate(b2, F2, i3, r3);
      s3 = ae(s3);
      const l3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(s3), M2);
      C2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(y2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(S2), M2)), C2);
      const d3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(l3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, l3), y2 = import_jsbi.default.toNumber(import_jsbi.default.divide(d3, l3)), C2 = Ie, I2 = S2 = 0;
      break;
    }
    case "week": {
      if (!b2)
        throw new RangeError("A starting point is required for weeks rounding");
      const t3 = se(S2), r3 = new O2(0, 0, S2 < 0 ? -1 : 1), o3 = "string" != typeof b2 ? GetMethod(b2, "dateAdd") : void 0;
      let n3;
      for ({ relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3); ae(S2) >= ae(n3); )
        I2 += t3, S2 -= n3, { relativeTo: F2, days: n3 } = MoveRelativeDate(b2, F2, r3, o3);
      n3 = ae(n3);
      const a3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(n3), M2);
      C2 = import_jsbi.default.add(import_jsbi.default.add(import_jsbi.default.multiply(a3, import_jsbi.default.BigInt(I2)), import_jsbi.default.multiply(import_jsbi.default.BigInt(S2), M2)), C2);
      const i3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(a3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, a3), I2 = import_jsbi.default.toNumber(import_jsbi.default.divide(i3, a3)), C2 = Ie, S2 = 0;
      break;
    }
    case "day": {
      const t3 = M2;
      C2 = import_jsbi.default.add(import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(S2)), C2);
      const r3 = RoundNumberToIncrement(C2, import_jsbi.default.multiply(t3, import_jsbi.default.BigInt(c2)), u2);
      R2 = BigIntDivideToNumber(C2, t3), S2 = import_jsbi.default.toNumber(import_jsbi.default.divide(r3, t3)), C2 = Ie;
      break;
    }
    case "hour": {
      const t3 = 36e11;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(g2), import_jsbi.default.BigInt(36e11));
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), import_jsbi.default.BigInt(6e10))), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ve)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      g2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, w2 = D2 = G2 = v2 = 0;
      break;
    }
    case "minute": {
      const t3 = 6e10;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(w2), import_jsbi.default.BigInt(6e10));
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ve)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      w2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, D2 = G2 = v2 = 0;
      break;
    }
    case "second": {
      const t3 = 1e9;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(D2), ve);
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge)), r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      D2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, G2 = v2 = 0;
      break;
    }
    case "millisecond": {
      const t3 = 1e6;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(G2), Ge);
      r3 = import_jsbi.default.add(r3, import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De)), r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      G2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie, v2 = 0;
      break;
    }
    case "microsecond": {
      const t3 = 1e3;
      let r3 = import_jsbi.default.multiply(import_jsbi.default.BigInt(v2), De);
      r3 = import_jsbi.default.add(r3, C2), R2 = BigIntDivideToNumber(r3, import_jsbi.default.BigInt(t3));
      const o3 = RoundNumberToIncrement(r3, import_jsbi.default.BigInt(t3 * c2), u2);
      v2 = import_jsbi.default.toNumber(import_jsbi.default.divide(o3, import_jsbi.default.BigInt(t3))), C2 = Ie;
      break;
    }
    case "nanosecond":
      R2 = import_jsbi.default.toNumber(C2), C2 = RoundNumberToIncrement(import_jsbi.default.BigInt(C2), import_jsbi.default.BigInt(c2), u2);
  }
  return { years: f2, months: y2, weeks: I2, days: S2, hours: g2, minutes: w2, seconds: D2, milliseconds: G2, microseconds: v2, nanoseconds: import_jsbi.default.toNumber(C2), total: R2 };
}
function CompareISODate(e2, t2, r2, o2, n2, a2) {
  for (const [i2, s2] of [[e2, o2], [t2, n2], [r2, a2]])
    if (i2 !== s2)
      return ComparisonResult(i2 - s2);
  return 0;
}
function NonNegativeBigIntDivmod(t2, r2) {
  let { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return import_jsbi.default.lessThan(n2, Ie) && (o2 = import_jsbi.default.subtract(o2, Se), n2 = import_jsbi.default.add(n2, r2)), { quotient: o2, remainder: n2 };
}
function BigIntFloorDiv(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return isZero(n2) || !isNegativeJSBI(t2) == !isNegativeJSBI(r2) ? o2 : import_jsbi.default.subtract(o2, Se);
}
function BigIntDivideToNumber(t2, r2) {
  const { quotient: o2, remainder: n2 } = divmod(t2, r2);
  return import_jsbi.default.toNumber(o2) + import_jsbi.default.toNumber(n2) / import_jsbi.default.toNumber(r2);
}
function ToBigIntExternal(e2) {
  const t2 = ToBigInt(e2);
  return void 0 !== globalThis.BigInt ? globalThis.BigInt(t2.toString(10)) : t2;
}
function ToBigInt(t2) {
  let r2 = t2;
  if ("object" == typeof t2) {
    const e2 = t2[Symbol.toPrimitive];
    e2 && "function" == typeof e2 && (r2 = fe(e2, t2, ["number"]));
  }
  if ("number" == typeof r2)
    throw new TypeError("cannot convert number to bigint");
  return "bigint" == typeof r2 ? import_jsbi.default.BigInt(r2.toString(10)) : import_jsbi.default.BigInt(r2);
}
var Ve = (() => {
  let t2 = import_jsbi.default.BigInt(Date.now() % 1e6);
  return () => {
    const r2 = import_jsbi.default.BigInt(Date.now()), o2 = import_jsbi.default.add(import_jsbi.default.multiply(r2, Ge), t2);
    return t2 = import_jsbi.default.remainder(r2, Ge), import_jsbi.default.greaterThan(o2, Re) ? Re : import_jsbi.default.lessThan(o2, Me) ? Me : o2;
  };
})();
function DefaultTimeZone() {
  return new re().resolvedOptions().timeZone;
}
function ComparisonResult(e2) {
  return e2 < 0 ? -1 : e2 > 0 ? 1 : e2;
}
function GetOptionsObject(e2) {
  if (void 0 === e2)
    return Te(null);
  if (IsObject(e2) && null !== e2)
    return e2;
  throw new TypeError("Options parameter must be an object, not " + (null === e2 ? "null" : typeof e2));
}
function CreateOnePropObject(e2, t2) {
  const r2 = Te(null);
  return r2[e2] = t2, r2;
}
function CopyOptions(e2) {
  const t2 = Te(null);
  return CopyDataProperties(t2, GetOptionsObject(e2), []), t2;
}
function GetOption(e2, t2, r2, o2) {
  let n2 = e2[t2];
  if (void 0 !== n2) {
    if (n2 = ToString(n2), !r2.includes(n2))
      throw new RangeError(`${t2} must be one of ${r2.join(", ")}, not ${n2}`);
    return n2;
  }
  return o2;
}
function IsBuiltinCalendar(e2) {
  return je.includes(ASCIILowercase(e2));
}
function ASCIILowercase(e2) {
  return e2.replace(/[A-Z]/g, (e3) => {
    const t2 = e3.charCodeAt(0);
    return String.fromCharCode(t2 + 32);
  });
}
var ze = new RegExp(`^${W.source}$`);
function bisect(t2, r2, o2, n2 = t2(r2), a2 = t2(o2)) {
  let i2 = import_jsbi.default.BigInt(r2), s2 = import_jsbi.default.BigInt(o2), l2 = n2, d2 = a2;
  for (; import_jsbi.default.greaterThan(import_jsbi.default.subtract(s2, i2), Se); ) {
    const r3 = import_jsbi.default.divide(import_jsbi.default.add(i2, s2), import_jsbi.default.BigInt(2)), o3 = t2(r3);
    if (o3 === l2)
      i2 = r3, l2 = o3;
    else {
      if (o3 !== d2)
        throw new Error(`invalid state in bisection ${l2} - ${o3} - ${d2}`);
      s2 = r3, d2 = o3;
    }
  }
  return s2;
}
var _e = { hour: 36e11, minute: 6e10, second: 1e9, millisecond: 1e6, microsecond: 1e3, nanosecond: 1 };
var Je = Symbol("date");
var Ke = Symbol("ym");
var Xe = Symbol("md");
var Qe = Symbol("time");
var et = Symbol("datetime");
var tt = Symbol("instant");
var rt = Symbol("original");
var ot = Symbol("timezone");
var nt = Symbol("calendar-id");
var at = Symbol("locale");
var it = Symbol("options");
var descriptor = (e2) => ({ value: e2, enumerable: true, writable: false, configurable: true });
var st = globalThis.Intl.DateTimeFormat;
var lt = Object.assign;
var dt = Object.prototype.hasOwnProperty;
var mt = Reflect.apply;
function getPropLazy(e2, t2) {
  let r2 = e2[t2];
  return "function" == typeof r2 && (r2 = new st(e2[at], r2(e2[it])), e2[t2] = r2), r2;
}
function DateTimeFormatImpl(e2, t2 = {}) {
  if (!(this instanceof DateTimeFormatImpl))
    return new DateTimeFormatImpl(e2, t2);
  const r2 = void 0 !== t2, o2 = r2 ? lt({}, t2) : {}, n2 = new st(e2, o2), a2 = n2.resolvedOptions();
  if (r2) {
    const e3 = lt({}, a2);
    for (const t3 in e3)
      mt(dt, o2, [t3]) || delete e3[t3];
    this[it] = e3;
  } else
    this[it] = o2;
  this[at] = a2.locale, this[rt] = n2, this[ot] = a2.timeZone, this[nt] = a2.calendar, this[Je] = dateAmend, this[Ke] = yearMonthAmend, this[Xe] = monthDayAmend, this[Qe] = timeAmend, this[et] = datetimeAmend, this[tt] = instantAmend;
}
Object.defineProperty(DateTimeFormatImpl, "name", { writable: true, value: "DateTimeFormat" }), DateTimeFormatImpl.supportedLocalesOf = function(e2, t2) {
  return st.supportedLocalesOf(e2, t2);
};
var ct = { resolvedOptions: descriptor(function resolvedOptions() {
  return this[rt].resolvedOptions();
}), format: descriptor(function format(e2, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e2, this);
  if (r2 && o2)
    return o2.format(r2.epochMilliseconds);
  return this[rt].format(e2, ...t2);
}), formatRange: descriptor(function formatRange(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2))
      throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e2, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2)
      return o2.formatRange(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRange(e2, t2);
}) };
"formatToParts" in st.prototype && (ct.formatToParts = descriptor(function formatToParts(e2, ...t2) {
  let { instant: r2, formatter: o2 } = extractOverrides(e2, this);
  if (r2 && o2)
    return o2.formatToParts(r2.epochMilliseconds);
  return this[rt].formatToParts(e2, ...t2);
})), "formatRangeToParts" in st.prototype && (ct.formatRangeToParts = descriptor(function formatRangeToParts(e2, t2) {
  if (isTemporalObject(e2) || isTemporalObject(t2)) {
    if (!sameTemporalType(e2, t2))
      throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");
    const { instant: r2, formatter: o2 } = extractOverrides(e2, this), { instant: n2, formatter: a2 } = extractOverrides(t2, this);
    if (r2 && n2 && o2 && a2 && o2 === a2)
      return o2.formatRangeToParts(r2.epochMilliseconds, n2.epochMilliseconds);
  }
  return this[rt].formatRangeToParts(e2, t2);
})), DateTimeFormatImpl.prototype = Object.create(st.prototype, ct), Object.defineProperty(DateTimeFormatImpl, "prototype", { writable: false, enumerable: false, configurable: false });
var ht = DateTimeFormatImpl;
function amend(e2 = {}, t2 = {}) {
  const r2 = lt({}, e2);
  for (const e3 of ["year", "month", "day", "hour", "minute", "second", "weekday", "dayPeriod", "timeZoneName", "dateStyle", "timeStyle"])
    r2[e3] = e3 in t2 ? t2[e3] : r2[e3], false !== r2[e3] && void 0 !== r2[e3] || delete r2[e3];
  return r2;
}
function timeAmend(e2) {
  let t2 = amend(e2, { year: false, month: false, day: false, weekday: false, timeZoneName: false, dateStyle: false });
  return hasTimeOptions(t2) || (t2 = lt({}, t2, { hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function yearMonthAmend(e2) {
  let t2 = amend(e2, { day: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "year" in t2 || "month" in t2 || (t2 = lt(t2, { year: "numeric", month: "numeric" })), t2;
}
function monthDayAmend(e2) {
  let t2 = amend(e2, { year: false, hour: false, minute: false, second: false, weekday: false, dayPeriod: false, timeZoneName: false, dateStyle: false, timeStyle: false });
  return "month" in t2 || "day" in t2 || (t2 = lt({}, t2, { month: "numeric", day: "numeric" })), t2;
}
function dateAmend(e2) {
  let t2 = amend(e2, { hour: false, minute: false, second: false, dayPeriod: false, timeZoneName: false, timeStyle: false });
  return hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric" })), t2;
}
function datetimeAmend(e2) {
  let t2 = amend(e2, { timeZoneName: false });
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function instantAmend(e2) {
  let t2 = e2;
  return hasTimeOptions(t2) || hasDateOptions(t2) || (t2 = lt({}, t2, { year: "numeric", month: "numeric", day: "numeric", hour: "numeric", minute: "numeric", second: "numeric" })), t2;
}
function hasDateOptions(e2) {
  return "year" in e2 || "month" in e2 || "day" in e2 || "weekday" in e2 || "dateStyle" in e2;
}
function hasTimeOptions(e2) {
  return "hour" in e2 || "minute" in e2 || "second" in e2 || "timeStyle" in e2 || "dayPeriod" in e2;
}
function isTemporalObject(e2) {
  return IsTemporalDate(e2) || IsTemporalTime(e2) || IsTemporalDateTime(e2) || IsTemporalZonedDateTime(e2) || IsTemporalYearMonth(e2) || IsTemporalMonthDay(e2) || IsTemporalInstant(e2);
}
function sameTemporalType(e2, t2) {
  return !(!isTemporalObject(e2) || !isTemporalObject(t2)) && (!(IsTemporalTime(e2) && !IsTemporalTime(t2)) && (!(IsTemporalDate(e2) && !IsTemporalDate(t2)) && (!(IsTemporalDateTime(e2) && !IsTemporalDateTime(t2)) && (!(IsTemporalZonedDateTime(e2) && !IsTemporalZonedDateTime(t2)) && (!(IsTemporalYearMonth(e2) && !IsTemporalYearMonth(t2)) && (!(IsTemporalMonthDay(e2) && !IsTemporalMonthDay(t2)) && !(IsTemporalInstant(e2) && !IsTemporalInstant(t2))))))));
}
function extractOverrides(e2, t2) {
  const r2 = GetIntrinsic("%Temporal.PlainDateTime%");
  if (IsTemporalTime(e2)) {
    const o2 = new r2(1970, 1, 1, GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T), t2[nt]);
    return { instant: GetInstantFor(t2[ot], o2, "compatible"), formatter: getPropLazy(t2, Qe) };
  }
  if (IsTemporalYearMonth(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if (d2 !== t2[nt])
      throw new RangeError(`cannot format PlainYearMonth with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Ke) };
  }
  if (IsTemporalMonthDay(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if (d2 !== t2[nt])
      throw new RangeError(`cannot format PlainMonthDay with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, d2);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Xe) };
  }
  if (IsTemporalDate(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), d2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if ("iso8601" !== d2 && d2 !== t2[nt])
      throw new RangeError(`cannot format PlainDate with calendar ${d2} in locale with calendar ${t2[nt]}`);
    const m2 = new r2(o2, n2, a2, 12, 0, 0, 0, 0, 0, t2[nt]);
    return { instant: GetInstantFor(t2[ot], m2, "compatible"), formatter: getPropLazy(t2, Je) };
  }
  if (IsTemporalDateTime(e2)) {
    const o2 = GetSlot(e2, i), n2 = GetSlot(e2, s), a2 = GetSlot(e2, l), f2 = GetSlot(e2, d), y2 = GetSlot(e2, m), I2 = GetSlot(e2, c), S2 = GetSlot(e2, h), g2 = GetSlot(e2, u), w2 = GetSlot(e2, T), D2 = ToTemporalCalendarIdentifier(GetSlot(e2, p));
    if ("iso8601" !== D2 && D2 !== t2[nt])
      throw new RangeError(`cannot format PlainDateTime with calendar ${D2} in locale with calendar ${t2[nt]}`);
    let G2 = e2;
    return "iso8601" === D2 && (G2 = new r2(o2, n2, a2, f2, y2, I2, S2, g2, w2, t2[nt])), { instant: GetInstantFor(t2[ot], G2, "compatible"), formatter: getPropLazy(t2, et) };
  }
  if (IsTemporalZonedDateTime(e2))
    throw new TypeError("Temporal.ZonedDateTime not supported in DateTimeFormat methods. Use toLocaleString() instead.");
  return IsTemporalInstant(e2) ? { instant: e2, formatter: getPropLazy(t2, tt) } : {};
}
var ut = Object.freeze({ __proto__: null, DateTimeFormat: ht });
var Instant = class _Instant {
  constructor(e2) {
    if (arguments.length < 1)
      throw new TypeError("missing argument: epochNanoseconds is required");
    const t2 = ToBigInt(e2);
    ValidateEpochNanoseconds(t2), N(this), SetSlot(this, n, t2);
  }
  get epochSeconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = import_jsbi.default.BigInt(GetSlot(this, n));
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(import_jsbi.default.BigInt(GetSlot(this, n)), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(import_jsbi.default.BigInt(GetSlot(this, n)));
  }
  add(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromInstant("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalInstant("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, { hour: 24, minute: 1440, second: 86400, millisecond: 864e5, microsecond: 864e8, nanosecond: 864e11 }[a2], true);
    const i2 = RoundInstant(GetSlot(this, n), r2, a2, o2);
    return new _Instant(i2);
  }
  equals(t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalInstant(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return import_jsbi.default.equal(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(a2));
  }
  toString(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    let i2 = t2.timeZone;
    void 0 !== i2 && (i2 = ToTemporalTimeZoneSlotValue(i2));
    const { precision: s2, unit: l2, increment: d2 } = ToSecondsStringPrecisionRecord(a2, r2), m2 = RoundInstant(GetSlot(this, n), d2, l2, o2);
    return TemporalInstantToString(new _Instant(m2), i2, s2);
  }
  toJSON() {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return TemporalInstantToString(this, void 0, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.Instant");
  }
  toZonedDateTime(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument in toZonedDateTime");
    const t2 = e2.calendar;
    if (void 0 === t2)
      throw new TypeError("missing calendar property in toZonedDateTime");
    const r2 = ToTemporalCalendarSlotValue(t2), o2 = e2.timeZone;
    if (void 0 === o2)
      throw new TypeError("missing timeZone property in toZonedDateTime");
    const a2 = ToTemporalTimeZoneSlotValue(o2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), a2, r2);
  }
  toZonedDateTimeISO(e2) {
    if (!IsTemporalInstant(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, "iso8601");
  }
  static fromEpochSeconds(t2) {
    const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), ve);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMilliseconds(t2) {
    const r2 = ToNumber(t2), o2 = import_jsbi.default.multiply(import_jsbi.default.BigInt(r2), Ge);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochMicroseconds(t2) {
    const r2 = ToBigInt(t2), o2 = import_jsbi.default.multiply(r2, De);
    return ValidateEpochNanoseconds(o2), new _Instant(o2);
  }
  static fromEpochNanoseconds(e2) {
    const t2 = ToBigInt(e2);
    return ValidateEpochNanoseconds(t2), new _Instant(t2);
  }
  static from(e2) {
    return IsTemporalInstant(e2) ? new _Instant(GetSlot(e2, n)) : ToTemporalInstant(e2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalInstant(t2), a2 = ToTemporalInstant(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return import_jsbi.default.lessThan(i2, s2) ? -1 : import_jsbi.default.greaterThan(i2, s2) ? 1 : 0;
  }
};
MakeIntrinsicClass(Instant, "Temporal.Instant");
var Tt = Array.prototype.includes;
var pt = Array.prototype.push;
var ft = globalThis.Intl.DateTimeFormat;
var yt = Array.prototype.sort;
var It = Math.abs;
var St = Math.floor;
var gt = Object.create;
var wt = Object.entries;
var Dt = Set;
var Gt = Reflect.ownKeys;
var vt = Set.prototype.add;
var Ct = Set.prototype.values;
var Ot = {};
var Calendar = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new RangeError("missing argument: id is required");
    const t2 = ToString(e2);
    if (!IsBuiltinCalendar(t2))
      throw new RangeError(`invalid calendar identifier ${t2}`);
    N(this), SetSlot(this, F, ASCIILowercase(t2));
  }
  get id() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  dateFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].dateFromFields(e2, r2, o2);
  }
  yearMonthFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].yearMonthFromFields(e2, r2, o2);
  }
  monthDayFromFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid fields");
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, F);
    return Ot[o2].monthDayFromFields(e2, r2, o2);
  }
  fields(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = [], r2 = /* @__PURE__ */ new Set(["year", "month", "monthCode", "day", "hour", "minute", "second", "millisecond", "microsecond", "nanosecond"]);
    for (const o2 of e2) {
      if ("string" != typeof o2)
        throw new TypeError("invalid fields");
      if (!r2.has(o2))
        throw new RangeError(`invalid field name ${o2}`);
      r2.delete(o2), pt.call(t2, o2);
    }
    return Ot[GetSlot(this, F)].fields(t2);
  }
  mergeFields(e2, t2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const r2 = ToObject(e2), o2 = gt(null);
    CopyDataProperties(o2, r2, [], [void 0]);
    const n2 = ToObject(t2), a2 = gt(null);
    CopyDataProperties(a2, n2, [], [void 0]);
    const i2 = Gt(a2), s2 = Ot[GetSlot(this, F)].fieldKeysToIgnore(i2), l2 = gt(null), d2 = Gt(o2);
    for (const e3 of d2) {
      let t3;
      t3 = Call(Tt, s2, [e3]) ? a2[e3] : o2[e3], void 0 !== t3 && (l2[e3] = t3);
    }
    return CopyDataProperties(l2, a2, []), l2;
  }
  dateAdd(e2, t2, r2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDuration(t2), a2 = ToTemporalOverflow(GetOptionsObject(r2)), { days: i2 } = BalanceDuration(GetSlot(n2, v), GetSlot(n2, C), GetSlot(n2, O), GetSlot(n2, b), GetSlot(n2, E), GetSlot(n2, M), GetSlot(n2, R), "day"), s2 = GetSlot(this, F);
    return Ot[s2].dateAdd(o2, GetSlot(n2, w), GetSlot(n2, D), GetSlot(n2, G), i2, a2, s2);
  }
  dateUntil(e2, t2, r2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const o2 = ToTemporalDate(e2), n2 = ToTemporalDate(t2);
    let a2 = GetTemporalUnit(GetOptionsObject(r2), "largestUnit", "date", "auto");
    "auto" === a2 && (a2 = "day");
    const { years: i2, months: s2, weeks: l2, days: d2 } = Ot[GetSlot(this, F)].dateUntil(o2, n2, a2);
    return new (GetIntrinsic("%Temporal.Duration%"))(i2, s2, l2, d2, 0, 0, 0, 0, 0, 0);
  }
  year(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].year(t2);
  }
  month(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    if (IsTemporalMonthDay(t2))
      throw new TypeError("use monthCode on PlainMonthDay instead");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].month(t2);
  }
  monthCode(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthCode(t2);
  }
  day(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalMonthDay(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].day(t2);
  }
  era(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].era(t2);
  }
  eraYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].eraYear(t2);
  }
  dayOfWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].dayOfWeek(t2);
  }
  dayOfYear(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].dayOfYear(t2);
  }
  weekOfYear(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].weekOfYear(t2);
  }
  yearOfWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].yearOfWeek(t2);
  }
  daysInWeek(e2) {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    return Ot[GetSlot(this, F)].daysInWeek(t2);
  }
  daysInMonth(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInMonth(t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].daysInYear(t2);
  }
  monthsInYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].monthsInYear(t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return IsTemporalYearMonth(t2) || (t2 = ToTemporalDate(t2)), Ot[GetSlot(this, F)].inLeapYear(t2);
  }
  toString() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  toJSON() {
    if (!IsTemporalCalendar(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, F);
  }
  static from(e2) {
    return ToTemporalCalendarObject(ToTemporalCalendarSlotValue(e2));
  }
};
function monthCodeNumberPart(e2) {
  if (!e2.startsWith("M"))
    throw new RangeError(`Invalid month code: ${e2}.  Month codes must start with M.`);
  const t2 = +e2.slice(1);
  if (isNaN(t2))
    throw new RangeError(`Invalid month code: ${e2}`);
  return t2;
}
function buildMonthCode(e2, t2 = false) {
  return `M${e2.toString().padStart(2, "0")}${t2 ? "L" : ""}`;
}
function resolveNonLunisolarMonth(e2, t2, r2 = 12) {
  let { month: o2, monthCode: n2 } = e2;
  if (void 0 === n2) {
    if (void 0 === o2)
      throw new TypeError("Either month or monthCode are required");
    "reject" === t2 && RejectToRange(o2, 1, r2), "constrain" === t2 && (o2 = ConstrainToRange(o2, 1, r2)), n2 = buildMonthCode(o2);
  } else {
    const e3 = monthCodeNumberPart(n2);
    if (void 0 !== o2 && o2 !== e3)
      throw new RangeError(`monthCode ${n2} and month ${o2} must match if both are present`);
    if (n2 !== buildMonthCode(e3))
      throw new RangeError(`Invalid month code: ${n2}`);
    if (o2 = e3, o2 < 1 || o2 > r2)
      throw new RangeError(`Invalid monthCode: ${n2}`);
  }
  return { ...e2, month: o2, monthCode: n2 };
}
MakeIntrinsicClass(Calendar, "Temporal.Calendar"), DefineIntrinsic("Temporal.Calendar.from", Calendar.from), DefineIntrinsic("Temporal.Calendar.prototype.dateAdd", Calendar.prototype.dateAdd), DefineIntrinsic("Temporal.Calendar.prototype.dateFromFields", Calendar.prototype.dateFromFields), DefineIntrinsic("Temporal.Calendar.prototype.dateUntil", Calendar.prototype.dateUntil), DefineIntrinsic("Temporal.Calendar.prototype.day", Calendar.prototype.day), DefineIntrinsic("Temporal.Calendar.prototype.dayOfWeek", Calendar.prototype.dayOfWeek), DefineIntrinsic("Temporal.Calendar.prototype.dayOfYear", Calendar.prototype.dayOfYear), DefineIntrinsic("Temporal.Calendar.prototype.daysInMonth", Calendar.prototype.daysInMonth), DefineIntrinsic("Temporal.Calendar.prototype.daysInWeek", Calendar.prototype.daysInWeek), DefineIntrinsic("Temporal.Calendar.prototype.daysInYear", Calendar.prototype.daysInYear), DefineIntrinsic("Temporal.Calendar.prototype.era", Calendar.prototype.era), DefineIntrinsic("Temporal.Calendar.prototype.eraYear", Calendar.prototype.eraYear), DefineIntrinsic("Temporal.Calendar.prototype.fields", Calendar.prototype.fields), DefineIntrinsic("Temporal.Calendar.prototype.inLeapYear", Calendar.prototype.inLeapYear), DefineIntrinsic("Temporal.Calendar.prototype.mergeFields", Calendar.prototype.mergeFields), DefineIntrinsic("Temporal.Calendar.prototype.month", Calendar.prototype.month), DefineIntrinsic("Temporal.Calendar.prototype.monthCode", Calendar.prototype.monthCode), DefineIntrinsic("Temporal.Calendar.prototype.monthDayFromFields", Calendar.prototype.monthDayFromFields), DefineIntrinsic("Temporal.Calendar.prototype.monthsInYear", Calendar.prototype.monthsInYear), DefineIntrinsic("Temporal.Calendar.prototype.weekOfYear", Calendar.prototype.weekOfYear), DefineIntrinsic("Temporal.Calendar.prototype.year", Calendar.prototype.year), DefineIntrinsic("Temporal.Calendar.prototype.yearMonthFromFields", Calendar.prototype.yearMonthFromFields), DefineIntrinsic("Temporal.Calendar.prototype.yearOfWeek", Calendar.prototype.yearOfWeek), Ot.iso8601 = { dateFromFields(e2, t2, r2) {
  let o2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["year", "day"]);
  const n2 = ToTemporalOverflow(t2);
  o2 = resolveNonLunisolarMonth(o2);
  let { year: a2, month: i2, day: s2 } = o2;
  return { year: a2, month: i2, day: s2 } = RegulateISODate(a2, i2, s2, n2), CreateTemporalDate(a2, i2, s2, r2);
}, yearMonthFromFields(e2, t2, r2) {
  let o2 = PrepareTemporalFields(e2, ["month", "monthCode", "year"], ["year"]);
  const n2 = ToTemporalOverflow(t2);
  o2 = resolveNonLunisolarMonth(o2);
  let { year: a2, month: i2 } = o2;
  return { year: a2, month: i2 } = function RegulateISOYearMonth(e3, t3, r3) {
    let o3 = e3, n3 = t3;
    switch (r3) {
      case "reject":
        RejectISODate(o3, n3, 1);
        break;
      case "constrain":
        ({ year: o3, month: n3 } = ConstrainISODate(o3, n3));
    }
    return { year: o3, month: n3 };
  }(a2, i2, n2), CreateTemporalYearMonth(a2, i2, r2, 1);
}, monthDayFromFields(e2, t2, r2) {
  let o2 = PrepareTemporalFields(e2, ["day", "month", "monthCode", "year"], ["day"]);
  const n2 = ToTemporalOverflow(t2);
  if (void 0 !== o2.month && void 0 === o2.year && void 0 === o2.monthCode)
    throw new TypeError("either year or monthCode required with month");
  const a2 = void 0 === o2.monthCode;
  o2 = resolveNonLunisolarMonth(o2);
  let { month: i2, day: s2, year: l2 } = o2;
  return { month: i2, day: s2 } = RegulateISODate(a2 ? l2 : 1972, i2, s2, n2), CreateTemporalMonthDay(i2, s2, r2, 1972);
}, fields: (e2) => e2, fieldKeysToIgnore(e2) {
  const t2 = new Dt();
  for (let r2 = 0; r2 < e2.length; r2++) {
    const o2 = e2[r2];
    Call(vt, t2, [o2]), "month" === o2 ? Call(vt, t2, ["monthCode"]) : "monthCode" === o2 && Call(vt, t2, ["month"]);
  }
  return [...Call(Ct, t2, [])];
}, dateAdd(e2, t2, r2, o2, n2, a2, d2) {
  let m2 = GetSlot(e2, i), c2 = GetSlot(e2, s), h2 = GetSlot(e2, l);
  return { year: m2, month: c2, day: h2 } = AddISODate(m2, c2, h2, t2, r2, o2, n2, a2), CreateTemporalDate(m2, c2, h2, d2);
}, dateUntil: (e2, t2, r2) => DifferenceISODate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(t2, i), GetSlot(t2, s), GetSlot(t2, l), r2), year: (e2) => GetSlot(e2, i), era() {
}, eraYear() {
}, month: (e2) => GetSlot(e2, s), monthCode: (e2) => buildMonthCode(GetSlot(e2, s)), day: (e2) => GetSlot(e2, l), dayOfWeek: (e2) => DayOfWeek(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)), dayOfYear: (e2) => DayOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)), weekOfYear: (e2) => WeekOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)).week, yearOfWeek: (e2) => WeekOfYear(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l)).year, daysInWeek: () => 7, daysInMonth: (e2) => ISODaysInMonth(GetSlot(e2, i), GetSlot(e2, s)), daysInYear(e2) {
  let t2 = e2;
  return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i)) ? 366 : 365;
}, monthsInYear: () => 12, inLeapYear(e2) {
  let t2 = e2;
  return HasSlot(t2, i) || (t2 = ToTemporalDate(t2)), LeapYear(GetSlot(t2, i));
} };
var OneObjectCache = class _OneObjectCache {
  constructor(e2) {
    if (this.map = /* @__PURE__ */ new Map(), this.calls = 0, this.hits = 0, this.misses = 0, this.now = globalThis.performance ? globalThis.performance.now() : Date.now(), void 0 !== e2) {
      let t2 = 0;
      for (const r2 of e2.map.entries()) {
        if (++t2 > _OneObjectCache.MAX_CACHE_ENTRIES)
          break;
        this.map.set(...r2);
      }
    }
  }
  get(e2) {
    const t2 = this.map.get(e2);
    return t2 && (this.hits++, this.report()), this.calls++, t2;
  }
  set(e2, t2) {
    this.map.set(e2, t2), this.misses++, this.report();
  }
  report() {
  }
  setObject(e2) {
    if (_OneObjectCache.objectMap.get(e2))
      throw new RangeError("object already cached");
    _OneObjectCache.objectMap.set(e2, this), this.report();
  }
  static getCacheForObject(e2) {
    let t2 = _OneObjectCache.objectMap.get(e2);
    return t2 || (t2 = new _OneObjectCache(), _OneObjectCache.objectMap.set(e2, t2)), t2;
  }
};
function toUtcIsoDateString({ isoYear: e2, isoMonth: t2, isoDay: r2 }) {
  return `${ISOYearString(e2)}-${ISODateTimePartString(t2)}-${ISODateTimePartString(r2)}T00:00Z`;
}
function simpleDateDiff(e2, t2) {
  return { years: e2.year - t2.year, months: e2.month - t2.month, days: e2.day - t2.day };
}
OneObjectCache.objectMap = /* @__PURE__ */ new WeakMap(), OneObjectCache.MAX_CACHE_ENTRIES = 1e3;
var HelperBase = class {
  constructor() {
    this.eraLength = "short", this.hasEra = true, this.erasBeginMidYear = false;
  }
  getFormatter() {
    return void 0 === this.formatter && (this.formatter = new ft(`en-US-u-ca-${this.id}`, { day: "numeric", month: "numeric", year: "numeric", era: this.eraLength, timeZone: "UTC" })), this.formatter;
  }
  isoToCalendarDate(e2, t2) {
    const { year: r2, month: o2, day: n2 } = e2, a2 = JSON.stringify({ func: "isoToCalendarDate", isoYear: r2, isoMonth: o2, isoDay: n2, id: this.id }), i2 = t2.get(a2);
    if (i2)
      return i2;
    const s2 = this.getFormatter();
    let l2, d2;
    try {
      d2 = toUtcIsoDateString({ isoYear: r2, isoMonth: o2, isoDay: n2 }), l2 = s2.formatToParts(new Date(d2));
    } catch (e3) {
      throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear: r2, isoMonth: o2, isoDay: n2 })}`);
    }
    const m2 = {};
    for (let { type: e3, value: t3 } of l2) {
      if ("year" === e3 && (m2.eraYear = +t3), "relatedYear" === e3 && (m2.eraYear = +t3), "month" === e3) {
        const e4 = /^([0-9]*)(.*?)$/.exec(t3);
        if (!e4 || 3 != e4.length || !e4[1] && !e4[2])
          throw new RangeError(`Unexpected month: ${t3}`);
        if (m2.month = e4[1] ? +e4[1] : 1, m2.month < 1)
          throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);
        if (m2.month > 13)
          throw new RangeError(`Invalid month ${t3} from ${d2}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
        e4[2] && (m2.monthExtra = e4[2]);
      }
      "day" === e3 && (m2.day = +t3), this.hasEra && "era" === e3 && null != t3 && "" !== t3 && (t3 = t3.split(" (")[0], m2.era = t3.normalize("NFD").replace(/[^-0-9 \p{L}]/gu, "").replace(" ", "-").toLowerCase());
    }
    if (void 0 === m2.eraYear)
      throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
    if (this.reviseIntlEra) {
      const { era: t3, eraYear: r3 } = this.reviseIntlEra(m2, e2);
      m2.era = t3, m2.eraYear = r3;
    }
    this.checkIcuBugs && this.checkIcuBugs(e2);
    const c2 = this.adjustCalendarDate(m2, t2, "constrain", true);
    if (void 0 === c2.year)
      throw new RangeError(`Missing year converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.month)
      throw new RangeError(`Missing month converting ${JSON.stringify(e2)}`);
    if (void 0 === c2.day)
      throw new RangeError(`Missing day converting ${JSON.stringify(e2)}`);
    return t2.set(a2, c2), ["constrain", "reject"].forEach((r3) => {
      const o3 = JSON.stringify({ func: "calendarToIsoDate", year: c2.year, month: c2.month, day: c2.day, overflow: r3, id: this.id });
      t2.set(o3, e2);
    }), c2;
  }
  validateCalendarDate(e2) {
    const { era: t2, month: r2, year: o2, day: n2, eraYear: a2, monthCode: i2, monthExtra: s2 } = e2;
    if (void 0 !== s2)
      throw new RangeError("Unexpected `monthExtra` value");
    if (void 0 === o2 && void 0 === a2)
      throw new TypeError("year or eraYear is required");
    if (void 0 === r2 && void 0 === i2)
      throw new TypeError("month or monthCode is required");
    if (void 0 === n2)
      throw new RangeError("Missing day");
    if (void 0 !== i2) {
      if ("string" != typeof i2)
        throw new RangeError("monthCode must be a string, not " + typeof i2);
      if (!/^M([01]?\d)(L?)$/.test(i2))
        throw new RangeError(`Invalid monthCode: ${i2}`);
    }
    if (this.constantEra) {
      if (void 0 !== t2 && t2 !== this.constantEra)
        throw new RangeError(`era must be ${this.constantEra}, not ${t2}`);
      if (void 0 !== a2 && void 0 !== o2 && a2 !== o2)
        throw new RangeError(`eraYear ${a2} does not match year ${o2}`);
    }
    if (this.hasEra && void 0 === e2.era != (void 0 === e2.eraYear))
      throw new RangeError("properties 'era' and 'eraYear' must be provided together");
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    if ("lunisolar" === this.calendarType)
      throw new RangeError("Override required for lunisolar calendars");
    let n2 = e2;
    if (this.validateCalendarDate(n2), this.constantEra) {
      const { year: e3, eraYear: t3 } = n2;
      n2 = { ...n2, era: this.constantEra, year: void 0 !== e3 ? e3 : t3, eraYear: void 0 !== t3 ? t3 : e3 };
    }
    const a2 = this.monthsInYear(n2, t2);
    let { month: i2, monthCode: s2 } = n2;
    return { month: i2, monthCode: s2 } = resolveNonLunisolarMonth(n2, r2, a2), { ...n2, month: i2, monthCode: s2 };
  }
  regulateMonthDayNaive(e2, t2, r2) {
    const o2 = this.monthsInYear(e2, r2);
    let { month: n2, day: a2 } = e2;
    return "reject" === t2 ? (RejectToRange(n2, 1, o2), RejectToRange(a2, 1, this.maximumMonthLength(e2))) : (n2 = ConstrainToRange(n2, 1, o2), a2 = ConstrainToRange(a2, 1, this.maximumMonthLength({ ...e2, month: n2 }))), { ...e2, month: n2, day: a2 };
  }
  calendarToIsoDate(e2, t2 = "constrain", r2) {
    const o2 = e2;
    let n2 = this.adjustCalendarDate(e2, r2, t2, false);
    n2 = this.regulateMonthDayNaive(n2, t2, r2);
    const { year: a2, month: i2, day: s2 } = n2, l2 = JSON.stringify({ func: "calendarToIsoDate", year: a2, month: i2, day: s2, overflow: t2, id: this.id });
    let d2, m2 = r2.get(l2);
    if (m2)
      return m2;
    if (void 0 !== o2.year && void 0 !== o2.month && void 0 !== o2.day && (o2.year !== n2.year || o2.month !== n2.month || o2.day !== n2.day) && (d2 = JSON.stringify({ func: "calendarToIsoDate", year: o2.year, month: o2.month, day: o2.day, overflow: t2, id: this.id }), m2 = r2.get(d2), m2))
      return m2;
    let c2 = this.estimateIsoDate({ year: a2, month: i2, day: s2 });
    const calculateSameMonthResult = (e3) => {
      let o3 = this.addDaysIso(c2, e3);
      if (n2.day > this.minimumMonthLength(n2)) {
        let e4 = this.isoToCalendarDate(o3, r2);
        for (; e4.month !== i2 || e4.year !== a2; ) {
          if ("reject" === t2)
            throw new RangeError(`day ${s2} does not exist in month ${i2} of year ${a2}`);
          o3 = this.addDaysIso(o3, -1), e4 = this.isoToCalendarDate(o3, r2);
        }
      }
      return o3;
    };
    let h2 = 0, u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2);
    if (0 !== T2.years || 0 !== T2.months || 0 !== T2.days) {
      const e3 = 365 * T2.years + 30 * T2.months + T2.days;
      c2 = this.addDaysIso(c2, e3), u2 = this.isoToCalendarDate(c2, r2), T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months ? c2 = calculateSameMonthResult(T2.days) : h2 = this.compareCalendarDates(n2, u2);
    }
    let p2 = 8;
    for (; h2; ) {
      c2 = this.addDaysIso(c2, h2 * p2);
      const e3 = u2;
      u2 = this.isoToCalendarDate(c2, r2);
      const a3 = h2;
      if (h2 = this.compareCalendarDates(n2, u2), h2) {
        if (T2 = simpleDateDiff(n2, u2), 0 === T2.years && 0 === T2.months)
          c2 = calculateSameMonthResult(T2.days), h2 = 0;
        else if (a3 && h2 !== a3)
          if (p2 > 1)
            p2 /= 2;
          else {
            if ("reject" === t2)
              throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...o2 })}`);
            this.compareCalendarDates(u2, e3) > 0 && (c2 = this.addDaysIso(c2, -1)), h2 = 0;
          }
      }
    }
    if (r2.set(l2, c2), d2 && r2.set(d2, c2), void 0 === n2.year || void 0 === n2.month || void 0 === n2.day || void 0 === n2.monthCode || this.hasEra && (void 0 === n2.era || void 0 === n2.eraYear))
      throw new RangeError("Unexpected missing property");
    return c2;
  }
  temporalToCalendarDate(e2, t2) {
    const r2 = { year: GetSlot(e2, i), month: GetSlot(e2, s), day: GetSlot(e2, l) };
    return this.isoToCalendarDate(r2, t2);
  }
  compareCalendarDates(e2, t2) {
    const r2 = PrepareTemporalFields(e2, ["day", "month", "year"], ["day", "month", "year"]), o2 = PrepareTemporalFields(t2, ["day", "month", "year"], ["day", "month", "year"]);
    return r2.year !== o2.year ? ComparisonResult(r2.year - o2.year) : r2.month !== o2.month ? ComparisonResult(r2.month - o2.month) : r2.day !== o2.day ? ComparisonResult(r2.day - o2.day) : 0;
  }
  regulateDate(e2, t2 = "constrain", r2) {
    const o2 = this.calendarToIsoDate(e2, t2, r2);
    return this.isoToCalendarDate(o2, r2);
  }
  addDaysIso(e2, t2) {
    return AddISODate(e2.year, e2.month, e2.day, 0, 0, 0, t2, "constrain");
  }
  addDaysCalendar(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.addDaysIso(o2, t2);
    return this.isoToCalendarDate(n2, r2);
  }
  addMonthsCalendar(e2, t2, r2, o2) {
    let n2 = e2;
    const { day: a2 } = n2;
    for (let e3 = 0, r3 = It(t2); e3 < r3; e3++) {
      const { month: e4 } = n2, r4 = n2, i2 = t2 < 0 ? -Math.max(a2, this.daysInPreviousMonth(n2, o2)) : this.daysInMonth(n2, o2), s2 = this.calendarToIsoDate(n2, "constrain", o2);
      let l2 = this.addDaysIso(s2, i2);
      if (n2 = this.isoToCalendarDate(l2, o2), t2 > 0) {
        const t3 = this.monthsInYear(r4, o2);
        for (; n2.month - 1 != e4 % t3; )
          l2 = this.addDaysIso(l2, -1), n2 = this.isoToCalendarDate(l2, o2);
      }
      n2.day !== a2 && (n2 = this.regulateDate({ ...n2, day: a2 }, "constrain", o2));
    }
    if ("reject" === r2 && n2.day !== a2)
      throw new RangeError(`Day ${a2} does not exist in resulting calendar month`);
    return n2;
  }
  addCalendar(e2, { years: t2 = 0, months: r2 = 0, weeks: o2 = 0, days: n2 = 0 }, a2, i2) {
    const { year: s2, day: l2, monthCode: d2 } = e2, m2 = this.adjustCalendarDate({ year: s2 + t2, monthCode: d2, day: l2 }, i2), c2 = this.addMonthsCalendar(m2, r2, a2, i2), h2 = n2 + 7 * o2;
    return this.addDaysCalendar(c2, h2, i2);
  }
  untilCalendar(e2, t2, r2, o2) {
    let n2 = 0, a2 = 0, i2 = 0, s2 = 0;
    switch (r2) {
      case "day":
        n2 = this.calendarDaysUntil(e2, t2, o2);
        break;
      case "week": {
        const r3 = this.calendarDaysUntil(e2, t2, o2);
        n2 = r3 % 7, a2 = (r3 - n2) / 7;
        break;
      }
      case "month":
      case "year": {
        const a3 = this.compareCalendarDates(t2, e2);
        if (!a3)
          return { years: 0, months: 0, weeks: 0, days: 0 };
        const l2 = t2.year - e2.year, d2 = t2.day - e2.day;
        if ("year" === r2 && l2) {
          let r3 = 0;
          t2.monthCode > e2.monthCode && (r3 = 1), t2.monthCode < e2.monthCode && (r3 = -1), r3 || (r3 = Math.sign(d2));
          s2 = r3 * a3 < 0 ? l2 - a3 : l2;
        }
        let m2, c2 = s2 ? this.addCalendar(e2, { years: s2 }, "constrain", o2) : e2;
        do {
          i2 += a3, m2 = c2, c2 = this.addMonthsCalendar(m2, a3, "constrain", o2), c2.day !== e2.day && (c2 = this.regulateDate({ ...c2, day: e2.day }, "constrain", o2));
        } while (this.compareCalendarDates(t2, c2) * a3 >= 0);
        i2 -= a3;
        n2 = this.calendarDaysUntil(m2, t2, o2);
        break;
      }
    }
    return { years: s2, months: i2, weeks: a2, days: n2 };
  }
  daysInMonth(e2, t2) {
    const { day: r2 } = e2, o2 = this.maximumMonthLength(e2), n2 = this.minimumMonthLength(e2);
    if (n2 === o2)
      return n2;
    const a2 = r2 <= o2 - n2 ? o2 : n2, i2 = this.calendarToIsoDate(e2, "constrain", t2), s2 = this.addDaysIso(i2, a2), l2 = this.isoToCalendarDate(s2, t2), d2 = this.addDaysIso(s2, -l2.day);
    return this.isoToCalendarDate(d2, t2).day;
  }
  daysInPreviousMonth(e2, t2) {
    const { day: r2, month: o2, year: n2 } = e2;
    let a2 = { year: o2 > 1 ? n2 : n2 - 1, month: o2, day: 1 };
    const i2 = o2 > 1 ? o2 - 1 : this.monthsInYear(a2, t2);
    a2 = { ...a2, month: i2 };
    const s2 = this.minimumMonthLength(a2), l2 = this.maximumMonthLength(a2);
    if (s2 === l2)
      return l2;
    const d2 = this.calendarToIsoDate(e2, "constrain", t2), m2 = this.addDaysIso(d2, -r2);
    return this.isoToCalendarDate(m2, t2).day;
  }
  startOfCalendarYear(e2) {
    return { year: e2.year, month: 1, monthCode: "M01", day: 1 };
  }
  startOfCalendarMonth(e2) {
    return { year: e2.year, month: e2.month, day: 1 };
  }
  calendarDaysUntil(e2, t2, r2) {
    const o2 = this.calendarToIsoDate(e2, "constrain", r2), n2 = this.calendarToIsoDate(t2, "constrain", r2);
    return this.isoDaysUntil(o2, n2);
  }
  isoDaysUntil(e2, t2) {
    return DifferenceISODate(e2.year, e2.month, e2.day, t2.year, t2.month, t2.day, "day").days;
  }
  monthDayFromFields(e2, t2, r2) {
    let o2, n2, a2, i2, s2, { monthCode: l2, day: d2 } = e2;
    if (void 0 === l2) {
      let { year: o3, era: n3, eraYear: a3 } = e2;
      if (void 0 === o3 && (void 0 === n3 || void 0 === a3))
        throw new TypeError("when `monthCode` is omitted, `year` (or `era` and `eraYear`) and `month` are required");
      ({ monthCode: l2, day: d2 } = this.isoToCalendarDate(this.calendarToIsoDate(e2, t2, r2), r2));
    }
    const m2 = this.isoToCalendarDate({ year: 1972, month: 12, day: 31 }, r2), c2 = m2.monthCode > l2 || m2.monthCode === l2 && m2.day >= d2 ? m2.year : m2.year - 1;
    for (let e3 = 0; e3 < 100; e3++) {
      const m3 = this.adjustCalendarDate({ day: d2, monthCode: l2, year: c2 - e3 }, r2), h2 = this.calendarToIsoDate(m3, "constrain", r2), u2 = this.isoToCalendarDate(h2, r2);
      if ({ year: o2, month: n2, day: a2 } = h2, u2.monthCode === l2 && u2.day === d2)
        return { month: n2, day: a2, year: o2 };
      "constrain" === t2 && (void 0 === i2 || u2.monthCode === i2.monthCode && u2.day > i2.day) && (i2 = u2, s2 = h2);
    }
    if ("constrain" === t2 && void 0 !== s2)
      return s2;
    throw new RangeError(`No recent ${this.id} year with monthCode ${l2} and day ${d2}`);
  }
};
var HebrewHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "hebrew", this.calendarType = "lunisolar", this.months = { Tishri: { leap: 1, regular: 1, monthCode: "M01", days: 30 }, Heshvan: { leap: 2, regular: 2, monthCode: "M02", days: { min: 29, max: 30 } }, Kislev: { leap: 3, regular: 3, monthCode: "M03", days: { min: 29, max: 30 } }, Tevet: { leap: 4, regular: 4, monthCode: "M04", days: 29 }, Shevat: { leap: 5, regular: 5, monthCode: "M05", days: 30 }, Adar: { leap: void 0, regular: 6, monthCode: "M06", days: 29 }, "Adar I": { leap: 6, regular: void 0, monthCode: "M05L", days: 30 }, "Adar II": { leap: 7, regular: void 0, monthCode: "M06", days: 29 }, Nisan: { leap: 8, regular: 7, monthCode: "M07", days: 30 }, Iyar: { leap: 9, regular: 8, monthCode: "M08", days: 29 }, Sivan: { leap: 10, regular: 9, monthCode: "M09", days: 30 }, Tamuz: { leap: 11, regular: 10, monthCode: "M10", days: 29 }, Av: { leap: 12, regular: 11, monthCode: "M11", days: 30 }, Elul: { leap: 13, regular: 12, monthCode: "M12", days: 29 } }, this.hasEra = false;
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (7 * t2 + 1) % 19 < 7;
  }
  monthsInYear(e2) {
    return this.inLeapYear(e2) ? 13 : 12;
  }
  minimumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "min");
  }
  maximumMonthLength(e2) {
    return this.minMaxMonthLength(e2, "max");
  }
  minMaxMonthLength(e2, t2) {
    const { month: r2, year: o2 } = e2, n2 = this.getMonthCode(o2, r2), a2 = wt(this.months).find((e3) => e3[1].monthCode === n2);
    if (void 0 === a2)
      throw new RangeError(`unmatched Hebrew month: ${r2}`);
    const i2 = a2[1].days;
    return "number" == typeof i2 ? i2 : i2[t2];
  }
  estimateIsoDate(e2) {
    const { year: t2 } = e2;
    return { year: t2 - 3760, month: 1, day: 1 };
  }
  getMonthCode(e2, t2) {
    return this.inLeapYear({ year: e2 }) ? 6 === t2 ? buildMonthCode(5, true) : buildMonthCode(t2 < 6 ? t2 : t2 - 1) : buildMonthCode(t2);
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, eraYear: a2, month: i2, monthCode: s2, day: l2, monthExtra: d2 } = e2;
    if (void 0 === n2 && void 0 !== a2 && (n2 = a2), void 0 === a2 && void 0 !== n2 && (a2 = n2), o2) {
      if (d2) {
        const e3 = this.months[d2];
        if (!e3)
          throw new RangeError(`Unrecognized month from formatToParts: ${d2}`);
        i2 = this.inLeapYear({ year: n2 }) ? e3.leap : e3.regular;
      }
      s2 = this.getMonthCode(n2, i2);
      return { year: n2, month: i2, day: l2, era: void 0, eraYear: a2, monthCode: s2 };
    }
    if (this.validateCalendarDate(e2), void 0 === i2)
      if (s2.endsWith("L")) {
        if ("M05L" !== s2)
          throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${s2}`);
        if (i2 = 6, !this.inLeapYear({ year: n2 })) {
          if ("reject" === r2)
            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${n2} which is not a leap year`);
          i2 = 6, s2 = "M06";
        }
      } else {
        i2 = monthCodeNumberPart(s2), this.inLeapYear({ year: n2 }) && i2 >= 6 && i2++;
        const e3 = this.monthsInYear({ year: n2 });
        if (i2 < 1 || i2 > e3)
          throw new RangeError(`Invalid monthCode: ${s2}`);
      }
    else if ("reject" === r2 ? (RejectToRange(i2, 1, this.monthsInYear({ year: n2 })), RejectToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))) : (i2 = ConstrainToRange(i2, 1, this.monthsInYear({ year: n2 })), l2 = ConstrainToRange(l2, 1, this.maximumMonthLength({ year: n2, month: i2 }))), void 0 === s2)
      s2 = this.getMonthCode(n2, i2);
    else {
      if (this.getMonthCode(n2, i2) !== s2)
        throw new RangeError(`monthCode ${s2} doesn't correspond to month ${i2} in Hebrew year ${n2}`);
    }
    return { ...e2, day: l2, month: i2, monthCode: s2, year: n2, eraYear: a2 };
  }
};
var IslamicBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunar", this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30, this.DAYS_PER_ISO_YEAR = 365.2425, this.constantEra = "ah";
  }
  inLeapYear(e2, t2) {
    return 30 === this.daysInMonth({ year: e2.year, month: 12, day: 1 }, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return { year: St(t2 * this.DAYS_PER_ISLAMIC_YEAR / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };
  }
};
var IslamicHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic";
  }
};
var IslamicUmalquraHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-umalqura";
  }
};
var IslamicTblaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-tbla";
  }
};
var IslamicCivilHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-civil";
  }
};
var IslamicRgsaHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamic-rgsa";
  }
};
var IslamicCcHelper = class extends IslamicBaseHelper {
  constructor() {
    super(...arguments), this.id = "islamicc";
  }
};
var PersianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "persian", this.calendarType = "solar", this.constantEra = "ap";
  }
  inLeapYear(e2, t2) {
    return IslamicHelper.prototype.inLeapYear.call(this, e2, t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 29 : t2 <= 6 ? 31 : 30;
  }
  maximumMonthLength(e2) {
    const { month: t2 } = e2;
    return 12 === t2 ? 30 : t2 <= 6 ? 31 : 30;
  }
  estimateIsoDate(e2) {
    const { year: t2 } = this.adjustCalendarDate(e2);
    return { year: t2 + 621, month: 1, day: 1 };
  }
};
var IndianHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.id = "indian", this.calendarType = "solar", this.constantEra = "saka", this.months = { 1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } }, 2: { length: 31, month: 4, day: 21 }, 3: { length: 31, month: 5, day: 22 }, 4: { length: 31, month: 6, day: 22 }, 5: { length: 31, month: 7, day: 23 }, 6: { length: 31, month: 8, day: 23 }, 7: { length: 30, month: 9, day: 23 }, 8: { length: 30, month: 10, day: 23 }, 9: { length: 30, month: 11, day: 22 }, 10: { length: 30, month: 12, day: 22 }, 11: { length: 30, month: 1, nextYear: true, day: 21 }, 12: { length: 30, month: 2, nextYear: true, day: 20 } }, this.vulnerableToBceBug = "10/11/-79 Saka" !== (/* @__PURE__ */ new Date("0000-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-indian", { timeZone: "UTC" });
  }
  inLeapYear(e2) {
    return isGregorianLeapYear(e2.year + 78);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  maximumMonthLength(e2) {
    return this.getMonthInfo(e2).length;
  }
  getMonthInfo(e2) {
    const { month: t2 } = e2;
    let r2 = this.months[t2];
    if (void 0 === r2)
      throw new RangeError(`Invalid month: ${t2}`);
    return this.inLeapYear(e2) && r2.leap && (r2 = r2.leap), r2;
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), r2 = this.getMonthInfo(t2);
    return AddISODate(t2.year + 78 + (r2.nextYear ? 1 : 0), r2.month, r2.day, 0, 0, 0, t2.day - 1, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.vulnerableToBceBug && e2.year < 1)
      throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);
  }
};
function isGregorianLeapYear(e2) {
  return e2 % 4 == 0 && (e2 % 100 != 0 || e2 % 400 == 0);
}
var GregorianBaseHelper = class extends HelperBase {
  constructor(e2, t2) {
    super(), this.calendarType = "solar", this.v8IsVulnerableToJulianBug = (/* @__PURE__ */ new Date("+001001-01-01T00:00Z")).toLocaleDateString("en-US-u-ca-japanese", { timeZone: "UTC" }).startsWith("12"), this.calendarIsVulnerableToJulianBug = false, this.id = e2;
    const { eras: r2, anchorEra: o2 } = function adjustEras(e3) {
      let t3, r3 = e3;
      if (0 === r3.length)
        throw new RangeError("Invalid era data: eras are required");
      if (1 === r3.length && r3[0].reverseOf)
        throw new RangeError("Invalid era data: anchor era cannot count years backwards");
      if (1 === r3.length && !r3[0].name)
        throw new RangeError("Invalid era data: at least one named era is required");
      if (r3.filter((e4) => null != e4.reverseOf).length > 1)
        throw new RangeError("Invalid era data: only one era can count years backwards");
      r3.forEach((e4) => {
        if (e4.isAnchor || !e4.anchorEpoch && !e4.reverseOf) {
          if (t3)
            throw new RangeError("Invalid era data: cannot have multiple anchor eras");
          t3 = e4, e4.anchorEpoch = { year: e4.hasYearZero ? 0 : 1 };
        } else if (!e4.name)
          throw new RangeError("If era name is blank, it must be the anchor era");
      }), r3 = r3.filter((e4) => e4.name), r3.forEach((e4) => {
        const { reverseOf: t4 } = e4;
        if (t4) {
          const o4 = r3.find((e5) => e5.name === t4);
          if (void 0 === o4)
            throw new RangeError(`Invalid era data: unmatched reverseOf era: ${t4}`);
          e4.reverseOf = o4, e4.anchorEpoch = o4.anchorEpoch, e4.isoEpoch = o4.isoEpoch;
        }
        void 0 === e4.anchorEpoch.month && (e4.anchorEpoch.month = 1), void 0 === e4.anchorEpoch.day && (e4.anchorEpoch.day = 1);
      }), yt.call(r3, (e4, t4) => {
        if (e4.reverseOf)
          return 1;
        if (t4.reverseOf)
          return -1;
        if (!e4.isoEpoch || !t4.isoEpoch)
          throw new RangeError("Invalid era data: missing ISO epoch");
        return t4.isoEpoch.year - e4.isoEpoch.year;
      });
      const o3 = r3[r3.length - 1].reverseOf;
      if (o3 && o3 !== r3[r3.length - 2])
        throw new RangeError("Invalid era data: invalid reverse-sign era");
      return r3.forEach((e4, t4) => {
        e4.genericName = "era" + (r3.length - 1 - t4);
      }), { eras: r3, anchorEra: t3 || r3[0] };
    }(t2);
    this.anchorEra = o2, this.eras = r2;
  }
  inLeapYear(e2) {
    const { year: t2 } = this.estimateIsoDate({ month: 1, day: 1, year: e2.year });
    return isGregorianLeapYear(t2);
  }
  monthsInYear() {
    return 12;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 2 === t2 ? this.inLeapYear(e2) ? 29 : 28 : [4, 6, 9, 11].indexOf(t2) >= 0 ? 30 : 31;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
  completeEraYear(e2) {
    const checkField = (t3, r3) => {
      const o3 = e2[t3];
      if (null != o3 && o3 != r3)
        throw new RangeError(`Input ${t3} ${o3} doesn't match calculated value ${r3}`);
    }, eraFromYear = (t3) => {
      let r3;
      const o3 = { ...e2, year: t3 }, n2 = this.eras.find((e3, n3) => {
        if (n3 === this.eras.length - 1) {
          if (e3.reverseOf) {
            if (t3 > 0)
              throw new RangeError(`Signed year ${t3} is invalid for era ${e3.name}`);
            return r3 = e3.anchorEpoch.year - t3, true;
          }
          return r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true;
        }
        return this.compareCalendarDates(o3, e3.anchorEpoch) >= 0 && (r3 = t3 - e3.anchorEpoch.year + (e3.hasYearZero ? 0 : 1), true);
      });
      if (!n2)
        throw new RangeError(`Year ${t3} was not matched by any era`);
      return { eraYear: r3, era: n2.name };
    };
    let { year: t2, eraYear: r2, era: o2 } = e2;
    if (null != t2)
      ({ eraYear: r2, era: o2 } = eraFromYear(t2)), checkField("era", o2), checkField("eraYear", r2);
    else {
      if (null == r2)
        throw new RangeError("Either `year` or `eraYear` and `era` are required");
      {
        const e3 = void 0 === o2 ? void 0 : this.eras.find((e4) => e4.name === o2 || e4.genericName === o2);
        if (!e3)
          throw new RangeError(`Era ${o2} (ISO year ${r2}) was not matched by any era`);
        if (r2 < 1 && e3.reverseOf)
          throw new RangeError(`Years in ${o2} era must be positive, not ${t2}`);
        t2 = e3.reverseOf ? e3.anchorEpoch.year - r2 : r2 + e3.anchorEpoch.year - (e3.hasYearZero ? 0 : 1), checkField("year", t2), { eraYear: r2, era: o2 } = eraFromYear(t2);
      }
    }
    return { ...e2, year: t2, eraYear: r2, era: o2 };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain") {
    let o2 = e2;
    const { month: n2, monthCode: a2 } = o2;
    return void 0 === n2 && (o2 = { ...o2, month: monthCodeNumberPart(a2) }), this.validateCalendarDate(o2), o2 = this.completeEraYear(o2), super.adjustCalendarDate(o2, t2, r2);
  }
  estimateIsoDate(e2) {
    const t2 = this.adjustCalendarDate(e2), { year: r2, month: o2, day: n2 } = t2, { anchorEra: a2 } = this;
    return RegulateISODate(r2 + a2.isoEpoch.year - (a2.hasYearZero ? 0 : 1), o2, n2, "constrain");
  }
  checkIcuBugs(e2) {
    if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {
      if (CompareISODate(e2.year, e2.month, e2.day, 1582, 10, 15) < 0)
        throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`);
    }
  }
};
var OrthodoxBaseHelper = class extends GregorianBaseHelper {
  constructor(e2, t2) {
    super(e2, t2);
  }
  inLeapYear(e2) {
    const { year: t2 } = e2;
    return (t2 + 1) % 4 == 0;
  }
  monthsInYear() {
    return 13;
  }
  minimumMonthLength(e2) {
    const { month: t2 } = e2;
    return 13 === t2 ? this.inLeapYear(e2) ? 6 : 5 : 30;
  }
  maximumMonthLength(e2) {
    return this.minimumMonthLength(e2);
  }
};
var EthioaaHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethioaa", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }]);
  }
};
var CopticHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("coptic", [{ name: "era1", isoEpoch: { year: 284, month: 8, day: 29 } }, { name: "era0", reverseOf: "era1" }]);
  }
};
var EthiopicHelper = class extends OrthodoxBaseHelper {
  constructor() {
    super("ethiopic", [{ name: "era0", isoEpoch: { year: -5492, month: 7, day: 17 } }, { name: "era1", isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }]);
  }
};
var RocHelper = class extends GregorianBaseHelper {
  constructor() {
    super("roc", [{ name: "minguo", isoEpoch: { year: 1912, month: 1, day: 1 } }, { name: "before-roc", reverseOf: "minguo" }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var BuddhistHelper = class extends GregorianBaseHelper {
  constructor() {
    super("buddhist", [{ name: "be", hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]), this.calendarIsVulnerableToJulianBug = true;
  }
};
var GregoryHelper = class extends GregorianBaseHelper {
  constructor() {
    super("gregory", [{ name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]);
  }
  reviseIntlEra(e2) {
    let { era: t2, eraYear: r2 } = e2;
    return "bc" !== t2 && "b" !== t2 || (t2 = "bce"), "ad" !== t2 && "a" !== t2 || (t2 = "ce"), { era: t2, eraYear: r2 };
  }
};
var JapaneseHelper = class extends GregorianBaseHelper {
  constructor() {
    super("japanese", [{ name: "reiwa", isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } }, { name: "heisei", isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } }, { name: "showa", isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } }, { name: "taisho", isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } }, { name: "meiji", isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } }, { name: "ce", isoEpoch: { year: 1, month: 1, day: 1 } }, { name: "bce", reverseOf: "ce" }]), this.calendarIsVulnerableToJulianBug = true, this.eraLength = "long", this.erasBeginMidYear = true;
  }
  reviseIntlEra(e2, t2) {
    const { era: r2, eraYear: o2 } = e2, { year: n2 } = t2;
    return this.eras.find((e3) => e3.name === r2) ? { era: r2, eraYear: o2 } : n2 < 1 ? { era: "bce", eraYear: 1 - n2 } : { era: "ce", eraYear: n2 };
  }
};
var ChineseBaseHelper = class extends HelperBase {
  constructor() {
    super(...arguments), this.calendarType = "lunisolar", this.hasEra = false;
  }
  inLeapYear(e2, t2) {
    const r2 = this.getMonthList(e2.year, t2);
    return 13 === wt(r2).length;
  }
  monthsInYear(e2, t2) {
    return this.inLeapYear(e2, t2) ? 13 : 12;
  }
  minimumMonthLength() {
    return 29;
  }
  maximumMonthLength() {
    return 30;
  }
  getMonthList(e2, t2) {
    if (void 0 === e2)
      throw new TypeError("Missing year");
    const r2 = JSON.stringify({ func: "getMonthList", calendarYear: e2, id: this.id }), o2 = t2.get(r2);
    if (o2)
      return o2;
    const n2 = this.getFormatter(), getCalendarDate = (e3, t3) => {
      const r3 = toUtcIsoDateString({ isoYear: e3, isoMonth: 2, isoDay: 1 }), o3 = new Date(r3);
      o3.setUTCDate(t3 + 1);
      const a3 = n2.formatToParts(o3), i3 = a3.find((e4) => "month" === e4.type).value, s3 = +a3.find((e4) => "day" === e4.type).value;
      let l3 = a3.find((e4) => "relatedYear" === e4.type);
      if (void 0 === l3)
        throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);
      return l3 = +l3.value, { calendarMonthString: i3, calendarDay: s3, calendarYearToVerify: l3 };
    };
    let a2 = 17, { calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2);
    "1" !== i2 && (a2 += 29, { calendarMonthString: i2, calendarDay: s2 } = getCalendarDate(e2, a2)), a2 -= s2 - 5;
    const d2 = {};
    let m2, c2, h2 = 1, u2 = false;
    do {
      ({ calendarMonthString: i2, calendarDay: s2, calendarYearToVerify: l2 } = getCalendarDate(e2, a2)), m2 && (d2[c2].daysInMonth = m2 + 30 - s2), l2 !== e2 ? u2 = true : (d2[i2] = { monthIndex: h2++ }, a2 += 30), m2 = s2, c2 = i2;
    } while (!u2);
    return d2[c2].daysInMonth = m2 + 30 - s2, t2.set(r2, d2), d2;
  }
  estimateIsoDate(e2) {
    const { year: t2, month: r2 } = e2;
    return { year: t2, month: r2 >= 12 ? 12 : r2 + 1, day: 1 };
  }
  adjustCalendarDate(e2, t2, r2 = "constrain", o2 = false) {
    let { year: n2, month: a2, monthExtra: i2, day: s2, monthCode: l2, eraYear: d2 } = e2;
    if (o2) {
      if (n2 = d2, i2 && "bis" !== i2)
        throw new RangeError(`Unexpected leap month suffix: ${i2}`);
      const e3 = buildMonthCode(a2, void 0 !== i2), r3 = `${a2}${i2 || ""}`, o3 = this.getMonthList(n2, t2)[r3];
      if (void 0 === o3)
        throw new RangeError(`Unmatched month ${r3} in Chinese year ${n2}`);
      return a2 = o3.monthIndex, { year: n2, month: a2, day: s2, era: void 0, eraYear: d2, monthCode: e3 };
    }
    if (this.validateCalendarDate(e2), void 0 === n2 && (n2 = d2), void 0 === d2 && (d2 = n2), void 0 === a2) {
      const e3 = this.getMonthList(n2, t2);
      let o3 = l2.replace("L", "bis").slice(1);
      "0" === o3[0] && (o3 = o3.slice(1));
      let i3 = e3[o3];
      if (a2 = i3 && i3.monthIndex, void 0 === a2 && l2.endsWith("L") && "M13L" != l2 && "constrain" === r2) {
        let t3 = l2.slice(1, -1);
        "0" === t3[0] && (t3 = t3.slice(1)), i3 = e3[t3], i3 && (a2 = i3.monthIndex, l2 = buildMonthCode(t3));
      }
      if (void 0 === a2)
        throw new RangeError(`Unmatched month ${l2} in Chinese year ${n2}`);
    } else if (void 0 === l2) {
      const e3 = this.getMonthList(n2, t2), o3 = wt(e3), i3 = o3.length;
      "reject" === r2 ? (RejectToRange(a2, 1, i3), RejectToRange(s2, 1, this.maximumMonthLength())) : (a2 = ConstrainToRange(a2, 1, i3), s2 = ConstrainToRange(s2, 1, this.maximumMonthLength()));
      const d3 = o3.find(([, e4]) => e4.monthIndex === a2);
      if (void 0 === d3)
        throw new RangeError(`Invalid month ${a2} in Chinese year ${n2}`);
      l2 = buildMonthCode(d3[0].replace("bis", ""), -1 !== d3[0].indexOf("bis"));
    } else {
      const e3 = this.getMonthList(n2, t2);
      let r3 = l2.replace("L", "bis").slice(1);
      "0" === r3[0] && (r3 = r3.slice(1));
      const o3 = e3[r3];
      if (!o3)
        throw new RangeError(`Unmatched monthCode ${l2} in Chinese year ${n2}`);
      if (a2 !== o3.monthIndex)
        throw new RangeError(`monthCode ${l2} doesn't correspond to month ${a2} in Chinese year ${n2}`);
    }
    return { ...e2, year: n2, eraYear: d2, month: a2, monthCode: l2, day: s2 };
  }
};
var ChineseHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "chinese";
  }
};
var DangiHelper = class extends ChineseBaseHelper {
  constructor() {
    super(...arguments), this.id = "dangi";
  }
};
var NonIsoCalendar = class {
  constructor(e2) {
    this.helper = e2;
  }
  dateFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields(["day", "month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate(n2, a2, o2), d2 = CreateTemporalDate(i2, s2, l2, r2);
    return o2.setObject(d2), d2;
  }
  yearMonthFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields(["month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.calendarToIsoDate({ ...n2, day: 1 }, a2, o2), d2 = CreateTemporalYearMonth(i2, s2, r2, l2);
    return o2.setObject(d2), d2;
  }
  monthDayFromFields(e2, t2, r2) {
    const o2 = new OneObjectCache(), n2 = PrepareTemporalFields(e2, this.fields(["day", "month", "monthCode", "year"]), []), a2 = ToTemporalOverflow(t2), { year: i2, month: s2, day: l2 } = this.helper.monthDayFromFields(n2, a2, o2), d2 = CreateTemporalMonthDay(s2, l2, r2, i2);
    return o2.setObject(d2), d2;
  }
  fields(e2) {
    let t2 = e2;
    return Tt.call(t2, "year") && (t2 = [...t2, "era", "eraYear"]), t2;
  }
  fieldKeysToIgnore(e2) {
    const t2 = new Dt();
    for (let r2 = 0; r2 < e2.length; r2++) {
      const o2 = e2[r2];
      switch (Call(vt, t2, [o2]), o2) {
        case "era":
          Call(vt, t2, ["eraYear"]), Call(vt, t2, ["year"]);
          break;
        case "eraYear":
          Call(vt, t2, ["era"]), Call(vt, t2, ["year"]);
          break;
        case "year":
          Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]);
          break;
        case "month":
          Call(vt, t2, ["monthCode"]), this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
          break;
        case "monthCode":
          Call(vt, t2, ["month"]), this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
          break;
        case "day":
          this.helper.erasBeginMidYear && (Call(vt, t2, ["era"]), Call(vt, t2, ["eraYear"]));
      }
    }
    return [...Call(Ct, t2, [])];
  }
  dateAdd(e2, t2, r2, o2, n2, a2, i2) {
    const s2 = OneObjectCache.getCacheForObject(e2), l2 = this.helper.temporalToCalendarDate(e2, s2), d2 = this.helper.addCalendar(l2, { years: t2, months: r2, weeks: o2, days: n2 }, a2, s2), m2 = this.helper.calendarToIsoDate(d2, "constrain", s2), { year: c2, month: h2, day: u2 } = m2, T2 = CreateTemporalDate(c2, h2, u2, i2);
    return new OneObjectCache(s2).setObject(T2), T2;
  }
  dateUntil(e2, t2, r2) {
    const o2 = OneObjectCache.getCacheForObject(e2), n2 = OneObjectCache.getCacheForObject(t2), a2 = this.helper.temporalToCalendarDate(e2, o2), i2 = this.helper.temporalToCalendarDate(t2, n2);
    return this.helper.untilCalendar(a2, i2, r2, o2);
  }
  year(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).year;
  }
  month(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).month;
  }
  day(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).day;
  }
  era(e2) {
    if (!this.helper.hasEra)
      return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).era;
  }
  eraYear(e2) {
    if (!this.helper.hasEra)
      return;
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).eraYear;
  }
  monthCode(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2);
    return this.helper.temporalToCalendarDate(e2, t2).monthCode;
  }
  dayOfWeek(e2) {
    return Ot.iso8601.dayOfWeek(e2);
  }
  dayOfYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.isoToCalendarDate(e2, t2), o2 = this.helper.startOfCalendarYear(r2);
    return this.helper.calendarDaysUntil(o2, r2, t2) + 1;
  }
  weekOfYear(e2) {
    return Ot.iso8601.weekOfYear(e2);
  }
  yearOfWeek(e2) {
    return Ot.iso8601.yearOfWeek(e2);
  }
  daysInWeek(e2) {
    return Ot.iso8601.daysInWeek(e2);
  }
  daysInMonth(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2), o2 = this.helper.maximumMonthLength(r2);
    if (o2 === this.helper.minimumMonthLength(r2))
      return o2;
    const n2 = this.helper.startOfCalendarMonth(r2), a2 = this.helper.addMonthsCalendar(n2, 1, "constrain", t2);
    return this.helper.calendarDaysUntil(n2, a2, t2);
  }
  daysInYear(e2) {
    let t2 = e2;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2), n2 = this.helper.startOfCalendarYear(o2), a2 = this.helper.addCalendar(n2, { years: 1 }, "constrain", r2);
    return this.helper.calendarDaysUntil(n2, a2, r2);
  }
  monthsInYear(e2) {
    const t2 = OneObjectCache.getCacheForObject(e2), r2 = this.helper.temporalToCalendarDate(e2, t2);
    return this.helper.monthsInYear(r2, t2);
  }
  inLeapYear(e2) {
    let t2 = e2;
    HasSlot(t2, i) || (t2 = ToTemporalDate(t2));
    const r2 = OneObjectCache.getCacheForObject(t2), o2 = this.helper.temporalToCalendarDate(t2, r2);
    return this.helper.inLeapYear(o2, r2);
  }
};
for (const e2 of [HebrewHelper, PersianHelper, EthiopicHelper, EthioaaHelper, CopticHelper, ChineseHelper, DangiHelper, RocHelper, IndianHelper, BuddhistHelper, GregoryHelper, JapaneseHelper, IslamicHelper, IslamicUmalquraHelper, IslamicTblaHelper, IslamicCivilHelper, IslamicRgsaHelper, IslamicCcHelper]) {
  const t2 = new e2();
  Ot[t2.id] = new NonIsoCalendar(t2);
}
var PlainDate = class _PlainDate {
  constructor(e2, t2, r2, o2 = "iso8601") {
    CreateTemporalDateSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), ToTemporalCalendarSlotValue(o2));
  }
  get calendarId() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get year() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarDateFromFields(o2, a2, r2);
  }
  withCalendar(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return new _PlainDate(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalDuration(e2), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const r2 = CreateNegatedTemporalDuration(ToTemporalDuration(e2)), o2 = GetOptionsObject(t2);
    return CalendarDateAdd(GetSlot(this, p), this, r2, o2);
  }
  until(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDate("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2);
    for (const e3 of [i, s, l]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return TemporalDateToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return TemporalDateToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDate");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e2)
      return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    let t2, r2;
    if (IsObject(e2))
      if (IsTemporalTimeZone(e2))
        t2 = e2;
      else {
        const o3 = e2.timeZone;
        void 0 === o3 ? t2 = ToTemporalTimeZoneSlotValue(e2) : (t2 = ToTemporalTimeZoneSlotValue(o3), r2 = e2.plainTime);
      }
    else
      t2 = ToTemporalTimeZoneSlotValue(e2);
    const o2 = GetSlot(this, i), a2 = GetSlot(this, s), f2 = GetSlot(this, l), y2 = GetSlot(this, p);
    let I2 = 0, S2 = 0, g2 = 0, w2 = 0, D2 = 0, G2 = 0;
    void 0 !== r2 && (r2 = ToTemporalTime(r2), I2 = GetSlot(r2, d), S2 = GetSlot(r2, m), g2 = GetSlot(r2, c), w2 = GetSlot(r2, h), D2 = GetSlot(r2, u), G2 = GetSlot(r2, T));
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(t2, CreateTemporalDateTime(o2, a2, f2, I2, S2, g2, w2, D2, G2, y2), "compatible"), n), t2, y2);
  }
  toPlainYearMonth() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalDate(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDate(e2) ? (ToTemporalOverflow(r2), CreateTemporalDate(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p))) : ToTemporalDate(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDate(e2), o2 = ToTemporalDate(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainDate, "Temporal.PlainDate");
var PlainDateTime = class _PlainDateTime {
  constructor(e2, t2, r2, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = "iso8601") {
    CreateTemporalDateTimeSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToIntegerWithTruncation(r2), void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), void 0 === a2 ? 0 : ToIntegerWithTruncation(a2), void 0 === i2 ? 0 : ToIntegerWithTruncation(i2), void 0 === s2 ? 0 : ToIntegerWithTruncation(s2), void 0 === l2 ? 0 : ToIntegerWithTruncation(l2), ToTemporalCalendarSlotValue(d2));
  }
  get calendarId() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get year() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get hour() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  get era() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get dayOfWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), this);
  }
  get dayOfYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), this);
  }
  get weekOfYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), this);
  }
  get yearOfWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), this);
  }
  get daysInWeek() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []);
    const { year: i2, month: s2, day: l2, hour: d2, minute: m2, second: c2, millisecond: h2, microsecond: u2, nanosecond: T2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    return CreateTemporalDateTime(i2, s2, l2, d2, m2, c2, h2, u2, T2, o2);
  }
  withPlainTime(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, i), r2 = GetSlot(this, s), o2 = GetSlot(this, l), n2 = GetSlot(this, p);
    if (void 0 === e2)
      return CreateTemporalDateTime(t2, r2, o2, 0, 0, 0, 0, 0, 0, n2);
    const a2 = ToTemporalTime(e2);
    return CreateTemporalDateTime(t2, r2, o2, GetSlot(a2, d), GetSlot(a2, m), GetSlot(a2, c), GetSlot(a2, h), GetSlot(a2, u), GetSlot(a2, T), n2);
  }
  withPlainDate(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l);
    let a2 = GetSlot(t2, p);
    const f2 = GetSlot(this, d), y2 = GetSlot(this, m), I2 = GetSlot(this, c), S2 = GetSlot(this, h), g2 = GetSlot(this, u), w2 = GetSlot(this, T);
    return a2 = ConsolidateCalendars(GetSlot(this, p), a2), CreateTemporalDateTime(r2, o2, n2, f2, y2, I2, S2, g2, w2, a2);
  }
  withCalendar(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return new _PlainDateTime(GetSlot(this, i), GetSlot(this, s), GetSlot(this, l), GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), t2);
  }
  add(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainDateTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He, ["day"]), a2 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[n2];
    ValidateTemporalRoundingIncrement(r2, a2, 1 === a2);
    let f2 = GetSlot(this, i), y2 = GetSlot(this, s), I2 = GetSlot(this, l), S2 = GetSlot(this, d), g2 = GetSlot(this, m), w2 = GetSlot(this, c), D2 = GetSlot(this, h), G2 = GetSlot(this, u), v2 = GetSlot(this, T);
    return { year: f2, month: y2, day: I2, hour: S2, minute: g2, second: w2, millisecond: D2, microsecond: G2, nanosecond: v2 } = RoundISODateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, r2, n2, o2), CreateTemporalDateTime(f2, y2, I2, S2, g2, w2, D2, G2, v2, GetSlot(this, p));
  }
  equals(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDateTime(e2);
    for (const e3 of [i, s, l, d, m, c, h, u, T]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = ToTemporalRoundingMode(t2, "trunc"), a2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === a2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: i2, unit: s2, increment: l2 } = ToSecondsStringPrecisionRecord(a2, o2);
    return TemporalDateTimeToString(this, i2, r2, { unit: s2, increment: l2, roundingMode: n2 });
  }
  toJSON() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime");
  }
  toZonedDateTime(e2, t2) {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(r2, this, ToTemporalDisambiguation(GetOptionsObject(t2))), n), r2, GetSlot(this, p));
  }
  toPlainDate() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  toPlainTime() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(this);
  }
  getISOFields() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoHour: GetSlot(this, d), isoMicrosecond: GetSlot(this, u), isoMillisecond: GetSlot(this, h), isoMinute: GetSlot(this, m), isoMonth: GetSlot(this, s), isoNanosecond: GetSlot(this, T), isoSecond: GetSlot(this, c), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalDateTime(e2) ? (ToTemporalOverflow(r2), CreateTemporalDateTime(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T), GetSlot(e2, p))) : ToTemporalDateTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalDateTime(e2), o2 = ToTemporalDateTime(t2);
    for (const e3 of [i, s, l, d, m, c, h, u, T]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2)
        return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainDateTime, "Temporal.PlainDateTime");
var Duration = class _Duration {
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0, i2 = 0, s2 = 0, l2 = 0, d2 = 0) {
    const m2 = void 0 === e2 ? 0 : ToIntegerIfIntegral(e2), c2 = void 0 === t2 ? 0 : ToIntegerIfIntegral(t2), h2 = void 0 === r2 ? 0 : ToIntegerIfIntegral(r2), u2 = void 0 === o2 ? 0 : ToIntegerIfIntegral(o2), T2 = void 0 === n2 ? 0 : ToIntegerIfIntegral(n2), p2 = void 0 === a2 ? 0 : ToIntegerIfIntegral(a2), f2 = void 0 === i2 ? 0 : ToIntegerIfIntegral(i2), y2 = void 0 === s2 ? 0 : ToIntegerIfIntegral(s2), I2 = void 0 === l2 ? 0 : ToIntegerIfIntegral(l2), S2 = void 0 === d2 ? 0 : ToIntegerIfIntegral(d2);
    RejectDuration(m2, c2, h2, u2, T2, p2, f2, y2, I2, S2), N(this), SetSlot(this, w, m2), SetSlot(this, D, c2), SetSlot(this, G, h2), SetSlot(this, v, u2), SetSlot(this, C, T2), SetSlot(this, O, p2), SetSlot(this, b, f2), SetSlot(this, E, y2), SetSlot(this, M, I2), SetSlot(this, R, S2);
  }
  get years() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, w);
  }
  get months() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, D);
  }
  get weeks() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, G);
  }
  get days() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, v);
  }
  get hours() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, C);
  }
  get minutes() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, O);
  }
  get seconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, b);
  }
  get milliseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, E);
  }
  get microseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, M);
  }
  get nanoseconds() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, R);
  }
  get sign() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  get blank() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return 0 === DurationSign(GetSlot(this, w), GetSlot(this, D), GetSlot(this, G), GetSlot(this, v), GetSlot(this, C), GetSlot(this, O), GetSlot(this, b), GetSlot(this, E), GetSlot(this, M), GetSlot(this, R));
  }
  with(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    const t2 = PrepareTemporalFields(e2, ["days", "hours", "microseconds", "milliseconds", "minutes", "months", "nanoseconds", "seconds", "weeks", "years"], "partial"), { years: r2 = GetSlot(this, w), months: o2 = GetSlot(this, D), weeks: n2 = GetSlot(this, G), days: a2 = GetSlot(this, v), hours: i2 = GetSlot(this, C), minutes: s2 = GetSlot(this, O), seconds: l2 = GetSlot(this, b), milliseconds: d2 = GetSlot(this, E), microseconds: m2 = GetSlot(this, M), nanoseconds: c2 = GetSlot(this, R) } = t2;
    return new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  negated() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return CreateNegatedTemporalDuration(this);
  }
  abs() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return new _Duration(Math.abs(GetSlot(this, w)), Math.abs(GetSlot(this, D)), Math.abs(GetSlot(this, G)), Math.abs(GetSlot(this, v)), Math.abs(GetSlot(this, C)), Math.abs(GetSlot(this, O)), Math.abs(GetSlot(this, b)), Math.abs(GetSlot(this, E)), Math.abs(GetSlot(this, M)), Math.abs(GetSlot(this, R)));
  }
  add(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromDuration("subtract", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    if (void 0 === t2)
      throw new TypeError("options parameter is required");
    let r2 = GetSlot(this, w), o2 = GetSlot(this, D), n2 = GetSlot(this, G), a2 = GetSlot(this, v), i2 = GetSlot(this, C), s2 = GetSlot(this, O), l2 = GetSlot(this, b), d2 = GetSlot(this, E), m2 = GetSlot(this, M), c2 = GetSlot(this, R), h2 = DefaultTemporalLargestUnit(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
    const u2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2);
    let T2 = GetTemporalUnit(u2, "largestUnit", "datetime", void 0, ["auto"]), f2 = ToRelativeTemporalObject(u2);
    const y2 = ToTemporalRoundingIncrement(u2), I2 = ToTemporalRoundingMode(u2, "halfExpand");
    let S2 = GetTemporalUnit(u2, "smallestUnit", "datetime", void 0), g2 = true;
    S2 || (g2 = false, S2 = "nanosecond"), h2 = LargerOfTwoTemporalUnits(h2, S2);
    let F2 = true;
    if (T2 || (F2 = false, T2 = h2), "auto" === T2 && (T2 = h2), !g2 && !F2)
      throw new RangeError("at least one of smallestUnit or largestUnit is required");
    if (LargerOfTwoTemporalUnits(T2, S2) !== T2)
      throw new RangeError(`largestUnit ${T2} cannot be smaller than smallestUnit ${S2}`);
    const Y2 = { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[S2];
    return void 0 !== Y2 && ValidateTemporalRoundingIncrement(y2, Y2, false), { years: r2, months: o2, weeks: n2, days: a2 } = UnbalanceDurationRelative(r2, o2, n2, a2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = RoundDuration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { years: r2, months: o2, weeks: n2, days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = AdjustRoundedDurationDays(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2, y2, S2, I2, f2), { days: a2, hours: i2, minutes: s2, seconds: l2, milliseconds: d2, microseconds: m2, nanoseconds: c2 } = BalanceDuration(a2, i2, s2, l2, d2, m2, c2, T2, f2), { years: r2, months: o2, weeks: n2, days: a2 } = function BalanceDurationRelative(t3, r3, o3, n3, a3, i3) {
      const s3 = GetIntrinsic("%Temporal.Duration%"), l3 = DurationSign(t3, r3, o3, n3, 0, 0, 0, 0, 0, 0);
      if (0 === l3)
        return { years: t3, months: r3, weeks: o3, days: n3 };
      const d3 = import_jsbi.default.BigInt(l3);
      let m3, c3, h3 = import_jsbi.default.BigInt(t3), u3 = import_jsbi.default.BigInt(r3), T3 = import_jsbi.default.BigInt(o3), f3 = import_jsbi.default.BigInt(n3);
      i3 && (c3 = ToTemporalDate(i3), m3 = GetSlot(c3, p));
      const y3 = new s3(l3), I3 = new s3(0, l3), S3 = new s3(0, 0, l3);
      switch (a3) {
        case "year": {
          if (!m3)
            throw new RangeError("a starting point is required for years balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4, n4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(o4))); )
            f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(o4)), h3 = import_jsbi.default.add(h3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, y3, t4);
          for ({ relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(n4))); )
            f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(n4)), u3 = import_jsbi.default.add(u3, d3), c3 = r4, { relativeTo: r4, days: n4 } = MoveRelativeDate(m3, c3, I3, t4);
          r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
          const a4 = "string" != typeof m3 ? GetMethod(m3, "dateUntil") : void 0, i4 = Te(null);
          i4.largestUnit = "month";
          let s4 = CalendarDateUntil(m3, c3, r4, i4, a4), l4 = GetSlot(s4, D);
          for (; import_jsbi.default.greaterThanOrEqual(abs(u3), import_jsbi.default.BigInt(ae(l4))); ) {
            u3 = import_jsbi.default.subtract(u3, import_jsbi.default.BigInt(l4)), h3 = import_jsbi.default.add(h3, d3), c3 = r4, r4 = CalendarDateAdd(m3, c3, y3, void 0, t4);
            const o5 = Te(null);
            o5.largestUnit = "month", s4 = CalendarDateUntil(m3, c3, r4, o5, a4), l4 = GetSlot(s4, D);
          }
          break;
        }
        case "month": {
          if (!m3)
            throw new RangeError("a starting point is required for months balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(o4))); )
            f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(o4)), u3 = import_jsbi.default.add(u3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, I3, t4);
          break;
        }
        case "week": {
          if (!m3)
            throw new RangeError("a starting point is required for weeks balancing");
          const t4 = "string" != typeof m3 ? GetMethod(m3, "dateAdd") : void 0;
          let r4, o4;
          for ({ relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4); import_jsbi.default.greaterThanOrEqual(abs(f3), import_jsbi.default.BigInt(ae(o4))); )
            f3 = import_jsbi.default.subtract(f3, import_jsbi.default.BigInt(o4)), T3 = import_jsbi.default.add(T3, d3), c3 = r4, { relativeTo: r4, days: o4 } = MoveRelativeDate(m3, c3, S3, t4);
          break;
        }
      }
      return { years: import_jsbi.default.toNumber(h3), months: import_jsbi.default.toNumber(u3), weeks: import_jsbi.default.toNumber(T3), days: import_jsbi.default.toNumber(f3) };
    }(r2, o2, n2, a2, T2, f2), new _Duration(r2, o2, n2, a2, i2, s2, l2, d2, m2, c2);
  }
  total(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    let t2 = GetSlot(this, w), r2 = GetSlot(this, D), o2 = GetSlot(this, G), n2 = GetSlot(this, v), a2 = GetSlot(this, C), i2 = GetSlot(this, O), s2 = GetSlot(this, b), l2 = GetSlot(this, E), d2 = GetSlot(this, M), m2 = GetSlot(this, R);
    if (void 0 === e2)
      throw new TypeError("options argument is required");
    const c2 = "string" == typeof e2 ? CreateOnePropObject("unit", e2) : GetOptionsObject(e2), h2 = ToRelativeTemporalObject(c2), u2 = GetTemporalUnit(c2, "unit", "datetime", He);
    let T2;
    ({ years: t2, months: r2, weeks: o2, days: n2 } = UnbalanceDurationRelative(t2, r2, o2, n2, u2, h2)), IsTemporalZonedDateTime(h2) && (T2 = MoveRelativeZonedDateTime(h2, t2, r2, o2, 0));
    let p2 = BalancePossiblyInfiniteDuration(n2, a2, i2, s2, l2, d2, m2, u2, T2);
    if ("positive overflow" === p2)
      return 1 / 0;
    if ("negative overflow" === p2)
      return -1 / 0;
    ({ days: n2, hours: a2, minutes: i2, seconds: s2, milliseconds: l2, microseconds: d2, nanoseconds: m2 } = p2);
    const { total: f2 } = RoundDuration(t2, r2, o2, n2, a2, i2, s2, l2, d2, m2, 1, u2, "trunc", h2);
    return f2;
  }
  toString(e2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2 || "minute" === n2)
      throw new RangeError('smallestUnit must be a time unit other than "hours" or "minutes"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalDurationToString(this, a2, { unit: i2, increment: s2, roundingMode: o2 });
  }
  toJSON() {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return TemporalDurationToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalDuration(this))
      throw new TypeError("invalid receiver");
    return "undefined" != typeof Intl && void 0 !== Intl.DurationFormat ? new Intl.DurationFormat(e2, t2).format(this) : (console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."), TemporalDurationToString(this));
  }
  valueOf() {
    throw new TypeError("use compare() to compare Temporal.Duration");
  }
  static from(e2) {
    return IsTemporalDuration(e2) ? new _Duration(GetSlot(e2, w), GetSlot(e2, D), GetSlot(e2, G), GetSlot(e2, v), GetSlot(e2, C), GetSlot(e2, O), GetSlot(e2, b), GetSlot(e2, E), GetSlot(e2, M), GetSlot(e2, R)) : ToTemporalDuration(e2);
  }
  static compare(t2, r2, o2) {
    const n2 = ToTemporalDuration(t2), a2 = ToTemporalDuration(r2), i2 = ToRelativeTemporalObject(GetOptionsObject(o2)), s2 = GetSlot(n2, w), l2 = GetSlot(n2, D), d2 = GetSlot(n2, G);
    let m2 = GetSlot(n2, v);
    const c2 = GetSlot(n2, C), h2 = GetSlot(n2, O), u2 = GetSlot(n2, b), T2 = GetSlot(n2, E), p2 = GetSlot(n2, M);
    let f2 = GetSlot(n2, R);
    const y2 = GetSlot(a2, w), I2 = GetSlot(a2, D), S2 = GetSlot(a2, G);
    let g2 = GetSlot(a2, v);
    const F2 = GetSlot(a2, C), Y2 = GetSlot(a2, O), P2 = GetSlot(a2, b), Z2 = GetSlot(a2, E), B2 = GetSlot(a2, M);
    let N2 = GetSlot(a2, R);
    const j2 = CalculateOffsetShift(i2, s2, l2, d2, m2), $2 = CalculateOffsetShift(i2, y2, I2, S2, g2);
    0 === s2 && 0 === y2 && 0 === l2 && 0 === I2 && 0 === d2 && 0 === S2 || ({ days: m2 } = UnbalanceDurationRelative(s2, l2, d2, m2, "day", i2), { days: g2 } = UnbalanceDurationRelative(y2, I2, S2, g2, "day", i2));
    const k2 = TotalDurationNanoseconds(m2, c2, h2, u2, T2, p2, f2, j2), U2 = TotalDurationNanoseconds(g2, F2, Y2, P2, Z2, B2, N2, $2);
    return ComparisonResult(import_jsbi.default.toNumber(import_jsbi.default.subtract(k2, U2)));
  }
};
MakeIntrinsicClass(Duration, "Temporal.Duration");
var bt = Object.create;
var PlainMonthDay = class {
  constructor(e2, t2, r2 = "iso8601", o2 = 1972) {
    CreateTemporalMonthDaySlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get monthCode() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get day() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  with(e2, t2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["day", "month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarMonthDayFromFields(o2, a2, r2);
  }
  equals(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalMonthDay(e2);
    for (const e3 of [s, l, i]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return TemporalMonthDayToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use equals() to compare Temporal.PlainMonthDay");
  }
  toPlainDate(e2) {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, ["day", "monthCode"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["year"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = bt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalMonthDay(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalMonthDay(e2) ? (ToTemporalOverflow(r2), CreateTemporalMonthDay(GetSlot(e2, s), GetSlot(e2, l), GetSlot(e2, p), GetSlot(e2, i))) : ToTemporalMonthDay(e2, r2);
  }
};
MakeIntrinsicClass(PlainMonthDay, "Temporal.PlainMonthDay");
var instant = () => new (GetIntrinsic("%Temporal.Instant%"))(Ve());
var plainDateTime = (e2, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e2);
  return GetPlainDateTimeFor(r2, instant(), o2);
};
var plainDateTimeISO = (e2 = DefaultTimeZone()) => GetPlainDateTimeFor(ToTemporalTimeZoneSlotValue(e2), instant(), "iso8601");
var zonedDateTime = (e2, t2 = DefaultTimeZone()) => {
  const r2 = ToTemporalTimeZoneSlotValue(t2), o2 = ToTemporalCalendarSlotValue(e2);
  return CreateTemporalZonedDateTime(Ve(), r2, o2);
};
var Et = { instant, plainDateTime, plainDateTimeISO, plainDate: (e2, t2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTime(e2, t2)), plainDateISO: (e2 = DefaultTimeZone()) => TemporalDateTimeToDate(plainDateTimeISO(e2)), plainTimeISO: (e2 = DefaultTimeZone()) => TemporalDateTimeToTime(plainDateTimeISO(e2)), timeZoneId: () => DefaultTimeZone(), zonedDateTime, zonedDateTimeISO: (e2 = DefaultTimeZone()) => zonedDateTime("iso8601", e2), [Symbol.toStringTag]: "Temporal.Now" };
Object.defineProperty(Et, Symbol.toStringTag, { value: "Temporal.Now", writable: false, enumerable: false, configurable: true });
var Mt = Object.assign;
function TemporalTimeToString(e2, t2, r2) {
  let o2 = GetSlot(e2, d), n2 = GetSlot(e2, m), a2 = GetSlot(e2, c), i2 = GetSlot(e2, h), s2 = GetSlot(e2, u), l2 = GetSlot(e2, T);
  if (r2) {
    const { unit: e3, increment: t3, roundingMode: d2 } = r2;
    ({ hour: o2, minute: n2, second: a2, millisecond: i2, microsecond: s2, nanosecond: l2 } = RoundTime(o2, n2, a2, i2, s2, l2, t3, e3, d2));
  }
  return `${ISODateTimePartString(o2)}:${ISODateTimePartString(n2)}${FormatSecondsStringPart(a2, i2, s2, l2, t2)}`;
}
var PlainTime = class _PlainTime {
  constructor(e2 = 0, t2 = 0, r2 = 0, o2 = 0, n2 = 0, a2 = 0) {
    const i2 = void 0 === e2 ? 0 : ToIntegerWithTruncation(e2), s2 = void 0 === t2 ? 0 : ToIntegerWithTruncation(t2), l2 = void 0 === r2 ? 0 : ToIntegerWithTruncation(r2), p2 = void 0 === o2 ? 0 : ToIntegerWithTruncation(o2), f2 = void 0 === n2 ? 0 : ToIntegerWithTruncation(n2), y2 = void 0 === a2 ? 0 : ToIntegerWithTruncation(a2);
    RejectTime(i2, s2, l2, p2, f2, y2), N(this), SetSlot(this, d, i2), SetSlot(this, m, s2), SetSlot(this, c, l2), SetSlot(this, h, p2), SetSlot(this, u, f2), SetSlot(this, T, y2);
  }
  get hour() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, d);
  }
  get minute() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, m);
  }
  get second() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, c);
  }
  get millisecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, h);
  }
  get microsecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, u);
  }
  get nanosecond() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, T);
  }
  with(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = ToTemporalOverflow(GetOptionsObject(t2)), o2 = ToTemporalTimeRecord(e2, "partial"), n2 = ToTemporalTimeRecord(this);
    let { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = Mt(n2, o2);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: d2, nanosecond: m2 } = RegulateTime(a2, i2, s2, l2, d2, m2, r2), new _PlainTime(a2, i2, s2, l2, d2, m2);
  }
  add(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("add", this, e2);
  }
  subtract(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainTime("subtract", this, e2);
  }
  until(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainTime("since", this, e2, t2);
  }
  round(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === e2)
      throw new TypeError("options parameter is required");
    const t2 = "string" == typeof e2 ? CreateOnePropObject("smallestUnit", e2) : GetOptionsObject(e2), r2 = ToTemporalRoundingIncrement(t2), o2 = ToTemporalRoundingMode(t2, "halfExpand"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", He);
    ValidateTemporalRoundingIncrement(r2, { hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[n2], false);
    let a2 = GetSlot(this, d), i2 = GetSlot(this, m), s2 = GetSlot(this, c), l2 = GetSlot(this, h), p2 = GetSlot(this, u), f2 = GetSlot(this, T);
    return { hour: a2, minute: i2, second: s2, millisecond: l2, microsecond: p2, nanosecond: f2 } = RoundTime(a2, i2, s2, l2, p2, f2, r2, n2, o2), new _PlainTime(a2, i2, s2, l2, p2, f2);
  }
  equals(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTime(e2);
    for (const e3 of [d, m, c, h, u, T]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return true;
  }
  toString(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToFractionalSecondDigits(t2), o2 = ToTemporalRoundingMode(t2, "trunc"), n2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === n2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const { precision: a2, unit: i2, increment: s2 } = ToSecondsStringPrecisionRecord(n2, r2);
    return TemporalTimeToString(this, a2, { unit: i2, increment: s2, roundingMode: o2 });
  }
  toJSON() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return TemporalTimeToString(this, "auto");
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainTime");
  }
  toPlainDateTime(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), n2 = GetSlot(t2, l), a2 = GetSlot(t2, p);
    return CreateTemporalDateTime(r2, o2, n2, GetSlot(this, d), GetSlot(this, m), GetSlot(this, c), GetSlot(this, h), GetSlot(this, u), GetSlot(this, T), a2);
  }
  toZonedDateTime(e2) {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    const t2 = e2.plainDate;
    if (void 0 === t2)
      throw new TypeError("missing date property");
    const r2 = ToTemporalDate(t2), o2 = e2.timeZone;
    if (void 0 === o2)
      throw new TypeError("missing timeZone property");
    const a2 = ToTemporalTimeZoneSlotValue(o2), f2 = GetSlot(r2, i), y2 = GetSlot(r2, s), I2 = GetSlot(r2, l), S2 = GetSlot(r2, p), g2 = GetSlot(this, d), w2 = GetSlot(this, m), D2 = GetSlot(this, c), G2 = GetSlot(this, h), v2 = GetSlot(this, u), C2 = GetSlot(this, T);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(f2, y2, I2, g2, w2, D2, G2, v2, C2, S2), "compatible"), n), a2, S2);
  }
  getISOFields() {
    if (!IsTemporalTime(this))
      throw new TypeError("invalid receiver");
    return { isoHour: GetSlot(this, d), isoMicrosecond: GetSlot(this, u), isoMillisecond: GetSlot(this, h), isoMinute: GetSlot(this, m), isoNanosecond: GetSlot(this, T), isoSecond: GetSlot(this, c) };
  }
  static from(e2, t2) {
    const r2 = ToTemporalOverflow(GetOptionsObject(t2));
    return IsTemporalTime(e2) ? new _PlainTime(GetSlot(e2, d), GetSlot(e2, m), GetSlot(e2, c), GetSlot(e2, h), GetSlot(e2, u), GetSlot(e2, T)) : ToTemporalTime(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalTime(e2), o2 = ToTemporalTime(t2);
    for (const e3 of [d, m, c, h, u, T]) {
      const t3 = GetSlot(r2, e3), n2 = GetSlot(o2, e3);
      if (t3 !== n2)
        return ComparisonResult(t3 - n2);
    }
    return 0;
  }
};
MakeIntrinsicClass(PlainTime, "Temporal.PlainTime");
var TimeZone = class {
  constructor(e2) {
    if (arguments.length < 1)
      throw new RangeError("missing argument: identifier is required");
    const t2 = GetCanonicalTimeZoneIdentifier(e2);
    N(this), SetSlot(this, a, t2);
  }
  get id() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  getOffsetNanosecondsFor(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    return IsTimeZoneOffsetString(r2) ? ParseTimeZoneOffsetString(r2) : GetNamedTimeZoneOffsetNanoseconds(r2, GetSlot(t2, n));
  }
  getOffsetStringFor(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetOffsetStringFor(this, ToTemporalInstant(e2));
  }
  getPlainDateTimeFor(e2, t2 = "iso8601") {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetPlainDateTimeFor(this, ToTemporalInstant(e2), ToTemporalCalendarSlotValue(t2));
  }
  getInstantFor(e2, t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetInstantFor(this, ToTemporalDateTime(e2), ToTemporalDisambiguation(GetOptionsObject(t2)));
  }
  getPossibleInstantsFor(t2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalDateTime(t2), o2 = GetIntrinsic("%Temporal.Instant%"), n2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(n2)) {
      const t3 = GetUTCEpochNanoseconds(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
      if (null === t3)
        throw new RangeError("DateTime outside of supported range");
      const a2 = ParseTimeZoneOffsetString(n2);
      return [new o2(import_jsbi.default.subtract(t3, import_jsbi.default.BigInt(a2)))];
    }
    const p2 = function GetNamedTimeZoneEpochNanoseconds(t3, r3, o3, n3, a2, i2, s2, l2, d2, m2) {
      const c2 = GetUTCEpochNanoseconds(r3, o3, n3, a2, i2, s2, l2, d2, m2);
      if (null === c2)
        throw new RangeError("DateTime outside of supported range");
      let h2 = import_jsbi.default.subtract(c2, Ee);
      import_jsbi.default.lessThan(h2, Me) && (h2 = c2);
      let u2 = import_jsbi.default.add(c2, Ee);
      import_jsbi.default.greaterThan(u2, Re) && (u2 = c2);
      const T2 = GetNamedTimeZoneOffsetNanoseconds(t3, h2), p3 = GetNamedTimeZoneOffsetNanoseconds(t3, u2);
      return (T2 === p3 ? [T2] : [T2, p3]).map((h3) => {
        const u3 = import_jsbi.default.subtract(c2, import_jsbi.default.BigInt(h3)), T3 = GetNamedTimeZoneDateTimeParts(t3, u3);
        if (r3 === T3.year && o3 === T3.month && n3 === T3.day && a2 === T3.hour && i2 === T3.minute && s2 === T3.second && l2 === T3.millisecond && d2 === T3.microsecond && m2 === T3.nanosecond)
          return u3;
      }).filter((e2) => void 0 !== e2);
    }(n2, GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(r2, d), GetSlot(r2, m), GetSlot(r2, c), GetSlot(r2, h), GetSlot(r2, u), GetSlot(r2, T));
    return p2.map((e2) => new o2(e2));
  }
  getNextTransition(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2)
      return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZoneNextTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  getPreviousTransition(e2) {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalInstant(e2), r2 = GetSlot(this, a);
    if (IsTimeZoneOffsetString(r2) || "UTC" === r2)
      return null;
    let o2 = GetSlot(t2, n);
    const i2 = GetIntrinsic("%Temporal.Instant%");
    return o2 = GetNamedTimeZonePreviousTransition(r2, o2), null === o2 ? null : new i2(o2);
  }
  toString() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  toJSON() {
    if (!IsTemporalTimeZone(this))
      throw new TypeError("invalid receiver");
    return GetSlot(this, a);
  }
  static from(e2) {
    return ToTemporalTimeZoneObject(ToTemporalTimeZoneSlotValue(e2));
  }
};
MakeIntrinsicClass(TimeZone, "Temporal.TimeZone"), DefineIntrinsic("Temporal.TimeZone.prototype.getOffsetNanosecondsFor", TimeZone.prototype.getOffsetNanosecondsFor), DefineIntrinsic("Temporal.TimeZone.prototype.getPossibleInstantsFor", TimeZone.prototype.getPossibleInstantsFor);
var Rt = Object.create;
var PlainYearMonth = class {
  constructor(e2, t2, r2 = "iso8601", o2 = 1) {
    CreateTemporalYearMonthSlots(this, ToIntegerWithTruncation(e2), ToIntegerWithTruncation(t2), ToTemporalCalendarSlotValue(r2), ToIntegerWithTruncation(o2));
  }
  get year() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), this);
  }
  get month() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), this);
  }
  get monthCode() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), this);
  }
  get calendarId() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get era() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), this);
  }
  get eraYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), this);
  }
  get daysInMonth() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), this);
  }
  get daysInYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), this);
  }
  get monthsInYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), this);
  }
  get inLeapYear() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), this);
  }
  with(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid argument");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p), n2 = CalendarFields(o2, ["month", "monthCode", "year"]);
    let a2 = PrepareTemporalFields(this, n2, []);
    return a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, []), CalendarYearMonthFromFields(o2, a2, r2);
  }
  add(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromPlainYearMonth("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalPlainYearMonth("since", this, e2, t2);
  }
  equals(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalYearMonth(e2);
    for (const e3 of [i, s, l]) {
      if (GetSlot(this, e3) !== GetSlot(t2, e3))
        return false;
    }
    return CalendarEquals(GetSlot(this, p), GetSlot(t2, p));
  }
  toString(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this, ToCalendarNameOption(GetOptionsObject(e2)));
  }
  toJSON() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return TemporalYearMonthToString(this);
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return new ht(e2, t2).format(this);
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth");
  }
  toPlainDate(e2) {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("argument should be an object");
    const t2 = GetSlot(this, p), r2 = CalendarFields(t2, ["monthCode", "year"]), o2 = PrepareTemporalFields(this, r2, []), n2 = CalendarFields(t2, ["day"]);
    let a2 = CalendarMergeFields(t2, o2, PrepareTemporalFields(e2, n2, []));
    a2 = PrepareTemporalFields(a2, [.../* @__PURE__ */ new Set([...r2, ...n2])], []);
    const i2 = Rt(null);
    return i2.overflow = "reject", CalendarDateFromFields(t2, a2, i2);
  }
  getISOFields() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return { calendar: GetSlot(this, p), isoDay: GetSlot(this, l), isoMonth: GetSlot(this, s), isoYear: GetSlot(this, i) };
  }
  getCalendar() {
    if (!IsTemporalYearMonth(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalYearMonth(e2) ? (ToTemporalOverflow(r2), CreateTemporalYearMonth(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, p), GetSlot(e2, l))) : ToTemporalYearMonth(e2, r2);
  }
  static compare(e2, t2) {
    const r2 = ToTemporalYearMonth(e2), o2 = ToTemporalYearMonth(t2);
    return CompareISODate(GetSlot(r2, i), GetSlot(r2, s), GetSlot(r2, l), GetSlot(o2, i), GetSlot(o2, s), GetSlot(o2, l));
  }
};
MakeIntrinsicClass(PlainYearMonth, "Temporal.PlainYearMonth");
var Ft = ht.prototype.resolvedOptions;
var Yt = Object.create;
var ZonedDateTime = class {
  constructor(e2, t2, r2 = "iso8601") {
    if (arguments.length < 1)
      throw new TypeError("missing argument: epochNanoseconds is required");
    CreateTemporalZonedDateTimeSlots(this, ToBigInt(e2), ToTemporalTimeZoneSlotValue(t2), ToTemporalCalendarSlotValue(r2));
  }
  get calendarId() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarIdentifier(GetSlot(this, p));
  }
  get timeZoneId() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneIdentifier(GetSlot(this, g));
  }
  get year() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYear(GetSlot(this, p), dateTime(this));
  }
  get month() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonth(GetSlot(this, p), dateTime(this));
  }
  get monthCode() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthCode(GetSlot(this, p), dateTime(this));
  }
  get day() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDay(GetSlot(this, p), dateTime(this));
  }
  get hour() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), d);
  }
  get minute() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), m);
  }
  get second() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), c);
  }
  get millisecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), h);
  }
  get microsecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), u);
  }
  get nanosecond() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetSlot(dateTime(this), T);
  }
  get era() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEra(GetSlot(this, p), dateTime(this));
  }
  get eraYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarEraYear(GetSlot(this, p), dateTime(this));
  }
  get epochSeconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, ve));
  }
  get epochMilliseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetSlot(this, n);
    return import_jsbi.default.toNumber(BigIntFloorDiv(t2, Ge));
  }
  get epochMicroseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(BigIntFloorDiv(GetSlot(this, n), De));
  }
  get epochNanoseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToBigIntExternal(GetSlot(this, n));
  }
  get dayOfWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfWeek(GetSlot(this, p), dateTime(this));
  }
  get dayOfYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDayOfYear(GetSlot(this, p), dateTime(this));
  }
  get weekOfYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarWeekOfYear(GetSlot(this, p), dateTime(this));
  }
  get yearOfWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarYearOfWeek(GetSlot(this, p), dateTime(this));
  }
  get hoursInDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = dateTime(this), r2 = GetIntrinsic("%Temporal.PlainDateTime%"), o2 = GetSlot(t2, i), a2 = GetSlot(t2, s), d2 = GetSlot(t2, l), m2 = new r2(o2, a2, d2, 0, 0, 0, 0, 0, 0), c2 = AddISODate(o2, a2, d2, 0, 0, 0, 1, "reject"), h2 = new r2(c2.year, c2.month, c2.day, 0, 0, 0, 0, 0, 0), u2 = GetSlot(this, g), T2 = GetSlot(GetInstantFor(u2, m2, "compatible"), n), p2 = GetSlot(GetInstantFor(u2, h2, "compatible"), n);
    return BigIntDivideToNumber(import_jsbi.default.subtract(p2, T2), Oe);
  }
  get daysInWeek() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInWeek(GetSlot(this, p), dateTime(this));
  }
  get daysInMonth() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInMonth(GetSlot(this, p), dateTime(this));
  }
  get daysInYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarDaysInYear(GetSlot(this, p), dateTime(this));
  }
  get monthsInYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarMonthsInYear(GetSlot(this, p), dateTime(this));
  }
  get inLeapYear() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return CalendarInLeapYear(GetSlot(this, p), dateTime(this));
  }
  get offset() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetOffsetStringFor(GetSlot(this, g), GetSlot(this, S));
  }
  get offsetNanoseconds() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return GetOffsetNanosecondsFor(GetSlot(this, g), GetSlot(this, S));
  }
  with(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    if (!IsObject(e2))
      throw new TypeError("invalid zoned-date-time-like");
    RejectTemporalLikeObject(e2);
    const r2 = GetOptionsObject(t2), o2 = GetSlot(this, p);
    let n2 = CalendarFields(o2, ["day", "hour", "microsecond", "millisecond", "minute", "month", "monthCode", "nanosecond", "second", "year"]);
    n2.push("offset");
    let a2 = PrepareTemporalFields(this, n2, ["offset"]);
    a2 = CalendarMergeFields(o2, a2, PrepareTemporalFields(e2, n2, "partial")), a2 = PrepareTemporalFields(a2, n2, ["offset"]);
    const i2 = ToTemporalDisambiguation(r2), s2 = ToTemporalOffset(r2, "prefer");
    let { year: l2, month: d2, day: m2, hour: c2, minute: h2, second: u2, millisecond: T2, microsecond: f2, nanosecond: y2 } = InterpretTemporalDateTimeFields(o2, a2, r2);
    const I2 = ParseTimeZoneOffsetString(a2.offset), S2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(l2, d2, m2, c2, h2, u2, T2, f2, y2, "option", I2, S2, i2, s2, false), S2, o2);
  }
  withPlainDate(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalDate(e2), r2 = GetSlot(t2, i), o2 = GetSlot(t2, s), a2 = GetSlot(t2, l);
    let f2 = GetSlot(t2, p);
    const y2 = dateTime(this), I2 = GetSlot(y2, d), S2 = GetSlot(y2, m), w2 = GetSlot(y2, c), D2 = GetSlot(y2, h), G2 = GetSlot(y2, u), v2 = GetSlot(y2, T);
    f2 = ConsolidateCalendars(GetSlot(this, p), f2);
    const C2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(C2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(r2, o2, a2, I2, S2, w2, D2, G2, v2, f2), "compatible"), n), C2, f2);
  }
  withPlainTime(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetIntrinsic("%Temporal.PlainTime%"), r2 = void 0 === e2 ? new t2() : ToTemporalTime(e2), o2 = dateTime(this), a2 = GetSlot(o2, i), f2 = GetSlot(o2, s), y2 = GetSlot(o2, l), I2 = GetSlot(this, p), S2 = GetSlot(r2, d), w2 = GetSlot(r2, m), D2 = GetSlot(r2, c), G2 = GetSlot(r2, h), v2 = GetSlot(r2, u), C2 = GetSlot(r2, T), O2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(O2, new (GetIntrinsic("%Temporal.PlainDateTime%"))(a2, f2, y2, S2, w2, D2, G2, v2, C2, I2), "compatible"), n), O2, I2);
  }
  withTimeZone(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalTimeZoneSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), t2, GetSlot(this, p));
  }
  withCalendar(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = ToTemporalCalendarSlotValue(e2);
    return CreateTemporalZonedDateTime(GetSlot(this, n), GetSlot(this, g), t2);
  }
  add(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("add", this, e2, t2);
  }
  subtract(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return AddDurationToOrSubtractDurationFromZonedDateTime("subtract", this, e2, t2);
  }
  until(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("until", this, e2, t2);
  }
  since(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return DifferenceTemporalZonedDateTime("since", this, e2, t2);
  }
  round(t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    if (void 0 === t2)
      throw new TypeError("options parameter is required");
    const r2 = "string" == typeof t2 ? CreateOnePropObject("smallestUnit", t2) : GetOptionsObject(t2), o2 = ToTemporalRoundingIncrement(r2), a2 = ToTemporalRoundingMode(r2, "halfExpand"), f2 = GetTemporalUnit(r2, "smallestUnit", "time", He, ["day"]), y2 = { day: 1, hour: 24, minute: 60, second: 60, millisecond: 1e3, microsecond: 1e3, nanosecond: 1e3 }[f2];
    ValidateTemporalRoundingIncrement(o2, y2, 1 === y2);
    const I2 = dateTime(this);
    let w2 = GetSlot(I2, i), D2 = GetSlot(I2, s), G2 = GetSlot(I2, l), v2 = GetSlot(I2, d), C2 = GetSlot(I2, m), O2 = GetSlot(I2, c), b2 = GetSlot(I2, h), E2 = GetSlot(I2, u), M2 = GetSlot(I2, T);
    const R2 = GetIntrinsic("%Temporal.PlainDateTime%"), F2 = GetSlot(this, g), Y2 = GetSlot(this, p), P2 = GetInstantFor(F2, new R2(GetSlot(I2, i), GetSlot(I2, s), GetSlot(I2, l), 0, 0, 0, 0, 0, 0), "compatible"), Z2 = AddZonedDateTime(P2, F2, Y2, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0), B2 = import_jsbi.default.subtract(Z2, import_jsbi.default.BigInt(GetSlot(P2, n)));
    if (import_jsbi.default.lessThanOrEqual(B2, Ie))
      throw new RangeError("cannot round a ZonedDateTime in a calendar with zero or negative length days");
    ({ year: w2, month: D2, day: G2, hour: v2, minute: C2, second: O2, millisecond: b2, microsecond: E2, nanosecond: M2 } = RoundISODateTime(w2, D2, G2, v2, C2, O2, b2, E2, M2, o2, f2, a2, import_jsbi.default.toNumber(B2)));
    return CreateTemporalZonedDateTime(InterpretISODateTimeOffset(w2, D2, G2, v2, C2, O2, b2, E2, M2, "option", GetOffsetNanosecondsFor(F2, GetSlot(this, S)), F2, "compatible", "prefer", false), F2, GetSlot(this, p));
  }
  equals(t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const r2 = ToTemporalZonedDateTime(t2), o2 = GetSlot(this, n), a2 = GetSlot(r2, n);
    return !!import_jsbi.default.equal(import_jsbi.default.BigInt(o2), import_jsbi.default.BigInt(a2)) && (!!TimeZoneEquals(GetSlot(this, g), GetSlot(r2, g)) && CalendarEquals(GetSlot(this, p), GetSlot(r2, p)));
  }
  toString(e2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const t2 = GetOptionsObject(e2), r2 = ToCalendarNameOption(t2), o2 = ToFractionalSecondDigits(t2), n2 = function ToShowOffsetOption(e3) {
      return GetOption(e3, "offset", ["auto", "never"], "auto");
    }(t2), a2 = ToTemporalRoundingMode(t2, "trunc"), i2 = GetTemporalUnit(t2, "smallestUnit", "time", void 0);
    if ("hour" === i2)
      throw new RangeError('smallestUnit must be a time unit other than "hour"');
    const s2 = function ToTimeZoneNameOption(e3) {
      return GetOption(e3, "timeZoneName", ["auto", "never", "critical"], "auto");
    }(t2), { precision: l2, unit: d2, increment: m2 } = ToSecondsStringPrecisionRecord(i2, o2);
    return TemporalZonedDateTimeToString(this, l2, r2, s2, n2, { unit: d2, increment: m2, roundingMode: a2 });
  }
  toLocaleString(e2, t2) {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const r2 = GetOptionsObject(t2), o2 = Yt(null);
    if (CopyDataProperties(o2, r2, ["timeZone"]), void 0 !== r2.timeZone)
      throw new TypeError("ZonedDateTime toLocaleString does not accept a timeZone option");
    void 0 === o2.year && void 0 === o2.month && void 0 === o2.day && void 0 === o2.weekday && void 0 === o2.dateStyle && void 0 === o2.hour && void 0 === o2.minute && void 0 === o2.second && void 0 === o2.timeStyle && void 0 === o2.dayPeriod && void 0 === o2.timeZoneName && (o2.timeZoneName = "short");
    let n2 = ToTemporalTimeZoneIdentifier(GetSlot(this, g));
    if (IsTimeZoneOffsetString(n2))
      throw new RangeError("toLocaleString does not support offset string time zones");
    n2 = GetCanonicalTimeZoneIdentifier(n2), o2.timeZone = n2;
    const a2 = new ht(e2, o2), i2 = Call(Ft, a2, []).calendar, s2 = ToTemporalCalendarIdentifier(GetSlot(this, p));
    if ("iso8601" !== s2 && "iso8601" !== i2 && i2 !== s2)
      throw new RangeError(`cannot format ZonedDateTime with calendar ${s2} in locale with calendar ${i2}`);
    return a2.format(GetSlot(this, S));
  }
  toJSON() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalZonedDateTimeToString(this, "auto");
  }
  valueOf() {
    throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime");
  }
  startOfDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetIntrinsic("%Temporal.PlainDateTime%"), r2 = GetSlot(this, p), o2 = new t2(GetSlot(e2, i), GetSlot(e2, s), GetSlot(e2, l), 0, 0, 0, 0, 0, 0, r2), a2 = GetSlot(this, g);
    return CreateTemporalZonedDateTime(GetSlot(GetInstantFor(a2, o2, "compatible"), n), a2, r2);
  }
  toInstant() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return new (GetIntrinsic("%Temporal.Instant%"))(GetSlot(this, n));
  }
  toPlainDate() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToDate(dateTime(this));
  }
  toPlainTime() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return TemporalDateTimeToTime(dateTime(this));
  }
  toPlainDateTime() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return dateTime(this);
  }
  toPlainYearMonth() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarYearMonthFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["monthCode", "year"]), []));
  }
  toPlainMonthDay() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = GetSlot(this, p);
    return CalendarMonthDayFromFields(e2, PrepareTemporalFields(this, CalendarFields(e2, ["day", "monthCode"]), []));
  }
  getISOFields() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    const e2 = dateTime(this), t2 = GetSlot(this, g);
    return { calendar: GetSlot(this, p), isoDay: GetSlot(e2, l), isoHour: GetSlot(e2, d), isoMicrosecond: GetSlot(e2, u), isoMillisecond: GetSlot(e2, h), isoMinute: GetSlot(e2, m), isoMonth: GetSlot(e2, s), isoNanosecond: GetSlot(e2, T), isoSecond: GetSlot(e2, c), isoYear: GetSlot(e2, i), offset: GetOffsetStringFor(t2, GetSlot(this, S)), timeZone: t2 };
  }
  getCalendar() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalCalendarObject(GetSlot(this, p));
  }
  getTimeZone() {
    if (!IsTemporalZonedDateTime(this))
      throw new TypeError("invalid receiver");
    return ToTemporalTimeZoneObject(GetSlot(this, g));
  }
  static from(e2, t2) {
    const r2 = GetOptionsObject(t2);
    return IsTemporalZonedDateTime(e2) ? (ToTemporalDisambiguation(r2), ToTemporalOffset(r2, "reject"), ToTemporalOverflow(r2), CreateTemporalZonedDateTime(GetSlot(e2, n), GetSlot(e2, g), GetSlot(e2, p))) : ToTemporalZonedDateTime(e2, r2);
  }
  static compare(t2, r2) {
    const o2 = ToTemporalZonedDateTime(t2), a2 = ToTemporalZonedDateTime(r2), i2 = GetSlot(o2, n), s2 = GetSlot(a2, n);
    return import_jsbi.default.lessThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? -1 : import_jsbi.default.greaterThan(import_jsbi.default.BigInt(i2), import_jsbi.default.BigInt(s2)) ? 1 : 0;
  }
};
function dateTime(e2) {
  return GetPlainDateTimeFor(GetSlot(e2, g), GetSlot(e2, S), GetSlot(e2, p));
}
MakeIntrinsicClass(ZonedDateTime, "Temporal.ZonedDateTime");
var Pt = Object.freeze({ __proto__: null, Calendar, Duration, Instant, Now: Et, PlainDate, PlainDateTime, PlainMonthDay, PlainTime, PlainYearMonth, TimeZone, ZonedDateTime });
var Zt = [Instant, Calendar, PlainDate, PlainDateTime, Duration, PlainMonthDay, PlainTime, TimeZone, PlainYearMonth, ZonedDateTime];
for (const e2 of Zt) {
  const t2 = Object.getOwnPropertyDescriptor(e2, "prototype");
  (t2.configurable || t2.enumerable || t2.writable) && (t2.configurable = false, t2.enumerable = false, t2.writable = false, Object.defineProperty(e2, "prototype", t2));
}

// src/jekyll/chirpy.ts
var fs2 = __toESM(require("fs"));
var path = __toESM(require("path"));

// src/ObsidianRegex.ts
var ObsidianRegex = {
  ATTACHMENT_LINK: /!\[\[([^|\]]+)\.(\w+)\|?(\d*)x?(\d*)]](\n{0,2}(_.*_))?/g,
  EMBEDDED_LINK: /!\[\[([\w\s-]+)[#^]*([\w\s]*)]]/g,
  WIKI_LINK: /(?<!!)\[\[([^|\]]+)\|?([^|\]]*)]]/g,
  CALLOUT: /> \[!(.*)].*?\n(>.*)/ig,
  SIMPLE_FOOTNOTE: /\[\^(\d+)]/g,
  COMMENT: /%%(.*?)%%/g,
  DOUBLE_CURLY_BRACES: /{{(.*?)}}/g
};

// src/jekyll/WikiLinkConverter.ts
var WikiLinkConverter = class {
  convert(input) {
    return input.replace(ObsidianRegex.WIKI_LINK, (match, p1, p2) => p2 ? p2 : p1);
  }
};

// src/jekyll/ResourceLinkConverter.ts
var import_fs = __toESM(require("fs"));
var import_obsidian2 = require("obsidian");
var ResourceLinkConverter = class {
  constructor(fileName, resourcePath, absolutePath, attachmentsFolder, relativeResourcePath) {
    this.fileName = fileName;
    this.resourcePath = resourcePath;
    this.absolutePath = absolutePath;
    this.attachmentsFolder = attachmentsFolder;
    this.relativeResourcePath = relativeResourcePath;
  }
  convert(input) {
    const resourcePath = `${this.resourcePath}/${this.fileName}`;
    const resourceNames = extractResourceNames(input);
    if (!(resourceNames === void 0 || resourceNames.length === 0)) {
      import_fs.default.mkdirSync(resourcePath, { recursive: true });
    }
    resourceNames == null ? void 0 : resourceNames.forEach((resourceName) => {
      import_fs.default.copyFile(
        `${this.absolutePath}/${this.attachmentsFolder}/${resourceName}`,
        `${resourcePath}/${resourceName.replace(/\s/g, "-")}`,
        (err) => {
          if (err) {
            console.error(err);
            new import_obsidian2.Notice(err.message);
          }
        }
      );
    });
    const replacer = (match, contents, suffix, width, height, space, caption) => `![image](/${this.relativeResourcePath}/${this.fileName}/${contents.replace(/\s/g, "-")}.${suffix})${convertImageSize(width, height)}${convertImageCaption(caption)}`;
    return input.replace(ObsidianRegex.ATTACHMENT_LINK, replacer);
  }
};
function extractResourceNames(content) {
  const result = content.match(ObsidianRegex.ATTACHMENT_LINK);
  if (result === null) {
    return void 0;
  }
  return result.map((imageLink) => imageLink.replace(ObsidianRegex.ATTACHMENT_LINK, "$1.$2"));
}
function convertImageSize(width, height) {
  if (width === void 0 || width.length === 0) {
    return "";
  }
  if (height === void 0 || height.length === 0) {
    return `{: width="${width}" }`;
  }
  return `{: width="${width}" height="${height}" }`;
}
function convertImageCaption(caption) {
  if (caption === void 0 || caption.length === 0) {
    return "";
  }
  return `
${caption}`;
}

// src/jekyll/chirpy.ts
var import_obsidian4 = require("obsidian");

// src/jekyll/CalloutConverter.ts
var CalloutConverter = class {
  convert(input) {
    return convertCalloutSyntaxToChirpy(input);
  }
};
function convertCalloutSyntaxToChirpy(content) {
  function replacer(match, p1, p2) {
    return `${p2}
{: .prompt-${replaceKeyword(p1)}}`;
  }
  return content.replace(ObsidianRegex.CALLOUT, replacer);
}
var map = /* @__PURE__ */ new Map();
map.set("note", "info");
map.set("info", "info");
map.set("todo", "info");
map.set("example", "info");
map.set("quote", "info");
map.set("cite", "info");
map.set("success", "info");
map.set("done", "info");
map.set("check", "info");
map.set("tip", "tip");
map.set("hint", "tip");
map.set("important", "tip");
map.set("question", "tip");
map.set("help", "tip");
map.set("faq", "tip");
map.set("failure", "danger");
map.set("fail", "danger");
map.set("missing", "danger");
map.set("error", "danger");
map.set("danger", "danger");
map.set("bug", "danger");
map.set("warning", "warning");
map.set("caution", "warning");
map.set("attention", "warning");
function replaceKeyword(target) {
  return map.get(target.toLowerCase()) || "info";
}

// node_modules/js-yaml/dist/js-yaml.mjs
function isNothing(subject) {
  return typeof subject === "undefined" || subject === null;
}
function isObject(subject) {
  return typeof subject === "object" && subject !== null;
}
function toArray(sequence) {
  if (Array.isArray(sequence))
    return sequence;
  else if (isNothing(sequence))
    return [];
  return [sequence];
}
function extend(target, source) {
  var index, length, key, sourceKeys;
  if (source) {
    sourceKeys = Object.keys(source);
    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }
  return target;
}
function repeat(string, count) {
  var result = "", cycle;
  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }
  return result;
}
function isNegativeZero(number) {
  return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
}
var isNothing_1 = isNothing;
var isObject_1 = isObject;
var toArray_1 = toArray;
var repeat_1 = repeat;
var isNegativeZero_1 = isNegativeZero;
var extend_1 = extend;
var common = {
  isNothing: isNothing_1,
  isObject: isObject_1,
  toArray: toArray_1,
  repeat: repeat_1,
  isNegativeZero: isNegativeZero_1,
  extend: extend_1
};
function formatError(exception2, compact) {
  var where = "", message = exception2.reason || "(unknown reason)";
  if (!exception2.mark)
    return message;
  if (exception2.mark.name) {
    where += 'in "' + exception2.mark.name + '" ';
  }
  where += "(" + (exception2.mark.line + 1) + ":" + (exception2.mark.column + 1) + ")";
  if (!compact && exception2.mark.snippet) {
    where += "\n\n" + exception2.mark.snippet;
  }
  return message + " " + where;
}
function YAMLException$1(reason, mark) {
  Error.call(this);
  this.name = "YAMLException";
  this.reason = reason;
  this.mark = mark;
  this.message = formatError(this, false);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack || "";
  }
}
YAMLException$1.prototype = Object.create(Error.prototype);
YAMLException$1.prototype.constructor = YAMLException$1;
YAMLException$1.prototype.toString = function toString(compact) {
  return this.name + ": " + formatError(this, compact);
};
var exception = YAMLException$1;
function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
  var head = "";
  var tail = "";
  var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
  if (position - lineStart > maxHalfLength) {
    head = " ... ";
    lineStart = position - maxHalfLength + head.length;
  }
  if (lineEnd - position > maxHalfLength) {
    tail = " ...";
    lineEnd = position + maxHalfLength - tail.length;
  }
  return {
    str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
    pos: position - lineStart + head.length
    // relative position
  };
}
function padStart(string, max) {
  return common.repeat(" ", max - string.length) + string;
}
function makeSnippet(mark, options) {
  options = Object.create(options || null);
  if (!mark.buffer)
    return null;
  if (!options.maxLength)
    options.maxLength = 79;
  if (typeof options.indent !== "number")
    options.indent = 1;
  if (typeof options.linesBefore !== "number")
    options.linesBefore = 3;
  if (typeof options.linesAfter !== "number")
    options.linesAfter = 2;
  var re2 = /\r?\n|\r|\0/g;
  var lineStarts = [0];
  var lineEnds = [];
  var match;
  var foundLineNo = -1;
  while (match = re2.exec(mark.buffer)) {
    lineEnds.push(match.index);
    lineStarts.push(match.index + match[0].length);
    if (mark.position <= match.index && foundLineNo < 0) {
      foundLineNo = lineStarts.length - 2;
    }
  }
  if (foundLineNo < 0)
    foundLineNo = lineStarts.length - 1;
  var result = "", i2, line;
  var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
  var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
  for (i2 = 1; i2 <= options.linesBefore; i2++) {
    if (foundLineNo - i2 < 0)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo - i2],
      lineEnds[foundLineNo - i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i2]),
      maxLineLength
    );
    result = common.repeat(" ", options.indent) + padStart((mark.line - i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
  }
  line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
  result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
  for (i2 = 1; i2 <= options.linesAfter; i2++) {
    if (foundLineNo + i2 >= lineEnds.length)
      break;
    line = getLine(
      mark.buffer,
      lineStarts[foundLineNo + i2],
      lineEnds[foundLineNo + i2],
      mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i2]),
      maxLineLength
    );
    result += common.repeat(" ", options.indent) + padStart((mark.line + i2 + 1).toString(), lineNoLength) + " | " + line.str + "\n";
  }
  return result.replace(/\n$/, "");
}
var snippet = makeSnippet;
var TYPE_CONSTRUCTOR_OPTIONS = [
  "kind",
  "multi",
  "resolve",
  "construct",
  "instanceOf",
  "predicate",
  "represent",
  "representName",
  "defaultStyle",
  "styleAliases"
];
var YAML_NODE_KINDS = [
  "scalar",
  "sequence",
  "mapping"
];
function compileStyleAliases(map3) {
  var result = {};
  if (map3 !== null) {
    Object.keys(map3).forEach(function(style) {
      map3[style].forEach(function(alias) {
        result[String(alias)] = style;
      });
    });
  }
  return result;
}
function Type$1(tag, options) {
  options = options || {};
  Object.keys(options).forEach(function(name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });
  this.options = options;
  this.tag = tag;
  this.kind = options["kind"] || null;
  this.resolve = options["resolve"] || function() {
    return true;
  };
  this.construct = options["construct"] || function(data) {
    return data;
  };
  this.instanceOf = options["instanceOf"] || null;
  this.predicate = options["predicate"] || null;
  this.represent = options["represent"] || null;
  this.representName = options["representName"] || null;
  this.defaultStyle = options["defaultStyle"] || null;
  this.multi = options["multi"] || false;
  this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}
var type = Type$1;
function compileList(schema2, name) {
  var result = [];
  schema2[name].forEach(function(currentType) {
    var newIndex = result.length;
    result.forEach(function(previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
        newIndex = previousIndex;
      }
    });
    result[newIndex] = currentType;
  });
  return result;
}
function compileMap() {
  var result = {
    scalar: {},
    sequence: {},
    mapping: {},
    fallback: {},
    multi: {
      scalar: [],
      sequence: [],
      mapping: [],
      fallback: []
    }
  }, index, length;
  function collectType(type2) {
    if (type2.multi) {
      result.multi[type2.kind].push(type2);
      result.multi["fallback"].push(type2);
    } else {
      result[type2.kind][type2.tag] = result["fallback"][type2.tag] = type2;
    }
  }
  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}
function Schema$1(definition) {
  return this.extend(definition);
}
Schema$1.prototype.extend = function extend2(definition) {
  var implicit = [];
  var explicit = [];
  if (definition instanceof type) {
    explicit.push(definition);
  } else if (Array.isArray(definition)) {
    explicit = explicit.concat(definition);
  } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
    if (definition.implicit)
      implicit = implicit.concat(definition.implicit);
    if (definition.explicit)
      explicit = explicit.concat(definition.explicit);
  } else {
    throw new exception("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
  }
  implicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    if (type$1.loadKind && type$1.loadKind !== "scalar") {
      throw new exception("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }
    if (type$1.multi) {
      throw new exception("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
    }
  });
  explicit.forEach(function(type$1) {
    if (!(type$1 instanceof type)) {
      throw new exception("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
  });
  var result = Object.create(Schema$1.prototype);
  result.implicit = (this.implicit || []).concat(implicit);
  result.explicit = (this.explicit || []).concat(explicit);
  result.compiledImplicit = compileList(result, "implicit");
  result.compiledExplicit = compileList(result, "explicit");
  result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
  return result;
};
var schema = Schema$1;
var str = new type("tag:yaml.org,2002:str", {
  kind: "scalar",
  construct: function(data) {
    return data !== null ? data : "";
  }
});
var seq = new type("tag:yaml.org,2002:seq", {
  kind: "sequence",
  construct: function(data) {
    return data !== null ? data : [];
  }
});
var map2 = new type("tag:yaml.org,2002:map", {
  kind: "mapping",
  construct: function(data) {
    return data !== null ? data : {};
  }
});
var failsafe = new schema({
  explicit: [
    str,
    seq,
    map2
  ]
});
function resolveYamlNull(data) {
  if (data === null)
    return true;
  var max = data.length;
  return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
}
function constructYamlNull() {
  return null;
}
function isNull(object) {
  return object === null;
}
var _null = new type("tag:yaml.org,2002:null", {
  kind: "scalar",
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function() {
      return "~";
    },
    lowercase: function() {
      return "null";
    },
    uppercase: function() {
      return "NULL";
    },
    camelcase: function() {
      return "Null";
    },
    empty: function() {
      return "";
    }
  },
  defaultStyle: "lowercase"
});
function resolveYamlBoolean(data) {
  if (data === null)
    return false;
  var max = data.length;
  return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
}
function constructYamlBoolean(data) {
  return data === "true" || data === "True" || data === "TRUE";
}
function isBoolean(object) {
  return Object.prototype.toString.call(object) === "[object Boolean]";
}
var bool = new type("tag:yaml.org,2002:bool", {
  kind: "scalar",
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function(object) {
      return object ? "true" : "false";
    },
    uppercase: function(object) {
      return object ? "TRUE" : "FALSE";
    },
    camelcase: function(object) {
      return object ? "True" : "False";
    }
  },
  defaultStyle: "lowercase"
});
function isHexCode(c2) {
  return 48 <= c2 && c2 <= 57 || 65 <= c2 && c2 <= 70 || 97 <= c2 && c2 <= 102;
}
function isOctCode(c2) {
  return 48 <= c2 && c2 <= 55;
}
function isDecCode(c2) {
  return 48 <= c2 && c2 <= 57;
}
function resolveYamlInteger(data) {
  if (data === null)
    return false;
  var max = data.length, index = 0, hasDigits = false, ch;
  if (!max)
    return false;
  ch = data[index];
  if (ch === "-" || ch === "+") {
    ch = data[++index];
  }
  if (ch === "0") {
    if (index + 1 === max)
      return true;
    ch = data[++index];
    if (ch === "b") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (ch !== "0" && ch !== "1")
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "x") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isHexCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "o") {
      index++;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
  }
  if (ch === "_")
    return false;
  for (; index < max; index++) {
    ch = data[index];
    if (ch === "_")
      continue;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }
  if (!hasDigits || ch === "_")
    return false;
  return true;
}
function constructYamlInteger(data) {
  var value = data, sign = 1, ch;
  if (value.indexOf("_") !== -1) {
    value = value.replace(/_/g, "");
  }
  ch = value[0];
  if (ch === "-" || ch === "+") {
    if (ch === "-")
      sign = -1;
    value = value.slice(1);
    ch = value[0];
  }
  if (value === "0")
    return 0;
  if (ch === "0") {
    if (value[1] === "b")
      return sign * parseInt(value.slice(2), 2);
    if (value[1] === "x")
      return sign * parseInt(value.slice(2), 16);
    if (value[1] === "o")
      return sign * parseInt(value.slice(2), 8);
  }
  return sign * parseInt(value, 10);
}
function isInteger(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
}
var int = new type("tag:yaml.org,2002:int", {
  kind: "scalar",
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary: function(obj) {
      return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
    },
    octal: function(obj) {
      return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
    },
    decimal: function(obj) {
      return obj.toString(10);
    },
    /* eslint-disable max-len */
    hexadecimal: function(obj) {
      return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
    }
  },
  defaultStyle: "decimal",
  styleAliases: {
    binary: [2, "bin"],
    octal: [8, "oct"],
    decimal: [10, "dec"],
    hexadecimal: [16, "hex"]
  }
});
var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
);
function resolveYamlFloat(data) {
  if (data === null)
    return false;
  if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
  // Probably should update regexp & check speed
  data[data.length - 1] === "_") {
    return false;
  }
  return true;
}
function constructYamlFloat(data) {
  var value, sign;
  value = data.replace(/_/g, "").toLowerCase();
  sign = value[0] === "-" ? -1 : 1;
  if ("+-".indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }
  if (value === ".inf") {
    return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
  } else if (value === ".nan") {
    return NaN;
  }
  return sign * parseFloat(value, 10);
}
var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
function representYamlFloat(object, style) {
  var res;
  if (isNaN(object)) {
    switch (style) {
      case "lowercase":
        return ".nan";
      case "uppercase":
        return ".NAN";
      case "camelcase":
        return ".NaN";
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return ".inf";
      case "uppercase":
        return ".INF";
      case "camelcase":
        return ".Inf";
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case "lowercase":
        return "-.inf";
      case "uppercase":
        return "-.INF";
      case "camelcase":
        return "-.Inf";
    }
  } else if (common.isNegativeZero(object)) {
    return "-0.0";
  }
  res = object.toString(10);
  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
}
function isFloat(object) {
  return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
}
var float = new type("tag:yaml.org,2002:float", {
  kind: "scalar",
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: "lowercase"
});
var json = failsafe.extend({
  implicit: [
    _null,
    bool,
    int,
    float
  ]
});
var core = json;
var YAML_DATE_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
);
var YAML_TIMESTAMP_REGEXP = new RegExp(
  "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
);
function resolveYamlTimestamp(data) {
  if (data === null)
    return false;
  if (YAML_DATE_REGEXP.exec(data) !== null)
    return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
    return true;
  return false;
}
function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
  match = YAML_DATE_REGEXP.exec(data);
  if (match === null)
    match = YAML_TIMESTAMP_REGEXP.exec(data);
  if (match === null)
    throw new Error("Date resolve error");
  year = +match[1];
  month = +match[2] - 1;
  day = +match[3];
  if (!match[4]) {
    return new Date(Date.UTC(year, month, day));
  }
  hour = +match[4];
  minute = +match[5];
  second = +match[6];
  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) {
      fraction += "0";
    }
    fraction = +fraction;
  }
  if (match[9]) {
    tz_hour = +match[10];
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 6e4;
    if (match[9] === "-")
      delta = -delta;
  }
  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
  if (delta)
    date.setTime(date.getTime() - delta);
  return date;
}
function representYamlTimestamp(object) {
  return object.toISOString();
}
var timestamp = new type("tag:yaml.org,2002:timestamp", {
  kind: "scalar",
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});
function resolveYamlMerge(data) {
  return data === "<<" || data === null;
}
var merge = new type("tag:yaml.org,2002:merge", {
  kind: "scalar",
  resolve: resolveYamlMerge
});
var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
function resolveYamlBinary(data) {
  if (data === null)
    return false;
  var code, idx, bitlen = 0, max = data.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    code = map3.indexOf(data.charAt(idx));
    if (code > 64)
      continue;
    if (code < 0)
      return false;
    bitlen += 6;
  }
  return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
  var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map3 = BASE64_MAP, bits = 0, result = [];
  for (idx = 0; idx < max; idx++) {
    if (idx % 4 === 0 && idx) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    }
    bits = bits << 6 | map3.indexOf(input.charAt(idx));
  }
  tailbits = max % 4 * 6;
  if (tailbits === 0) {
    result.push(bits >> 16 & 255);
    result.push(bits >> 8 & 255);
    result.push(bits & 255);
  } else if (tailbits === 18) {
    result.push(bits >> 10 & 255);
    result.push(bits >> 2 & 255);
  } else if (tailbits === 12) {
    result.push(bits >> 4 & 255);
  }
  return new Uint8Array(result);
}
function representYamlBinary(object) {
  var result = "", bits = 0, idx, tail, max = object.length, map3 = BASE64_MAP;
  for (idx = 0; idx < max; idx++) {
    if (idx % 3 === 0 && idx) {
      result += map3[bits >> 18 & 63];
      result += map3[bits >> 12 & 63];
      result += map3[bits >> 6 & 63];
      result += map3[bits & 63];
    }
    bits = (bits << 8) + object[idx];
  }
  tail = max % 3;
  if (tail === 0) {
    result += map3[bits >> 18 & 63];
    result += map3[bits >> 12 & 63];
    result += map3[bits >> 6 & 63];
    result += map3[bits & 63];
  } else if (tail === 2) {
    result += map3[bits >> 10 & 63];
    result += map3[bits >> 4 & 63];
    result += map3[bits << 2 & 63];
    result += map3[64];
  } else if (tail === 1) {
    result += map3[bits >> 2 & 63];
    result += map3[bits << 4 & 63];
    result += map3[64];
    result += map3[64];
  }
  return result;
}
function isBinary(obj) {
  return Object.prototype.toString.call(obj) === "[object Uint8Array]";
}
var binary = new type("tag:yaml.org,2002:binary", {
  kind: "scalar",
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});
var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var _toString$2 = Object.prototype.toString;
function resolveYamlOmap(data) {
  if (data === null)
    return true;
  var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;
    if (_toString$2.call(pair) !== "[object Object]")
      return false;
    for (pairKey in pair) {
      if (_hasOwnProperty$3.call(pair, pairKey)) {
        if (!pairHasKey)
          pairHasKey = true;
        else
          return false;
      }
    }
    if (!pairHasKey)
      return false;
    if (objectKeys.indexOf(pairKey) === -1)
      objectKeys.push(pairKey);
    else
      return false;
  }
  return true;
}
function constructYamlOmap(data) {
  return data !== null ? data : [];
}
var omap = new type("tag:yaml.org,2002:omap", {
  kind: "sequence",
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});
var _toString$1 = Object.prototype.toString;
function resolveYamlPairs(data) {
  if (data === null)
    return true;
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    if (_toString$1.call(pair) !== "[object Object]")
      return false;
    keys = Object.keys(pair);
    if (keys.length !== 1)
      return false;
    result[index] = [keys[0], pair[keys[0]]];
  }
  return true;
}
function constructYamlPairs(data) {
  if (data === null)
    return [];
  var index, length, pair, keys, result, object = data;
  result = new Array(object.length);
  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    keys = Object.keys(pair);
    result[index] = [keys[0], pair[keys[0]]];
  }
  return result;
}
var pairs = new type("tag:yaml.org,2002:pairs", {
  kind: "sequence",
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});
var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
  if (data === null)
    return true;
  var key, object = data;
  for (key in object) {
    if (_hasOwnProperty$2.call(object, key)) {
      if (object[key] !== null)
        return false;
    }
  }
  return true;
}
function constructYamlSet(data) {
  return data !== null ? data : {};
}
var set = new type("tag:yaml.org,2002:set", {
  kind: "mapping",
  resolve: resolveYamlSet,
  construct: constructYamlSet
});
var _default = core.extend({
  implicit: [
    timestamp,
    merge
  ],
  explicit: [
    binary,
    omap,
    pairs,
    set
  ]
});
var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
function is_EOL(c2) {
  return c2 === 10 || c2 === 13;
}
function is_WHITE_SPACE(c2) {
  return c2 === 9 || c2 === 32;
}
function is_WS_OR_EOL(c2) {
  return c2 === 9 || c2 === 32 || c2 === 10 || c2 === 13;
}
function is_FLOW_INDICATOR(c2) {
  return c2 === 44 || c2 === 91 || c2 === 93 || c2 === 123 || c2 === 125;
}
function fromHexCode(c2) {
  var lc;
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  lc = c2 | 32;
  if (97 <= lc && lc <= 102) {
    return lc - 97 + 10;
  }
  return -1;
}
function escapedHexLen(c2) {
  if (c2 === 120) {
    return 2;
  }
  if (c2 === 117) {
    return 4;
  }
  if (c2 === 85) {
    return 8;
  }
  return 0;
}
function fromDecimalCode(c2) {
  if (48 <= c2 && c2 <= 57) {
    return c2 - 48;
  }
  return -1;
}
function simpleEscapeSequence(c2) {
  return c2 === 48 ? "\0" : c2 === 97 ? "\x07" : c2 === 98 ? "\b" : c2 === 116 ? "	" : c2 === 9 ? "	" : c2 === 110 ? "\n" : c2 === 118 ? "\v" : c2 === 102 ? "\f" : c2 === 114 ? "\r" : c2 === 101 ? "\x1B" : c2 === 32 ? " " : c2 === 34 ? '"' : c2 === 47 ? "/" : c2 === 92 ? "\\" : c2 === 78 ? "\x85" : c2 === 95 ? "\xA0" : c2 === 76 ? "\u2028" : c2 === 80 ? "\u2029" : "";
}
function charFromCodepoint(c2) {
  if (c2 <= 65535) {
    return String.fromCharCode(c2);
  }
  return String.fromCharCode(
    (c2 - 65536 >> 10) + 55296,
    (c2 - 65536 & 1023) + 56320
  );
}
var simpleEscapeCheck = new Array(256);
var simpleEscapeMap = new Array(256);
for (i2 = 0; i2 < 256; i2++) {
  simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
  simpleEscapeMap[i2] = simpleEscapeSequence(i2);
}
var i2;
function State$1(input, options) {
  this.input = input;
  this.filename = options["filename"] || null;
  this.schema = options["schema"] || _default;
  this.onWarning = options["onWarning"] || null;
  this.legacy = options["legacy"] || false;
  this.json = options["json"] || false;
  this.listener = options["listener"] || null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap = this.schema.compiledTypeMap;
  this.length = input.length;
  this.position = 0;
  this.line = 0;
  this.lineStart = 0;
  this.lineIndent = 0;
  this.firstTabInLine = -1;
  this.documents = [];
}
function generateError(state, message) {
  var mark = {
    name: state.filename,
    buffer: state.input.slice(0, -1),
    // omit trailing \0
    position: state.position,
    line: state.line,
    column: state.position - state.lineStart
  };
  mark.snippet = snippet(mark);
  return new exception(message, mark);
}
function throwError(state, message) {
  throw generateError(state, message);
}
function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}
var directiveHandlers = {
  YAML: function handleYamlDirective(state, name, args) {
    var match, major, minor;
    if (state.version !== null) {
      throwError(state, "duplication of %YAML directive");
    }
    if (args.length !== 1) {
      throwError(state, "YAML directive accepts exactly one argument");
    }
    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
    if (match === null) {
      throwError(state, "ill-formed argument of the YAML directive");
    }
    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);
    if (major !== 1) {
      throwError(state, "unacceptable YAML version of the document");
    }
    state.version = args[0];
    state.checkLineBreaks = minor < 2;
    if (minor !== 1 && minor !== 2) {
      throwWarning(state, "unsupported YAML version of the document");
    }
  },
  TAG: function handleTagDirective(state, name, args) {
    var handle, prefix;
    if (args.length !== 2) {
      throwError(state, "TAG directive accepts exactly two arguments");
    }
    handle = args[0];
    prefix = args[1];
    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
    }
    if (_hasOwnProperty$1.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }
    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
    }
    try {
      prefix = decodeURIComponent(prefix);
    } catch (err) {
      throwError(state, "tag prefix is malformed: " + prefix);
    }
    state.tagMap[handle] = prefix;
  }
};
function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;
  if (start < end) {
    _result = state.input.slice(start, end);
    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
          throwError(state, "expected valid JSON character");
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, "the stream contains non-printable characters");
    }
    state.result += _result;
  }
}
function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;
  if (!common.isObject(source)) {
    throwError(state, "cannot merge mappings; the provided source object is unacceptable");
  }
  sourceKeys = Object.keys(source);
  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];
    if (!_hasOwnProperty$1.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}
function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
  var index, quantity;
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);
    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, "nested arrays are not supported inside keys");
      }
      if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
        keyNode[index] = "[object Object]";
      }
    }
  }
  if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
    keyNode = "[object Object]";
  }
  keyNode = String(keyNode);
  if (_result === null) {
    _result = {};
  }
  if (keyTag === "tag:yaml.org,2002:merge") {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json && !_hasOwnProperty$1.call(overridableKeys, keyNode) && _hasOwnProperty$1.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.lineStart = startLineStart || state.lineStart;
      state.position = startPos || state.position;
      throwError(state, "duplicated mapping key");
    }
    if (keyNode === "__proto__") {
      Object.defineProperty(_result, keyNode, {
        configurable: true,
        enumerable: true,
        writable: true,
        value: valueNode
      });
    } else {
      _result[keyNode] = valueNode;
    }
    delete overridableKeys[keyNode];
  }
  return _result;
}
function readLineBreak(state) {
  var ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 10) {
    state.position++;
  } else if (ch === 13) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 10) {
      state.position++;
    }
  } else {
    throwError(state, "a line break is expected");
  }
  state.line += 1;
  state.lineStart = state.position;
  state.firstTabInLine = -1;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      if (ch === 9 && state.firstTabInLine === -1) {
        state.firstTabInLine = state.position;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    if (allowComments && ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 10 && ch !== 13 && ch !== 0);
    }
    if (is_EOL(ch)) {
      readLineBreak(state);
      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;
      while (ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }
  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, "deficient indentation");
  }
  return lineBreaks;
}
function testDocumentSeparator(state) {
  var _position = state.position, ch;
  ch = state.input.charCodeAt(_position);
  if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
    _position += 3;
    ch = state.input.charCodeAt(_position);
    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }
  return false;
}
function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += " ";
  } else if (count > 1) {
    state.result += common.repeat("\n", count - 1);
  }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
  ch = state.input.charCodeAt(state.position);
  if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
    return false;
  }
  if (ch === 63 || ch === 45) {
    following = state.input.charCodeAt(state.position + 1);
    if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }
  state.kind = "scalar";
  state.result = "";
  captureStart = captureEnd = state.position;
  hasPendingContent = false;
  while (ch !== 0) {
    if (ch === 58) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }
    } else if (ch === 35) {
      preceding = state.input.charCodeAt(state.position - 1);
      if (is_WS_OR_EOL(preceding)) {
        break;
      }
    } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;
    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);
      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }
    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }
    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }
    ch = state.input.charCodeAt(++state.position);
  }
  captureSegment(state, captureStart, captureEnd, false);
  if (state.result) {
    return true;
  }
  state.kind = _kind;
  state.result = _result;
  return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
  var ch, captureStart, captureEnd;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 39) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 39) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (ch === 39) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a single quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a single quoted scalar");
}
function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 34) {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  state.position++;
  captureStart = captureEnd = state.position;
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 34) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;
    } else if (ch === 92) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);
      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;
      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;
        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);
          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;
          } else {
            throwError(state, "expected hexadecimal character");
          }
        }
        state.result += charFromCodepoint(hexResult);
        state.position++;
      } else {
        throwError(state, "unknown escape sequence");
      }
      captureStart = captureEnd = state.position;
    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;
    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, "unexpected end of the document within a double quoted scalar");
    } else {
      state.position++;
      captureEnd = state.position;
    }
  }
  throwError(state, "unexpected end of the stream within a double quoted scalar");
}
function readFlowCollection(state, nodeIndent) {
  var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 91) {
    terminator = 93;
    isMapping = false;
    _result = [];
  } else if (ch === 123) {
    terminator = 125;
    isMapping = true;
    _result = {};
  } else {
    return false;
  }
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(++state.position);
  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? "mapping" : "sequence";
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, "missed comma between flow collection entries");
    } else if (ch === 44) {
      throwError(state, "expected the node content, but found ','");
    }
    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;
    if (ch === 63) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }
    _line = state.line;
    _lineStart = state.lineStart;
    _pos = state.position;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if ((isExplicitPair || state.line === _line) && ch === 58) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }
    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
    } else {
      _result.push(keyNode);
    }
    skipSeparationSpace(state, true, nodeIndent);
    ch = state.input.charCodeAt(state.position);
    if (ch === 44) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }
  throwError(state, "unexpected end of the stream within a flow collection");
}
function readBlockScalar(state, nodeIndent) {
  var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch === 124) {
    folding = false;
  } else if (ch === 62) {
    folding = true;
  } else {
    return false;
  }
  state.kind = "scalar";
  state.result = "";
  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);
    if (ch === 43 || ch === 45) {
      if (CHOMPING_CLIP === chomping) {
        chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, "repeat of a chomping mode identifier");
      }
    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, "repeat of an indentation width identifier");
      }
    } else {
      break;
    }
  }
  if (is_WHITE_SPACE(ch)) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (is_WHITE_SPACE(ch));
    if (ch === 35) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (!is_EOL(ch) && ch !== 0);
    }
  }
  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;
    ch = state.input.charCodeAt(state.position);
    while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }
    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }
    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }
    if (state.lineIndent < textIndent) {
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) {
          state.result += "\n";
        }
      }
      break;
    }
    if (folding) {
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat("\n", emptyLines + 1);
      } else if (emptyLines === 0) {
        if (didReadContent) {
          state.result += " ";
        }
      } else {
        state.result += common.repeat("\n", emptyLines);
      }
    } else {
      state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
    }
    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;
    while (!is_EOL(ch) && ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, state.position, false);
  }
  return true;
}
function readBlockSequence(state, nodeIndent) {
  var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    if (ch !== 45) {
      break;
    }
    following = state.input.charCodeAt(state.position + 1);
    if (!is_WS_OR_EOL(following)) {
      break;
    }
    detected = true;
    state.position++;
    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }
    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a sequence entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "sequence";
    state.result = _result;
    return true;
  }
  return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
  var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
  if (state.firstTabInLine !== -1)
    return false;
  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }
  ch = state.input.charCodeAt(state.position);
  while (ch !== 0) {
    if (!atExplicitKey && state.firstTabInLine !== -1) {
      state.position = state.firstTabInLine;
      throwError(state, "tab characters must not be used in indentation");
    }
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line;
    if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
      if (ch === 63) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
          keyTag = keyNode = valueNode = null;
        }
        detected = true;
        atExplicitKey = true;
        allowCompact = true;
      } else if (atExplicitKey) {
        atExplicitKey = false;
        allowCompact = true;
      } else {
        throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
      }
      state.position += 1;
      ch = following;
    } else {
      _keyLine = state.line;
      _keyLineStart = state.lineStart;
      _keyPos = state.position;
      if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        break;
      }
      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 58) {
          ch = state.input.charCodeAt(++state.position);
          if (!is_WS_OR_EOL(ch)) {
            throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
          }
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;
        } else if (detected) {
          throwError(state, "can not read an implicit mapping pair; a colon is missed");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else if (detected) {
        throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true;
      }
    }
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (atExplicitKey) {
        _keyLine = state.line;
        _keyLineStart = state.lineStart;
        _keyPos = state.position;
      }
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }
      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
        keyTag = keyNode = valueNode = null;
      }
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }
    if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
      throwError(state, "bad indentation of a mapping entry");
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
  }
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = "mapping";
    state.result = _result;
  }
  return detected;
}
function readTagProperty(state) {
  var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 33)
    return false;
  if (state.tag !== null) {
    throwError(state, "duplication of a tag property");
  }
  ch = state.input.charCodeAt(++state.position);
  if (ch === 60) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);
  } else if (ch === 33) {
    isNamed = true;
    tagHandle = "!!";
    ch = state.input.charCodeAt(++state.position);
  } else {
    tagHandle = "!";
  }
  _position = state.position;
  if (isVerbatim) {
    do {
      ch = state.input.charCodeAt(++state.position);
    } while (ch !== 0 && ch !== 62);
    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, "unexpected end of the stream within a verbatim tag");
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      if (ch === 33) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);
          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, "named tag handle cannot contain such characters");
          }
          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, "tag suffix cannot contain exclamation marks");
        }
      }
      ch = state.input.charCodeAt(++state.position);
    }
    tagName = state.input.slice(_position, state.position);
    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, "tag suffix cannot contain flow indicator characters");
    }
  }
  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, "tag name cannot contain such characters: " + tagName);
  }
  try {
    tagName = decodeURIComponent(tagName);
  } catch (err) {
    throwError(state, "tag name is malformed: " + tagName);
  }
  if (isVerbatim) {
    state.tag = tagName;
  } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;
  } else if (tagHandle === "!") {
    state.tag = "!" + tagName;
  } else if (tagHandle === "!!") {
    state.tag = "tag:yaml.org,2002:" + tagName;
  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }
  return true;
}
function readAnchorProperty(state) {
  var _position, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 38)
    return false;
  if (state.anchor !== null) {
    throwError(state, "duplication of an anchor property");
  }
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an anchor node must contain at least one character");
  }
  state.anchor = state.input.slice(_position, state.position);
  return true;
}
function readAlias(state) {
  var _position, alias, ch;
  ch = state.input.charCodeAt(state.position);
  if (ch !== 42)
    return false;
  ch = state.input.charCodeAt(++state.position);
  _position = state.position;
  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }
  if (state.position === _position) {
    throwError(state, "name of an alias node must contain at least one character");
  }
  alias = state.input.slice(_position, state.position);
  if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }
  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type2, flowIndent, blockIndent;
  if (state.listener !== null) {
    state.listener("open", state);
  }
  state.tag = null;
  state.anchor = null;
  state.kind = null;
  state.result = null;
  allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;
      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }
  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }
  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }
  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }
    blockIndent = state.position - state.lineStart;
    if (indentStatus === 1) {
      if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;
        } else if (readAlias(state)) {
          hasContent = true;
          if (state.tag !== null || state.anchor !== null) {
            throwError(state, "alias node should not have any properties");
          }
        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;
          if (state.tag === null) {
            state.tag = "?";
          }
        }
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }
  if (state.tag === null) {
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = state.result;
    }
  } else if (state.tag === "?") {
    if (state.result !== null && state.kind !== "scalar") {
      throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
    }
    for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
      type2 = state.implicitTypes[typeIndex];
      if (type2.resolve(state.result)) {
        state.result = type2.construct(state.result);
        state.tag = type2.tag;
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
        break;
      }
    }
  } else if (state.tag !== "!") {
    if (_hasOwnProperty$1.call(state.typeMap[state.kind || "fallback"], state.tag)) {
      type2 = state.typeMap[state.kind || "fallback"][state.tag];
    } else {
      type2 = null;
      typeList = state.typeMap.multi[state.kind || "fallback"];
      for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
        if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
          type2 = typeList[typeIndex];
          break;
        }
      }
    }
    if (!type2) {
      throwError(state, "unknown tag !<" + state.tag + ">");
    }
    if (state.result !== null && type2.kind !== state.kind) {
      throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type2.kind + '", not "' + state.kind + '"');
    }
    if (!type2.resolve(state.result, state.tag)) {
      throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
    } else {
      state.result = type2.construct(state.result, state.tag);
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = state.result;
      }
    }
  }
  if (state.listener !== null) {
    state.listener("close", state);
  }
  return state.tag !== null || state.anchor !== null || hasContent;
}
function readDocument(state) {
  var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = /* @__PURE__ */ Object.create(null);
  state.anchorMap = /* @__PURE__ */ Object.create(null);
  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);
    ch = state.input.charCodeAt(state.position);
    if (state.lineIndent > 0 || ch !== 37) {
      break;
    }
    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];
    if (directiveName.length < 1) {
      throwError(state, "directive name must not be less than one character in length");
    }
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && !is_EOL(ch));
        break;
      }
      if (is_EOL(ch))
        break;
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveArgs.push(state.input.slice(_position, state.position));
    }
    if (ch !== 0)
      readLineBreak(state);
    if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }
  skipSeparationSpace(state, true, -1);
  if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);
  } else if (hasDirectives) {
    throwError(state, "directives end mark is expected");
  }
  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);
  if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, "non-ASCII line breaks are interpreted as content");
  }
  state.documents.push(state.result);
  if (state.position === state.lineStart && testDocumentSeparator(state)) {
    if (state.input.charCodeAt(state.position) === 46) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }
  if (state.position < state.length - 1) {
    throwError(state, "end of the stream or a document separator is expected");
  } else {
    return;
  }
}
function loadDocuments(input, options) {
  input = String(input);
  options = options || {};
  if (input.length !== 0) {
    if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
      input += "\n";
    }
    if (input.charCodeAt(0) === 65279) {
      input = input.slice(1);
    }
  }
  var state = new State$1(input, options);
  var nullpos = input.indexOf("\0");
  if (nullpos !== -1) {
    state.position = nullpos;
    throwError(state, "null byte is not allowed in input");
  }
  state.input += "\0";
  while (state.input.charCodeAt(state.position) === 32) {
    state.lineIndent += 1;
    state.position += 1;
  }
  while (state.position < state.length - 1) {
    readDocument(state);
  }
  return state.documents;
}
function loadAll$1(input, iterator, options) {
  if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
    options = iterator;
    iterator = null;
  }
  var documents = loadDocuments(input, options);
  if (typeof iterator !== "function") {
    return documents;
  }
  for (var index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}
function load$1(input, options) {
  var documents = loadDocuments(input, options);
  if (documents.length === 0) {
    return void 0;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new exception("expected a single document in the stream, but found more");
}
var loadAll_1 = loadAll$1;
var load_1 = load$1;
var loader = {
  loadAll: loadAll_1,
  load: load_1
};
var _toString = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_BOM = 65279;
var CHAR_TAB = 9;
var CHAR_LINE_FEED = 10;
var CHAR_CARRIAGE_RETURN = 13;
var CHAR_SPACE = 32;
var CHAR_EXCLAMATION = 33;
var CHAR_DOUBLE_QUOTE = 34;
var CHAR_SHARP = 35;
var CHAR_PERCENT = 37;
var CHAR_AMPERSAND = 38;
var CHAR_SINGLE_QUOTE = 39;
var CHAR_ASTERISK = 42;
var CHAR_COMMA = 44;
var CHAR_MINUS = 45;
var CHAR_COLON = 58;
var CHAR_EQUALS = 61;
var CHAR_GREATER_THAN = 62;
var CHAR_QUESTION = 63;
var CHAR_COMMERCIAL_AT = 64;
var CHAR_LEFT_SQUARE_BRACKET = 91;
var CHAR_RIGHT_SQUARE_BRACKET = 93;
var CHAR_GRAVE_ACCENT = 96;
var CHAR_LEFT_CURLY_BRACKET = 123;
var CHAR_VERTICAL_LINE = 124;
var CHAR_RIGHT_CURLY_BRACKET = 125;
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0] = "\\0";
ESCAPE_SEQUENCES[7] = "\\a";
ESCAPE_SEQUENCES[8] = "\\b";
ESCAPE_SEQUENCES[9] = "\\t";
ESCAPE_SEQUENCES[10] = "\\n";
ESCAPE_SEQUENCES[11] = "\\v";
ESCAPE_SEQUENCES[12] = "\\f";
ESCAPE_SEQUENCES[13] = "\\r";
ESCAPE_SEQUENCES[27] = "\\e";
ESCAPE_SEQUENCES[34] = '\\"';
ESCAPE_SEQUENCES[92] = "\\\\";
ESCAPE_SEQUENCES[133] = "\\N";
ESCAPE_SEQUENCES[160] = "\\_";
ESCAPE_SEQUENCES[8232] = "\\L";
ESCAPE_SEQUENCES[8233] = "\\P";
var DEPRECATED_BOOLEANS_SYNTAX = [
  "y",
  "Y",
  "yes",
  "Yes",
  "YES",
  "on",
  "On",
  "ON",
  "n",
  "N",
  "no",
  "No",
  "NO",
  "off",
  "Off",
  "OFF"
];
var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
function compileStyleMap(schema2, map3) {
  var result, keys, index, length, tag, style, type2;
  if (map3 === null)
    return {};
  result = {};
  keys = Object.keys(map3);
  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map3[tag]);
    if (tag.slice(0, 2) === "!!") {
      tag = "tag:yaml.org,2002:" + tag.slice(2);
    }
    type2 = schema2.compiledTypeMap["fallback"][tag];
    if (type2 && _hasOwnProperty.call(type2.styleAliases, style)) {
      style = type2.styleAliases[style];
    }
    result[tag] = style;
  }
  return result;
}
function encodeHex(character) {
  var string, handle, length;
  string = character.toString(16).toUpperCase();
  if (character <= 255) {
    handle = "x";
    length = 2;
  } else if (character <= 65535) {
    handle = "u";
    length = 4;
  } else if (character <= 4294967295) {
    handle = "U";
    length = 8;
  } else {
    throw new exception("code point within a string may not be greater than 0xFFFFFFFF");
  }
  return "\\" + handle + common.repeat("0", length - string.length) + string;
}
var QUOTING_TYPE_SINGLE = 1;
var QUOTING_TYPE_DOUBLE = 2;
function State(options) {
  this.schema = options["schema"] || _default;
  this.indent = Math.max(1, options["indent"] || 2);
  this.noArrayIndent = options["noArrayIndent"] || false;
  this.skipInvalid = options["skipInvalid"] || false;
  this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
  this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
  this.sortKeys = options["sortKeys"] || false;
  this.lineWidth = options["lineWidth"] || 80;
  this.noRefs = options["noRefs"] || false;
  this.noCompatMode = options["noCompatMode"] || false;
  this.condenseFlow = options["condenseFlow"] || false;
  this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
  this.forceQuotes = options["forceQuotes"] || false;
  this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;
  this.tag = null;
  this.result = "";
  this.duplicates = [];
  this.usedDuplicates = null;
}
function indentString(string, spaces) {
  var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
  while (position < length) {
    next = string.indexOf("\n", position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }
    if (line.length && line !== "\n")
      result += ind;
    result += line;
  }
  return result;
}
function generateNextLine(state, level) {
  return "\n" + common.repeat(" ", state.indent * level);
}
function testImplicitResolving(state, str2) {
  var index, length, type2;
  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type2 = state.implicitTypes[index];
    if (type2.resolve(str2)) {
      return true;
    }
  }
  return false;
}
function isWhitespace(c2) {
  return c2 === CHAR_SPACE || c2 === CHAR_TAB;
}
function isPrintable(c2) {
  return 32 <= c2 && c2 <= 126 || 161 <= c2 && c2 <= 55295 && c2 !== 8232 && c2 !== 8233 || 57344 <= c2 && c2 <= 65533 && c2 !== CHAR_BOM || 65536 <= c2 && c2 <= 1114111;
}
function isNsCharOrWhitespace(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && c2 !== CHAR_CARRIAGE_RETURN && c2 !== CHAR_LINE_FEED;
}
function isPlainSafe(c2, prev, inblock) {
  var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c2);
  var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c2);
  return (
    // ns-plain-safe
    (inblock ? (
      // c = flow-in
      cIsNsCharOrWhitespace
    ) : cIsNsCharOrWhitespace && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET) && c2 !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c2 === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
  );
}
function isPlainSafeFirst(c2) {
  return isPrintable(c2) && c2 !== CHAR_BOM && !isWhitespace(c2) && c2 !== CHAR_MINUS && c2 !== CHAR_QUESTION && c2 !== CHAR_COLON && c2 !== CHAR_COMMA && c2 !== CHAR_LEFT_SQUARE_BRACKET && c2 !== CHAR_RIGHT_SQUARE_BRACKET && c2 !== CHAR_LEFT_CURLY_BRACKET && c2 !== CHAR_RIGHT_CURLY_BRACKET && c2 !== CHAR_SHARP && c2 !== CHAR_AMPERSAND && c2 !== CHAR_ASTERISK && c2 !== CHAR_EXCLAMATION && c2 !== CHAR_VERTICAL_LINE && c2 !== CHAR_EQUALS && c2 !== CHAR_GREATER_THAN && c2 !== CHAR_SINGLE_QUOTE && c2 !== CHAR_DOUBLE_QUOTE && c2 !== CHAR_PERCENT && c2 !== CHAR_COMMERCIAL_AT && c2 !== CHAR_GRAVE_ACCENT;
}
function isPlainSafeLast(c2) {
  return !isWhitespace(c2) && c2 !== CHAR_COLON;
}
function codePointAt(string, pos) {
  var first = string.charCodeAt(pos), second;
  if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
    second = string.charCodeAt(pos + 1);
    if (second >= 56320 && second <= 57343) {
      return (first - 55296) * 1024 + second - 56320 + 65536;
    }
  }
  return first;
}
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}
var STYLE_PLAIN = 1;
var STYLE_SINGLE = 2;
var STYLE_LITERAL = 3;
var STYLE_FOLDED = 4;
var STYLE_DOUBLE = 5;
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
  var i2;
  var char = 0;
  var prevChar = null;
  var hasLineBreak = false;
  var hasFoldableLine = false;
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1;
  var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
  if (singleLineOnly || forceQuotes) {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
  } else {
    for (i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
      char = codePointAt(string, i2);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
          i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
          previousLineBreak = i2;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char, prevChar, inblock);
      prevChar = char;
    }
    hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i2 - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
  }
  if (!hasLineBreak && !hasFoldableLine) {
    if (plain && !forceQuotes && !testAmbiguousType(string)) {
      return STYLE_PLAIN;
    }
    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
  }
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  if (!forceQuotes) {
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
}
function writeScalar(state, string, level, iskey, inblock) {
  state.dump = function() {
    if (string.length === 0) {
      return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
    }
    if (!state.noCompatMode) {
      if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
        return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
      }
    }
    var indent = state.indent * Math.max(1, level);
    var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
    var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
    function testAmbiguity(string2) {
      return testImplicitResolving(state, string2);
    }
    switch (chooseScalarStyle(
      string,
      singleLineOnly,
      state.indent,
      lineWidth,
      testAmbiguity,
      state.quotingType,
      state.forceQuotes && !iskey,
      inblock
    )) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string) + '"';
      default:
        throw new exception("impossible error: invalid scalar style");
    }
  }();
}
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
  var clip = string[string.length - 1] === "\n";
  var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
  var chomp = keep ? "+" : clip ? "" : "-";
  return indentIndicator + chomp + "\n";
}
function dropEndingNewline(string) {
  return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
}
function foldString(string, width) {
  var lineRe = /(\n+)([^\n]*)/g;
  var result = function() {
    var nextLF = string.indexOf("\n");
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }();
  var prevMoreIndented = string[0] === "\n" || string[0] === " ";
  var moreIndented;
  var match;
  while (match = lineRe.exec(string)) {
    var prefix = match[1], line = match[2];
    moreIndented = line[0] === " ";
    result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }
  return result;
}
function foldLine(line, width) {
  if (line === "" || line[0] === " ")
    return line;
  var breakRe = / [^ ]/g;
  var match;
  var start = 0, end, curr = 0, next = 0;
  var result = "";
  while (match = breakRe.exec(line)) {
    next = match.index;
    if (next - start > width) {
      end = curr > start ? curr : next;
      result += "\n" + line.slice(start, end);
      start = end + 1;
    }
    curr = next;
  }
  result += "\n";
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }
  return result.slice(1);
}
function escapeString(string) {
  var result = "";
  var char = 0;
  var escapeSeq;
  for (var i2 = 0; i2 < string.length; char >= 65536 ? i2 += 2 : i2++) {
    char = codePointAt(string, i2);
    escapeSeq = ESCAPE_SEQUENCES[char];
    if (!escapeSeq && isPrintable(char)) {
      result += string[i2];
      if (char >= 65536)
        result += string[i2 + 1];
    } else {
      result += escapeSeq || encodeHex(char);
    }
  }
  return result;
}
function writeFlowSequence(state, level, object) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
      if (_result !== "")
        _result += "," + (!state.condenseFlow ? " " : "");
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = "[" + _result + "]";
}
function writeBlockSequence(state, level, object, compact) {
  var _result = "", _tag = state.tag, index, length, value;
  for (index = 0, length = object.length; index < length; index += 1) {
    value = object[index];
    if (state.replacer) {
      value = state.replacer.call(object, String(index), value);
    }
    if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
      if (!compact || _result !== "") {
        _result += generateNextLine(state, level);
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += "-";
      } else {
        _result += "- ";
      }
      _result += state.dump;
    }
  }
  state.tag = _tag;
  state.dump = _result || "[]";
}
function writeFlowMapping(state, level, object) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (_result !== "")
      pairBuffer += ", ";
    if (state.condenseFlow)
      pairBuffer += '"';
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level, objectKey, false, false)) {
      continue;
    }
    if (state.dump.length > 1024)
      pairBuffer += "? ";
    pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
    if (!writeNode(state, level, objectValue, false, false)) {
      continue;
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = "{" + _result + "}";
}
function writeBlockMapping(state, level, object, compact) {
  var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
  if (state.sortKeys === true) {
    objectKeyList.sort();
  } else if (typeof state.sortKeys === "function") {
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    throw new exception("sortKeys must be a boolean or a function");
  }
  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = "";
    if (!compact || _result !== "") {
      pairBuffer += generateNextLine(state, level);
    }
    objectKey = objectKeyList[index];
    objectValue = object[objectKey];
    if (state.replacer) {
      objectValue = state.replacer.call(object, objectKey, objectValue);
    }
    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue;
    }
    explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += "?";
      } else {
        pairBuffer += "? ";
      }
    }
    pairBuffer += state.dump;
    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }
    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue;
    }
    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ":";
    } else {
      pairBuffer += ": ";
    }
    pairBuffer += state.dump;
    _result += pairBuffer;
  }
  state.tag = _tag;
  state.dump = _result || "{}";
}
function detectType(state, object, explicit) {
  var _result, typeList, index, length, type2, style;
  typeList = explicit ? state.explicitTypes : state.implicitTypes;
  for (index = 0, length = typeList.length; index < length; index += 1) {
    type2 = typeList[index];
    if ((type2.instanceOf || type2.predicate) && (!type2.instanceOf || typeof object === "object" && object instanceof type2.instanceOf) && (!type2.predicate || type2.predicate(object))) {
      if (explicit) {
        if (type2.multi && type2.representName) {
          state.tag = type2.representName(object);
        } else {
          state.tag = type2.tag;
        }
      } else {
        state.tag = "?";
      }
      if (type2.represent) {
        style = state.styleMap[type2.tag] || type2.defaultStyle;
        if (_toString.call(type2.represent) === "[object Function]") {
          _result = type2.represent(object, style);
        } else if (_hasOwnProperty.call(type2.represent, style)) {
          _result = type2.represent[style](object, style);
        } else {
          throw new exception("!<" + type2.tag + '> tag resolver accepts not "' + style + '" style');
        }
        state.dump = _result;
      }
      return true;
    }
  }
  return false;
}
function writeNode(state, level, object, block, compact, iskey, isblockseq) {
  state.tag = null;
  state.dump = object;
  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }
  var type2 = _toString.call(state.dump);
  var inblock = block;
  var tagStr;
  if (block) {
    block = state.flowLevel < 0 || state.flowLevel > level;
  }
  var objectOrArray = type2 === "[object Object]" || type2 === "[object Array]", duplicateIndex, duplicate;
  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }
  if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
    compact = false;
  }
  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = "*ref_" + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type2 === "[object Object]") {
      if (block && Object.keys(state.dump).length !== 0) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object Array]") {
      if (block && state.dump.length !== 0) {
        if (state.noArrayIndent && !isblockseq && level > 0) {
          writeBlockSequence(state, level - 1, state.dump, compact);
        } else {
          writeBlockSequence(state, level, state.dump, compact);
        }
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, level, state.dump);
        if (duplicate) {
          state.dump = "&ref_" + duplicateIndex + " " + state.dump;
        }
      }
    } else if (type2 === "[object String]") {
      if (state.tag !== "?") {
        writeScalar(state, state.dump, level, iskey, inblock);
      }
    } else if (type2 === "[object Undefined]") {
      return false;
    } else {
      if (state.skipInvalid)
        return false;
      throw new exception("unacceptable kind of an object to dump " + type2);
    }
    if (state.tag !== null && state.tag !== "?") {
      tagStr = encodeURI(
        state.tag[0] === "!" ? state.tag.slice(1) : state.tag
      ).replace(/!/g, "%21");
      if (state.tag[0] === "!") {
        tagStr = "!" + tagStr;
      } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
        tagStr = "!!" + tagStr.slice(18);
      } else {
        tagStr = "!<" + tagStr + ">";
      }
      state.dump = tagStr + " " + state.dump;
    }
  }
  return true;
}
function getDuplicateReferences(object, state) {
  var objects = [], duplicatesIndexes = [], index, length;
  inspectNode(object, objects, duplicatesIndexes);
  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList, index, length;
  if (object !== null && typeof object === "object") {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);
      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);
        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}
function dump$1(input, options) {
  options = options || {};
  var state = new State(options);
  if (!state.noRefs)
    getDuplicateReferences(input, state);
  var value = input;
  if (state.replacer) {
    value = state.replacer.call({ "": value }, "", value);
  }
  if (writeNode(state, 0, value, true, true))
    return state.dump + "\n";
  return "";
}
var dump_1 = dump$1;
var dumper = {
  dump: dump_1
};
function renamed(from, to) {
  return function() {
    throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
  };
}
var Type = type;
var Schema = schema;
var FAILSAFE_SCHEMA = failsafe;
var JSON_SCHEMA = json;
var CORE_SCHEMA = core;
var DEFAULT_SCHEMA = _default;
var load = loader.load;
var loadAll = loader.loadAll;
var dump = dumper.dump;
var YAMLException = exception;
var types = {
  binary,
  float,
  map: map2,
  null: _null,
  pairs,
  set,
  timestamp,
  bool,
  int,
  merge,
  omap,
  seq,
  str
};
var safeLoad = renamed("safeLoad", "load");
var safeLoadAll = renamed("safeLoadAll", "loadAll");
var safeDump = renamed("safeDump", "dump");
var jsYaml = {
  Type,
  Schema,
  FAILSAFE_SCHEMA,
  JSON_SCHEMA,
  CORE_SCHEMA,
  DEFAULT_SCHEMA,
  load,
  loadAll,
  dump,
  YAMLException,
  types,
  safeLoad,
  safeLoadAll,
  safeDump
};
var js_yaml_default = jsYaml;

// src/jekyll/FrontMatterConverter.ts
var FrontMatterConverter = class {
  constructor(fileName, resourcePath, isEnableBanner = false, isEnableUpdateFrontmatterTimeOnEdit = false) {
    this.fileName = fileName;
    this.resourcePath = resourcePath;
    this.isEnableBanner = isEnableBanner;
    this.isEnableUpdateFrontmatterTimeOnEdit = isEnableUpdateFrontmatterTimeOnEdit;
  }
  parseFrontMatter(content) {
    if (!content.startsWith("---")) {
      return [{}, content];
    }
    const endOfFrontMatter = content.indexOf("---", 3);
    if (endOfFrontMatter === -1) {
      return [{}, content];
    }
    const frontMatterLines = content.substring(3, endOfFrontMatter);
    const body = content.substring(endOfFrontMatter + 3).trimStart();
    const frontMatter = js_yaml_default.load(frontMatterLines);
    return [frontMatter, body];
  }
  convert(input) {
    const [frontMatter, body] = this.parseFrontMatter(input);
    if (Object.keys(frontMatter).length === 0) {
      return input;
    }
    if (frontMatter.title && !frontMatter.title.startsWith('"')) {
      frontMatter.title = `"${frontMatter.title}"`;
    }
    if (frontMatter.categories && JSON.stringify(frontMatter.categories).startsWith("[")) {
      frontMatter.categories = `${JSON.stringify(frontMatter.categories).replace(/,/g, ", ").replace(/"/g, "")}`;
    }
    if (frontMatter.tags && Array.isArray(frontMatter.tags)) {
      frontMatter.tags = `[${frontMatter.tags}]`.replace(/,/g, ", ");
    } else if (frontMatter.tags && !JSON.stringify(frontMatter.tags).startsWith("[")) {
      frontMatter.tags = `[${frontMatter.tags}]`;
    }
    if (body.match(/```mermaid/)) {
      frontMatter.mermaid = true.toString();
    }
    const convertedFrontMatter = this.convertImageFrontMatter({ ...frontMatter });
    const result = replaceDateFrontMatter({ ...convertedFrontMatter }, this.isEnableUpdateFrontmatterTimeOnEdit);
    return `---
${Object.entries(result).map(([key, value]) => `${key}: ${value}`).join("\n")}
---

${body}`;
  }
  convertImageFrontMatter(frontMatter) {
    if (!this.isEnableBanner) {
      return frontMatter;
    }
    if (!frontMatter.image) {
      return frontMatter;
    }
    if (ObsidianRegex.ATTACHMENT_LINK.test(frontMatter.image)) {
      const match = frontMatter.image.match(ObsidianRegex.ATTACHMENT_LINK);
      if (match) {
        frontMatter.image = frontMatter.image.replace(ObsidianRegex.ATTACHMENT_LINK, "$1.$2");
      }
    }
    frontMatter.image = convertImagePath(this.fileName, frontMatter.image, this.resourcePath);
    return frontMatter;
  }
};
function convertImagePath(postTitle, imagePath, resourcePath) {
  return `/${resourcePath}/${postTitle}/${imagePath}`;
}
function replaceDateFrontMatter(frontMatter, isEnable) {
  if (!isEnable || frontMatter.updated === void 0) {
    return frontMatter;
  }
  if (frontMatter.updated.length > 0) {
    frontMatter.date = frontMatter.updated;
    delete frontMatter.updated;
  }
  return frontMatter;
}

// src/utils.ts
var import_obsidian3 = require("obsidian");
function vaultAbsolutePath(plugin) {
  const adapter = plugin.app.vault.adapter;
  if (adapter instanceof import_obsidian3.FileSystemAdapter) {
    return adapter.getBasePath();
  }
  new import_obsidian3.Notice("Vault is not a file system adapter");
  throw new Error("Vault is not a file system adapter");
}

// src/jekyll/FootnotesConverter.ts
var FootnotesConverter = class {
  convert(input) {
    return input.replace(ObsidianRegex.SIMPLE_FOOTNOTE, (match, key) => {
      return `[^fn-nth-${key}]`;
    });
  }
};

// src/core/ConverterChain.ts
var ConverterChain = class _ConverterChain {
  constructor() {
    this.converters = [];
  }
  static create() {
    return new _ConverterChain();
  }
  chaining(converter) {
    this.converters.push(converter);
    return this;
  }
  converting(input) {
    let result = input;
    for (const converter of this.converters) {
      result = converter.convert(result);
    }
    return result;
  }
};

// src/jekyll/CommentsConverter.ts
var CommentsConverter = class {
  convert(input) {
    return input.replace(ObsidianRegex.COMMENT, (match, comments) => `<!--${comments}-->`);
  }
};

// src/jekyll/EmbedsConverter.ts
var EmbedsConverter = class {
  convert(input) {
    return input.replace(ObsidianRegex.EMBEDDED_LINK, "$1");
  }
};

// src/jekyll/FilenameConverter.ts
var FilenameConverter = class {
  convert(filename) {
    return filename.replace(".md", "").replace(/\s/g, "-").replace(/[^a-zA-Z0-9-\uAC00-\uD7A3]/g, "");
  }
};

// src/jekyll/CurlyBraceConverter.ts
var CurlyBraceConverter = class {
  constructor(isEnable = false) {
    this.isEnable = isEnable;
  }
  convert(input) {
    if (!this.isEnable) {
      return input;
    }
    return input.replace(ObsidianRegex.DOUBLE_CURLY_BRACES, (match, content) => `{% raw %}${match}{% endraw %}`);
  }
};

// src/jekyll/chirpy.ts
async function convertToChirpy(plugin) {
  await validateSettings(plugin);
  await backupOriginalNotes(plugin);
  const filenameConverter = new FilenameConverter();
  try {
    const markdownFiles = await renameMarkdownFile(plugin);
    for (const file of markdownFiles) {
      const fileName = filenameConverter.convert(file.name);
      const frontMatterConverter = new FrontMatterConverter(
        fileName,
        plugin.settings.jekyllSetting().jekyllRelativeResourcePath,
        plugin.settings.jekyllSetting().isEnableBanner,
        plugin.settings.jekyllSetting().isEnableUpdateFrontmatterTimeOnEdit
      );
      const resourceLinkConverter = new ResourceLinkConverter(
        fileName,
        plugin.settings.jekyllSetting().resourcePath(),
        vaultAbsolutePath(plugin),
        plugin.settings.attachmentsFolder,
        plugin.settings.jekyllSetting().jekyllRelativeResourcePath
      );
      const curlyBraceConverter = new CurlyBraceConverter(
        plugin.settings.jekyllSetting().isEnableCurlyBraceConvertMode
      );
      const result = ConverterChain.create().chaining(frontMatterConverter).chaining(resourceLinkConverter).chaining(curlyBraceConverter).chaining(new WikiLinkConverter()).chaining(new CalloutConverter()).chaining(new FootnotesConverter()).chaining(new CommentsConverter()).chaining(new EmbedsConverter()).converting(await plugin.app.vault.read(file));
      await plugin.app.vault.modify(file, result);
    }
    await moveFilesToChirpy(plugin);
    new import_obsidian4.Notice("Chirpy conversion complete.");
  } catch (e2) {
    console.error(e2);
    new import_obsidian4.Notice("Chirpy conversion failed.");
  }
}
async function validateSettings(plugin) {
  const adapter = plugin.app.vault.adapter;
  if (!await adapter.exists(plugin.settings.attachmentsFolder)) {
    if (plugin.settings.jekyllSetting().isAutoCreateFolder) {
      new import_obsidian4.Notice(`Auto create attachments folder: ${plugin.settings.attachmentsFolder}.`, 5e3);
      await adapter.mkdir(plugin.settings.attachmentsFolder);
    } else {
      new import_obsidian4.Notice(`Attachments folder ${plugin.settings.attachmentsFolder} does not exist.`, 5e3);
      throw new Error(`Attachments folder ${plugin.settings.attachmentsFolder} does not exist.`);
    }
  }
  if (!await adapter.exists(plugin.settings.readyFolder)) {
    if (plugin.settings.jekyllSetting().isAutoCreateFolder) {
      new import_obsidian4.Notice(`Auto create ready folder: ${plugin.settings.readyFolder}.`, 5e3);
      await adapter.mkdir(plugin.settings.readyFolder);
    } else {
      new import_obsidian4.Notice(`Ready folder ${plugin.settings.readyFolder} does not exist.`, 5e3);
      throw new Error(`Ready folder ${plugin.settings.readyFolder} does not exist.`);
    }
  }
  if (!await adapter.exists(plugin.settings.backupFolder)) {
    if (plugin.settings.jekyllSetting().isAutoCreateFolder) {
      new import_obsidian4.Notice(`Auto create backup folder: ${plugin.settings.backupFolder}.`, 5e3);
      await adapter.mkdir(plugin.settings.backupFolder);
    } else {
      new import_obsidian4.Notice(`Backup folder ${plugin.settings.backupFolder} does not exist.`, 5e3);
      throw new Error(`Backup folder ${plugin.settings.backupFolder} does not exist.`);
    }
  }
}
function getFilesInReady(plugin) {
  return plugin.app.vault.getMarkdownFiles().filter((file) => file.path.startsWith(plugin.settings.readyFolder));
}
async function backupOriginalNotes(plugin) {
  const readyFiles = getFilesInReady.call(this, plugin);
  const backupFolder = plugin.settings.backupFolder;
  const readyFolder = plugin.settings.readyFolder;
  readyFiles.forEach((file) => {
    return plugin.app.vault.copy(file, file.path.replace(readyFolder, backupFolder));
  });
}
async function renameMarkdownFile(plugin) {
  const dateString = Pt.Now.plainDateISO().toString();
  const markdownFiles = getFilesInReady.call(this, plugin);
  for (const file of markdownFiles) {
    const newFileName = dateString + "-" + file.name;
    const newFilePath = file.path.replace(file.name, newFileName).replace(/\s/g, "-");
    await plugin.app.vault.rename(file, newFilePath);
  }
  return markdownFiles;
}
async function moveFilesToChirpy(plugin) {
  const sourceFolderPath = `${vaultAbsolutePath(plugin)}/${plugin.settings.readyFolder}`;
  const targetFolderPath = plugin.settings.targetPath();
  fs2.readdir(sourceFolderPath, (err, files) => {
    if (err)
      throw err;
    files.forEach((filename) => {
      const sourceFilePath = path.join(sourceFolderPath, filename);
      const targetFilePath = path.join(targetFolderPath, filename.replace(/\s/g, "-"));
      fs2.rename(sourceFilePath, targetFilePath, (err2) => {
        if (err2) {
          console.error(err2);
          new import_obsidian4.Notice(err2.message);
          throw err2;
        }
      });
    });
  });
}

// src/main.ts
var O2Plugin = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "jekyll-chirpy-syntax",
      name: "convert to Jekyll Chirpy",
      checkCallback: (checking) => {
        if (this.settings.afterPropertiesSet()) {
          if (checking) {
            return true;
          }
          convertToChirpy(this);
        }
      }
    });
    this.addSettingTab(new O2SettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign(new JekyllSetting(), await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
/*! Bundled license information:

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)
*/
